/*
 * Copyright (c) 2006, the libsecondlife development team
 * All rights reserved.
 *
 * - Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * - Neither the name of the Second Life Reverse Engineering Team nor the names
 *   of its contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using libsecondlife;

namespace libsecondlife.Packets
{
    public class MalformedDataException : ApplicationException
    {
        public MalformedDataException() { }

        public MalformedDataException(string Message)
            : base(Message)
        {
            this.Source = "Packet decoding";
        }
    }
    
    public abstract class Header
    {
        public byte[] Data;
        public byte Flags
        {
            get { return Data[0]; }
            set { Data[0] = value; }
        }
        public bool Reliable
        {
            get { return (Data[0] & Helpers.MSG_RELIABLE) != 0; }
            set { if (value) { Data[0] += (byte)Helpers.MSG_RELIABLE; } else { Data[0] -= (byte)Helpers.MSG_RELIABLE; } }
        }
        public bool Resent
        {
            get { return (Data[0] & Helpers.MSG_RESENT) != 0; }
            set { if (value) { Data[0] += (byte)Helpers.MSG_RESENT; } else { Data[0] -= (byte)Helpers.MSG_RESENT; } }
        }
        public bool Zerocoded
        {
            get { return (Data[0] & Helpers.MSG_ZEROCODED) != 0; }
            set { if (value) { Data[0] += (byte)Helpers.MSG_ZEROCODED; } else { Data[0] -= (byte)Helpers.MSG_ZEROCODED; } }
        }
        public bool AppendedAcks
        {
            get { return (Data[0] & Helpers.MSG_APPENDED_ACKS) != 0; }
            set { if (value) { Data[0] += (byte)Helpers.MSG_APPENDED_ACKS; } else { Data[0] -= (byte)Helpers.MSG_APPENDED_ACKS; } }
        }
        public ushort Sequence
        {
            get { return (ushort)((Data[2] << 8) + Data[3]); }
            set { Data[2] = (byte)(value >> 8); Data[3] = (byte)(value % 256); }
        }
        public abstract ushort ID { get; set; }
        public abstract PacketFrequency Frequency { get; }
        public abstract void ToBytes(byte[] bytes, ref int i);
        public uint[] AckList;

        public void AcksToBytes(byte[] bytes, ref int i)
        {
            foreach (uint ack in AckList)
            {
                bytes[i++] = (byte)(ack % 256);
                bytes[i++] = (byte)((ack >> 8) % 256);
            }
            if (AckList.Length > 0) { bytes[i++] = (byte)AckList.Length; }
        }
        
        protected void CreateAckList(byte[] bytes, ref int packetEnd)
        {
            if (AppendedAcks)
            {
                try
                {
                    int count = bytes[packetEnd--];
                    AckList = new uint[count];
                    
                    for (int i = 0; i < count; i++)
                    {
                        AckList[i] = (ushort)((bytes[(packetEnd - i * 4) - 1] << 8) | (bytes[packetEnd - i * 4]));
                    }

                    packetEnd -= (count * 4);
                }
                catch (Exception)
                {
                    AckList = new uint[0];
                    throw new MalformedDataException();
                }
            }
            else
            {
                AckList = new uint[0];
            }
        }

        public static Header BuildHeader(byte[] bytes, ref int pos, ref int packetEnd)
        {
            if (bytes[4] == 0xFF)
            {
                if (bytes[5] == 0xFF)
                {
                    return new LowHeader(bytes, ref pos, ref packetEnd);
                }
                else
                {
                    return new MediumHeader(bytes, ref pos, ref packetEnd);
                }
            }
            else
            {
                return new HighHeader(bytes, ref pos, ref packetEnd);
            }
        }
    }

    public class LowHeader : Header
    {
        public override ushort ID
        {
            get { return (ushort)((Data[6] << 8) + Data[7]); }
            set { Data[6] = (byte)(value >> 8); Data[7] = (byte)(value % 256); }
        }
        public override PacketFrequency Frequency { get { return PacketFrequency.Low; } }

        public LowHeader()
        {
            Data = new byte[8];
            Data[4] = Data[5] = 0xFF;
            AckList = new uint[0];
        }

        public LowHeader(byte[] bytes, ref int pos, ref int packetEnd)
        {
            if (bytes.Length < 8) { throw new MalformedDataException(); }
            Data = new byte[8];
            Array.Copy(bytes, Data, 8);

            if ((bytes[0] & Helpers.MSG_ZEROCODED) != 0 && bytes[6] == 0)
            {
                if (bytes[7] == 1)
                {
                    Data[7] = bytes[8];
                }
                else
                {
                    throw new MalformedDataException();
                }
            }

            pos = 8;
            CreateAckList(bytes, ref packetEnd);
        }

        public override void ToBytes(byte[] bytes, ref int i)
        {
            Array.Copy(Data, 0, bytes, i, 8);
            i += 8;
        }
    }

    public class MediumHeader : Header
    {
        public override ushort ID
        {
            get { return (ushort)Data[5]; }
            set { Data[5] = (byte)value; }
        }
        public override PacketFrequency Frequency { get { return PacketFrequency.Medium; } }

        public MediumHeader()
        {
            Data = new byte[6];
            Data[4] = 0xFF;
            AckList = new uint[0];
        }

        public MediumHeader(byte[] bytes, ref int pos, ref int packetEnd)
        {
            if (bytes.Length < 6) { throw new MalformedDataException(); }
            Data = new byte[6];
            Array.Copy(bytes, Data, 6);
            pos = 6;
            CreateAckList(bytes, ref packetEnd);
        }

        public override void ToBytes(byte[] bytes, ref int i)
        {
            Array.Copy(Data, 0, bytes, i, 6);
            i += 6;
        }
    }

    public class HighHeader : Header
    {
        public override ushort ID
        {
            get { return (ushort)Data[4]; }
            set { Data[4] = (byte)value; }
        }
        public override PacketFrequency Frequency { get { return PacketFrequency.High; } }

        public HighHeader()
        {
            Data = new byte[5];
            AckList = new uint[0];
        }

        public HighHeader(byte[] bytes, ref int pos, ref int packetEnd)
        {
            if (bytes.Length < 5) { throw new MalformedDataException(); }
            Data = new byte[5];
            Array.Copy(bytes, Data, 5);
            pos = 5;
            CreateAckList(bytes, ref packetEnd);
        }

        public override void ToBytes(byte[] bytes, ref int i)
        {
            Array.Copy(Data, 0, bytes, i, 5);
            i += 5;
        }
    }

    public enum PacketType
    {
        Default,
        /// <summary>TestMessage</summary>
        TestMessage,
        /// <summary>AddCircuitCode</summary>
        AddCircuitCode,
        /// <summary>UseCircuitCode</summary>
        UseCircuitCode,
        /// <summary>LogControl</summary>
        LogControl,
        /// <summary>RelayLogControl</summary>
        RelayLogControl,
        /// <summary>LogMessages</summary>
        LogMessages,
        /// <summary>SimulatorAssign</summary>
        SimulatorAssign,
        /// <summary>SpaceServerSimulatorTimeMessage</summary>
        SpaceServerSimulatorTimeMessage,
        /// <summary>AvatarTextureUpdate</summary>
        AvatarTextureUpdate,
        /// <summary>SimulatorMapUpdate</summary>
        SimulatorMapUpdate,
        /// <summary>SimulatorSetMap</summary>
        SimulatorSetMap,
        /// <summary>SubscribeLoad</summary>
        SubscribeLoad,
        /// <summary>UnsubscribeLoad</summary>
        UnsubscribeLoad,
        /// <summary>SimulatorStart</summary>
        SimulatorStart,
        /// <summary>SimulatorReady</summary>
        SimulatorReady,
        /// <summary>TelehubInfo</summary>
        TelehubInfo,
        /// <summary>SimulatorPresentAtLocation</summary>
        SimulatorPresentAtLocation,
        /// <summary>SimulatorLoad</summary>
        SimulatorLoad,
        /// <summary>SimulatorShutdownRequest</summary>
        SimulatorShutdownRequest,
        /// <summary>RegionPresenceRequestByRegionID</summary>
        RegionPresenceRequestByRegionID,
        /// <summary>RegionPresenceRequestByHandle</summary>
        RegionPresenceRequestByHandle,
        /// <summary>RegionPresenceResponse</summary>
        RegionPresenceResponse,
        /// <summary>RecordAgentPresence</summary>
        RecordAgentPresence,
        /// <summary>EraseAgentPresence</summary>
        EraseAgentPresence,
        /// <summary>AgentPresenceRequest</summary>
        AgentPresenceRequest,
        /// <summary>AgentPresenceResponse</summary>
        AgentPresenceResponse,
        /// <summary>UpdateSimulator</summary>
        UpdateSimulator,
        /// <summary>TrackAgentSession</summary>
        TrackAgentSession,
        /// <summary>ClearAgentSessions</summary>
        ClearAgentSessions,
        /// <summary>LogDwellTime</summary>
        LogDwellTime,
        /// <summary>LogFailedMoneyTransaction</summary>
        LogFailedMoneyTransaction,
        /// <summary>UserReportInternal</summary>
        UserReportInternal,
        /// <summary>SetSimStatusInDatabase</summary>
        SetSimStatusInDatabase,
        /// <summary>SetSimPresenceInDatabase</summary>
        SetSimPresenceInDatabase,
        /// <summary>EconomyDataRequest</summary>
        EconomyDataRequest,
        /// <summary>EconomyData</summary>
        EconomyData,
        /// <summary>AvatarPickerRequest</summary>
        AvatarPickerRequest,
        /// <summary>AvatarPickerRequestBackend</summary>
        AvatarPickerRequestBackend,
        /// <summary>AvatarPickerReply</summary>
        AvatarPickerReply,
        /// <summary>PlacesQuery</summary>
        PlacesQuery,
        /// <summary>PlacesReply</summary>
        PlacesReply,
        /// <summary>DirFindQuery</summary>
        DirFindQuery,
        /// <summary>DirFindQueryBackend</summary>
        DirFindQueryBackend,
        /// <summary>DirPlacesQuery</summary>
        DirPlacesQuery,
        /// <summary>DirPlacesQueryBackend</summary>
        DirPlacesQueryBackend,
        /// <summary>DirPlacesReply</summary>
        DirPlacesReply,
        /// <summary>DirPeopleQuery</summary>
        DirPeopleQuery,
        /// <summary>DirPeopleQueryBackend</summary>
        DirPeopleQueryBackend,
        /// <summary>DirPeopleReply</summary>
        DirPeopleReply,
        /// <summary>DirEventsReply</summary>
        DirEventsReply,
        /// <summary>DirGroupsQuery</summary>
        DirGroupsQuery,
        /// <summary>DirGroupsQueryBackend</summary>
        DirGroupsQueryBackend,
        /// <summary>DirGroupsReply</summary>
        DirGroupsReply,
        /// <summary>DirClassifiedQuery</summary>
        DirClassifiedQuery,
        /// <summary>DirClassifiedQueryBackend</summary>
        DirClassifiedQueryBackend,
        /// <summary>DirClassifiedReply</summary>
        DirClassifiedReply,
        /// <summary>AvatarClassifiedReply</summary>
        AvatarClassifiedReply,
        /// <summary>ClassifiedInfoRequest</summary>
        ClassifiedInfoRequest,
        /// <summary>ClassifiedInfoReply</summary>
        ClassifiedInfoReply,
        /// <summary>ClassifiedInfoUpdate</summary>
        ClassifiedInfoUpdate,
        /// <summary>ClassifiedDelete</summary>
        ClassifiedDelete,
        /// <summary>ClassifiedGodDelete</summary>
        ClassifiedGodDelete,
        /// <summary>DirPicksQuery</summary>
        DirPicksQuery,
        /// <summary>DirPicksQueryBackend</summary>
        DirPicksQueryBackend,
        /// <summary>DirPicksReply</summary>
        DirPicksReply,
        /// <summary>DirLandQuery</summary>
        DirLandQuery,
        /// <summary>DirLandQueryBackend</summary>
        DirLandQueryBackend,
        /// <summary>DirLandReply</summary>
        DirLandReply,
        /// <summary>DirPopularQuery</summary>
        DirPopularQuery,
        /// <summary>DirPopularQueryBackend</summary>
        DirPopularQueryBackend,
        /// <summary>DirPopularReply</summary>
        DirPopularReply,
        /// <summary>ParcelInfoRequest</summary>
        ParcelInfoRequest,
        /// <summary>ParcelInfoReply</summary>
        ParcelInfoReply,
        /// <summary>ParcelObjectOwnersRequest</summary>
        ParcelObjectOwnersRequest,
        /// <summary>OnlineStatusRequest</summary>
        OnlineStatusRequest,
        /// <summary>OnlineStatusReply</summary>
        OnlineStatusReply,
        /// <summary>ParcelObjectOwnersReply</summary>
        ParcelObjectOwnersReply,
        /// <summary>GroupNoticesListRequest</summary>
        GroupNoticesListRequest,
        /// <summary>GroupNoticesListReply</summary>
        GroupNoticesListReply,
        /// <summary>GroupNoticeRequest</summary>
        GroupNoticeRequest,
        /// <summary>GroupNoticeAdd</summary>
        GroupNoticeAdd,
        /// <summary>GroupNoticeDelete</summary>
        GroupNoticeDelete,
        /// <summary>TeleportRequest</summary>
        TeleportRequest,
        /// <summary>TeleportLocationRequest</summary>
        TeleportLocationRequest,
        /// <summary>TeleportLocal</summary>
        TeleportLocal,
        /// <summary>TeleportLandmarkRequest</summary>
        TeleportLandmarkRequest,
        /// <summary>TeleportProgress</summary>
        TeleportProgress,
        /// <summary>DataAgentAccessRequest</summary>
        DataAgentAccessRequest,
        /// <summary>DataAgentAccessReply</summary>
        DataAgentAccessReply,
        /// <summary>DataHomeLocationRequest</summary>
        DataHomeLocationRequest,
        /// <summary>DataHomeLocationReply</summary>
        DataHomeLocationReply,
        /// <summary>SpaceLocationTeleportRequest</summary>
        SpaceLocationTeleportRequest,
        /// <summary>SpaceLocationTeleportReply</summary>
        SpaceLocationTeleportReply,
        /// <summary>TeleportFinish</summary>
        TeleportFinish,
        /// <summary>StartLure</summary>
        StartLure,
        /// <summary>TeleportLureRequest</summary>
        TeleportLureRequest,
        /// <summary>TeleportCancel</summary>
        TeleportCancel,
        /// <summary>CompleteLure</summary>
        CompleteLure,
        /// <summary>TeleportStart</summary>
        TeleportStart,
        /// <summary>TeleportFailed</summary>
        TeleportFailed,
        /// <summary>LeaderBoardRequest</summary>
        LeaderBoardRequest,
        /// <summary>LeaderBoardData</summary>
        LeaderBoardData,
        /// <summary>RegisterNewAgent</summary>
        RegisterNewAgent,
        /// <summary>Undo</summary>
        Undo,
        /// <summary>Redo</summary>
        Redo,
        /// <summary>UndoLand</summary>
        UndoLand,
        /// <summary>RedoLand</summary>
        RedoLand,
        /// <summary>AgentPause</summary>
        AgentPause,
        /// <summary>AgentResume</summary>
        AgentResume,
        /// <summary>ChatFromViewer</summary>
        ChatFromViewer,
        /// <summary>AgentThrottle</summary>
        AgentThrottle,
        /// <summary>AgentFOV</summary>
        AgentFOV,
        /// <summary>AgentHeightWidth</summary>
        AgentHeightWidth,
        /// <summary>AgentSetAppearance</summary>
        AgentSetAppearance,
        /// <summary>RefreshViewer</summary>
        RefreshViewer,
        /// <summary>AgentQuit</summary>
        AgentQuit,
        /// <summary>AgentQuitCopy</summary>
        AgentQuitCopy,
        /// <summary>ImageNotInDatabase</summary>
        ImageNotInDatabase,
        /// <summary>RebakeAvatarTextures</summary>
        RebakeAvatarTextures,
        /// <summary>SetAlwaysRun</summary>
        SetAlwaysRun,
        /// <summary>ObjectDelete</summary>
        ObjectDelete,
        /// <summary>ObjectDuplicate</summary>
        ObjectDuplicate,
        /// <summary>ObjectDuplicateOnRay</summary>
        ObjectDuplicateOnRay,
        /// <summary>ObjectScale</summary>
        ObjectScale,
        /// <summary>ObjectRotation</summary>
        ObjectRotation,
        /// <summary>ObjectFlagUpdate</summary>
        ObjectFlagUpdate,
        /// <summary>ObjectClickAction</summary>
        ObjectClickAction,
        /// <summary>ObjectImage</summary>
        ObjectImage,
        /// <summary>ObjectMaterial</summary>
        ObjectMaterial,
        /// <summary>ObjectShape</summary>
        ObjectShape,
        /// <summary>ObjectExtraParams</summary>
        ObjectExtraParams,
        /// <summary>ObjectOwner</summary>
        ObjectOwner,
        /// <summary>ObjectGroup</summary>
        ObjectGroup,
        /// <summary>ObjectBuy</summary>
        ObjectBuy,
        /// <summary>BuyObjectInventory</summary>
        BuyObjectInventory,
        /// <summary>DerezContainer</summary>
        DerezContainer,
        /// <summary>ObjectPermissions</summary>
        ObjectPermissions,
        /// <summary>ObjectSaleInfo</summary>
        ObjectSaleInfo,
        /// <summary>ObjectName</summary>
        ObjectName,
        /// <summary>ObjectDescription</summary>
        ObjectDescription,
        /// <summary>ObjectCategory</summary>
        ObjectCategory,
        /// <summary>ObjectSelect</summary>
        ObjectSelect,
        /// <summary>ObjectDeselect</summary>
        ObjectDeselect,
        /// <summary>ObjectAttach</summary>
        ObjectAttach,
        /// <summary>ObjectDetach</summary>
        ObjectDetach,
        /// <summary>ObjectDrop</summary>
        ObjectDrop,
        /// <summary>ObjectLink</summary>
        ObjectLink,
        /// <summary>ObjectDelink</summary>
        ObjectDelink,
        /// <summary>ObjectHinge</summary>
        ObjectHinge,
        /// <summary>ObjectDehinge</summary>
        ObjectDehinge,
        /// <summary>ObjectGrab</summary>
        ObjectGrab,
        /// <summary>ObjectGrabUpdate</summary>
        ObjectGrabUpdate,
        /// <summary>ObjectDeGrab</summary>
        ObjectDeGrab,
        /// <summary>ObjectSpinStart</summary>
        ObjectSpinStart,
        /// <summary>ObjectSpinUpdate</summary>
        ObjectSpinUpdate,
        /// <summary>ObjectSpinStop</summary>
        ObjectSpinStop,
        /// <summary>ObjectExportSelected</summary>
        ObjectExportSelected,
        /// <summary>ObjectImport</summary>
        ObjectImport,
        /// <summary>ModifyLand</summary>
        ModifyLand,
        /// <summary>VelocityInterpolateOn</summary>
        VelocityInterpolateOn,
        /// <summary>VelocityInterpolateOff</summary>
        VelocityInterpolateOff,
        /// <summary>StateSave</summary>
        StateSave,
        /// <summary>ReportAutosaveCrash</summary>
        ReportAutosaveCrash,
        /// <summary>SimWideDeletes</summary>
        SimWideDeletes,
        /// <summary>StateLoad</summary>
        StateLoad,
        /// <summary>TrackAgent</summary>
        TrackAgent,
        /// <summary>GrantModification</summary>
        GrantModification,
        /// <summary>RevokeModification</summary>
        RevokeModification,
        /// <summary>RequestGrantedProxies</summary>
        RequestGrantedProxies,
        /// <summary>GrantedProxies</summary>
        GrantedProxies,
        /// <summary>AddModifyAbility</summary>
        AddModifyAbility,
        /// <summary>RemoveModifyAbility</summary>
        RemoveModifyAbility,
        /// <summary>ViewerStats</summary>
        ViewerStats,
        /// <summary>ScriptAnswerYes</summary>
        ScriptAnswerYes,
        /// <summary>UserReport</summary>
        UserReport,
        /// <summary>AlertMessage</summary>
        AlertMessage,
        /// <summary>AgentAlertMessage</summary>
        AgentAlertMessage,
        /// <summary>MeanCollisionAlert</summary>
        MeanCollisionAlert,
        /// <summary>ViewerFrozenMessage</summary>
        ViewerFrozenMessage,
        /// <summary>HealthMessage</summary>
        HealthMessage,
        /// <summary>ChatFromSimulator</summary>
        ChatFromSimulator,
        /// <summary>SimStats</summary>
        SimStats,
        /// <summary>RequestRegionInfo</summary>
        RequestRegionInfo,
        /// <summary>RegionInfo</summary>
        RegionInfo,
        /// <summary>GodUpdateRegionInfo</summary>
        GodUpdateRegionInfo,
        /// <summary>NearestLandingRegionRequest</summary>
        NearestLandingRegionRequest,
        /// <summary>NearestLandingRegionReply</summary>
        NearestLandingRegionReply,
        /// <summary>NearestLandingRegionUpdated</summary>
        NearestLandingRegionUpdated,
        /// <summary>TeleportLandingStatusChanged</summary>
        TeleportLandingStatusChanged,
        /// <summary>RegionHandshake</summary>
        RegionHandshake,
        /// <summary>RegionHandshakeReply</summary>
        RegionHandshakeReply,
        /// <summary>SimulatorViewerTimeMessage</summary>
        SimulatorViewerTimeMessage,
        /// <summary>EnableSimulator</summary>
        EnableSimulator,
        /// <summary>DisableSimulator</summary>
        DisableSimulator,
        /// <summary>TransferRequest</summary>
        TransferRequest,
        /// <summary>TransferInfo</summary>
        TransferInfo,
        /// <summary>TransferAbort</summary>
        TransferAbort,
        /// <summary>TransferPriority</summary>
        TransferPriority,
        /// <summary>RequestXfer</summary>
        RequestXfer,
        /// <summary>AbortXfer</summary>
        AbortXfer,
        /// <summary>RequestAvatarInfo</summary>
        RequestAvatarInfo,
        /// <summary>AvatarAppearance</summary>
        AvatarAppearance,
        /// <summary>SetFollowCamProperties</summary>
        SetFollowCamProperties,
        /// <summary>ClearFollowCamProperties</summary>
        ClearFollowCamProperties,
        /// <summary>RequestPayPrice</summary>
        RequestPayPrice,
        /// <summary>PayPriceReply</summary>
        PayPriceReply,
        /// <summary>KickUser</summary>
        KickUser,
        /// <summary>KickUserAck</summary>
        KickUserAck,
        /// <summary>GodKickUser</summary>
        GodKickUser,
        /// <summary>SystemKickUser</summary>
        SystemKickUser,
        /// <summary>EjectUser</summary>
        EjectUser,
        /// <summary>FreezeUser</summary>
        FreezeUser,
        /// <summary>AvatarPropertiesRequest</summary>
        AvatarPropertiesRequest,
        /// <summary>AvatarPropertiesRequestBackend</summary>
        AvatarPropertiesRequestBackend,
        /// <summary>AvatarPropertiesReply</summary>
        AvatarPropertiesReply,
        /// <summary>AvatarGroupsReply</summary>
        AvatarGroupsReply,
        /// <summary>AvatarPropertiesUpdate</summary>
        AvatarPropertiesUpdate,
        /// <summary>AvatarStatisticsReply</summary>
        AvatarStatisticsReply,
        /// <summary>AvatarNotesReply</summary>
        AvatarNotesReply,
        /// <summary>AvatarNotesUpdate</summary>
        AvatarNotesUpdate,
        /// <summary>AvatarPicksReply</summary>
        AvatarPicksReply,
        /// <summary>EventInfoRequest</summary>
        EventInfoRequest,
        /// <summary>EventInfoReply</summary>
        EventInfoReply,
        /// <summary>EventNotificationAddRequest</summary>
        EventNotificationAddRequest,
        /// <summary>EventNotificationRemoveRequest</summary>
        EventNotificationRemoveRequest,
        /// <summary>EventGodDelete</summary>
        EventGodDelete,
        /// <summary>PickInfoRequest</summary>
        PickInfoRequest,
        /// <summary>PickInfoReply</summary>
        PickInfoReply,
        /// <summary>PickInfoUpdate</summary>
        PickInfoUpdate,
        /// <summary>PickDelete</summary>
        PickDelete,
        /// <summary>PickGodDelete</summary>
        PickGodDelete,
        /// <summary>ScriptQuestion</summary>
        ScriptQuestion,
        /// <summary>ScriptControlChange</summary>
        ScriptControlChange,
        /// <summary>ScriptDialog</summary>
        ScriptDialog,
        /// <summary>ScriptDialogReply</summary>
        ScriptDialogReply,
        /// <summary>ForceScriptControlRelease</summary>
        ForceScriptControlRelease,
        /// <summary>RevokePermissions</summary>
        RevokePermissions,
        /// <summary>LoadURL</summary>
        LoadURL,
        /// <summary>ScriptTeleportRequest</summary>
        ScriptTeleportRequest,
        /// <summary>ParcelOverlay</summary>
        ParcelOverlay,
        /// <summary>ParcelPropertiesRequestByID</summary>
        ParcelPropertiesRequestByID,
        /// <summary>ParcelPropertiesUpdate</summary>
        ParcelPropertiesUpdate,
        /// <summary>ParcelReturnObjects</summary>
        ParcelReturnObjects,
        /// <summary>ParcelSetOtherCleanTime</summary>
        ParcelSetOtherCleanTime,
        /// <summary>ParcelDisableObjects</summary>
        ParcelDisableObjects,
        /// <summary>ParcelSelectObjects</summary>
        ParcelSelectObjects,
        /// <summary>EstateCovenantRequest</summary>
        EstateCovenantRequest,
        /// <summary>EstateCovenantReply</summary>
        EstateCovenantReply,
        /// <summary>ForceObjectSelect</summary>
        ForceObjectSelect,
        /// <summary>ParcelBuyPass</summary>
        ParcelBuyPass,
        /// <summary>ParcelDeedToGroup</summary>
        ParcelDeedToGroup,
        /// <summary>ParcelReclaim</summary>
        ParcelReclaim,
        /// <summary>ParcelClaim</summary>
        ParcelClaim,
        /// <summary>ParcelJoin</summary>
        ParcelJoin,
        /// <summary>ParcelDivide</summary>
        ParcelDivide,
        /// <summary>ParcelRelease</summary>
        ParcelRelease,
        /// <summary>ParcelBuy</summary>
        ParcelBuy,
        /// <summary>ParcelGodForceOwner</summary>
        ParcelGodForceOwner,
        /// <summary>ParcelAccessListRequest</summary>
        ParcelAccessListRequest,
        /// <summary>ParcelAccessListReply</summary>
        ParcelAccessListReply,
        /// <summary>ParcelAccessListUpdate</summary>
        ParcelAccessListUpdate,
        /// <summary>ParcelDwellRequest</summary>
        ParcelDwellRequest,
        /// <summary>ParcelDwellReply</summary>
        ParcelDwellReply,
        /// <summary>RequestParcelTransfer</summary>
        RequestParcelTransfer,
        /// <summary>UpdateParcel</summary>
        UpdateParcel,
        /// <summary>RemoveParcel</summary>
        RemoveParcel,
        /// <summary>MergeParcel</summary>
        MergeParcel,
        /// <summary>LogParcelChanges</summary>
        LogParcelChanges,
        /// <summary>CheckParcelSales</summary>
        CheckParcelSales,
        /// <summary>ParcelSales</summary>
        ParcelSales,
        /// <summary>ParcelGodMarkAsContent</summary>
        ParcelGodMarkAsContent,
        /// <summary>ParcelGodReserveForNewbie</summary>
        ParcelGodReserveForNewbie,
        /// <summary>ViewerStartAuction</summary>
        ViewerStartAuction,
        /// <summary>StartAuction</summary>
        StartAuction,
        /// <summary>ConfirmAuctionStart</summary>
        ConfirmAuctionStart,
        /// <summary>CompleteAuction</summary>
        CompleteAuction,
        /// <summary>CancelAuction</summary>
        CancelAuction,
        /// <summary>CheckParcelAuctions</summary>
        CheckParcelAuctions,
        /// <summary>ParcelAuctions</summary>
        ParcelAuctions,
        /// <summary>UUIDNameRequest</summary>
        UUIDNameRequest,
        /// <summary>UUIDNameReply</summary>
        UUIDNameReply,
        /// <summary>UUIDGroupNameRequest</summary>
        UUIDGroupNameRequest,
        /// <summary>UUIDGroupNameReply</summary>
        UUIDGroupNameReply,
        /// <summary>ChatPass</summary>
        ChatPass,
        /// <summary>ChildAgentDying</summary>
        ChildAgentDying,
        /// <summary>ChildAgentUnknown</summary>
        ChildAgentUnknown,
        /// <summary>KillChildAgents</summary>
        KillChildAgents,
        /// <summary>GetScriptRunning</summary>
        GetScriptRunning,
        /// <summary>ScriptRunningReply</summary>
        ScriptRunningReply,
        /// <summary>SetScriptRunning</summary>
        SetScriptRunning,
        /// <summary>ScriptReset</summary>
        ScriptReset,
        /// <summary>ScriptSensorRequest</summary>
        ScriptSensorRequest,
        /// <summary>ScriptSensorReply</summary>
        ScriptSensorReply,
        /// <summary>CompleteAgentMovement</summary>
        CompleteAgentMovement,
        /// <summary>AgentMovementComplete</summary>
        AgentMovementComplete,
        /// <summary>LogLogin</summary>
        LogLogin,
        /// <summary>ConnectAgentToUserserver</summary>
        ConnectAgentToUserserver,
        /// <summary>ConnectToUserserver</summary>
        ConnectToUserserver,
        /// <summary>DataServerLogout</summary>
        DataServerLogout,
        /// <summary>LogoutRequest</summary>
        LogoutRequest,
        /// <summary>FinalizeLogout</summary>
        FinalizeLogout,
        /// <summary>LogoutReply</summary>
        LogoutReply,
        /// <summary>LogoutDemand</summary>
        LogoutDemand,
        /// <summary>ViewerLoginLocationRequest</summary>
        ViewerLoginLocationRequest,
        /// <summary>ViewerSimLocationRequest</summary>
        ViewerSimLocationRequest,
        /// <summary>RequestLocationGetAccess</summary>
        RequestLocationGetAccess,
        /// <summary>RequestLocationGetAccessReply</summary>
        RequestLocationGetAccessReply,
        /// <summary>UserListRequest</summary>
        UserListRequest,
        /// <summary>ImprovedInstantMessage</summary>
        ImprovedInstantMessage,
        /// <summary>StartGroupIM</summary>
        StartGroupIM,
        /// <summary>DropGroupIM</summary>
        DropGroupIM,
        /// <summary>GroupIM</summary>
        GroupIM,
        /// <summary>RetrieveInstantMessages</summary>
        RetrieveInstantMessages,
        /// <summary>DequeueInstantMessages</summary>
        DequeueInstantMessages,
        /// <summary>FindAgent</summary>
        FindAgent,
        /// <summary>TrackOnlineStatus</summary>
        TrackOnlineStatus,
        /// <summary>IgnoreOnlineStatus</summary>
        IgnoreOnlineStatus,
        /// <summary>RequestGodlikePowers</summary>
        RequestGodlikePowers,
        /// <summary>GrantGodlikePowers</summary>
        GrantGodlikePowers,
        /// <summary>GodlikeMessage</summary>
        GodlikeMessage,
        /// <summary>EstateOwnerMessage</summary>
        EstateOwnerMessage,
        /// <summary>GenericMessage</summary>
        GenericMessage,
        /// <summary>MuteListRequest</summary>
        MuteListRequest,
        /// <summary>UpdateMuteListEntry</summary>
        UpdateMuteListEntry,
        /// <summary>RemoveMuteListEntry</summary>
        RemoveMuteListEntry,
        /// <summary>UpdateInventoryItem</summary>
        UpdateInventoryItem,
        /// <summary>UpdateInventoryItemAsset</summary>
        UpdateInventoryItemAsset,
        /// <summary>MoveInventoryItem</summary>
        MoveInventoryItem,
        /// <summary>CopyInventoryItem</summary>
        CopyInventoryItem,
        /// <summary>RemoveInventoryItem</summary>
        RemoveInventoryItem,
        /// <summary>ChangeInventoryItemFlags</summary>
        ChangeInventoryItemFlags,
        /// <summary>SaveAssetIntoInventory</summary>
        SaveAssetIntoInventory,
        /// <summary>CreateInventoryFolder</summary>
        CreateInventoryFolder,
        /// <summary>UpdateInventoryFolder</summary>
        UpdateInventoryFolder,
        /// <summary>MoveInventoryFolder</summary>
        MoveInventoryFolder,
        /// <summary>RemoveInventoryFolder</summary>
        RemoveInventoryFolder,
        /// <summary>FetchInventoryDescendents</summary>
        FetchInventoryDescendents,
        /// <summary>InventoryDescendents</summary>
        InventoryDescendents,
        /// <summary>FetchInventory</summary>
        FetchInventory,
        /// <summary>FetchInventoryReply</summary>
        FetchInventoryReply,
        /// <summary>BulkUpdateInventory</summary>
        BulkUpdateInventory,
        /// <summary>RequestInventoryAsset</summary>
        RequestInventoryAsset,
        /// <summary>InventoryAssetResponse</summary>
        InventoryAssetResponse,
        /// <summary>RemoveInventoryObjects</summary>
        RemoveInventoryObjects,
        /// <summary>PurgeInventoryDescendents</summary>
        PurgeInventoryDescendents,
        /// <summary>UpdateTaskInventory</summary>
        UpdateTaskInventory,
        /// <summary>RemoveTaskInventory</summary>
        RemoveTaskInventory,
        /// <summary>MoveTaskInventory</summary>
        MoveTaskInventory,
        /// <summary>RequestTaskInventory</summary>
        RequestTaskInventory,
        /// <summary>ReplyTaskInventory</summary>
        ReplyTaskInventory,
        /// <summary>DeRezObject</summary>
        DeRezObject,
        /// <summary>DeRezAck</summary>
        DeRezAck,
        /// <summary>RezObject</summary>
        RezObject,
        /// <summary>DeclineInventory</summary>
        DeclineInventory,
        /// <summary>TransferInventory</summary>
        TransferInventory,
        /// <summary>TransferInventoryAck</summary>
        TransferInventoryAck,
        /// <summary>RequestFriendship</summary>
        RequestFriendship,
        /// <summary>AcceptFriendship</summary>
        AcceptFriendship,
        /// <summary>DeclineFriendship</summary>
        DeclineFriendship,
        /// <summary>FormFriendship</summary>
        FormFriendship,
        /// <summary>TerminateFriendship</summary>
        TerminateFriendship,
        /// <summary>OfferCallingCard</summary>
        OfferCallingCard,
        /// <summary>AcceptCallingCard</summary>
        AcceptCallingCard,
        /// <summary>DeclineCallingCard</summary>
        DeclineCallingCard,
        /// <summary>RezScript</summary>
        RezScript,
        /// <summary>CreateInventoryItem</summary>
        CreateInventoryItem,
        /// <summary>CreateLandmarkForEvent</summary>
        CreateLandmarkForEvent,
        /// <summary>EventLocationRequest</summary>
        EventLocationRequest,
        /// <summary>EventLocationReply</summary>
        EventLocationReply,
        /// <summary>RegionHandleRequest</summary>
        RegionHandleRequest,
        /// <summary>RegionIDAndHandleReply</summary>
        RegionIDAndHandleReply,
        /// <summary>MoneyTransferRequest</summary>
        MoneyTransferRequest,
        /// <summary>MoneyTransferBackend</summary>
        MoneyTransferBackend,
        /// <summary>BulkMoneyTransfer</summary>
        BulkMoneyTransfer,
        /// <summary>AdjustBalance</summary>
        AdjustBalance,
        /// <summary>MoneyBalanceRequest</summary>
        MoneyBalanceRequest,
        /// <summary>MoneyBalanceReply</summary>
        MoneyBalanceReply,
        /// <summary>RoutedMoneyBalanceReply</summary>
        RoutedMoneyBalanceReply,
        /// <summary>MoneyHistoryRequest</summary>
        MoneyHistoryRequest,
        /// <summary>MoneyHistoryReply</summary>
        MoneyHistoryReply,
        /// <summary>MoneySummaryRequest</summary>
        MoneySummaryRequest,
        /// <summary>MoneySummaryReply</summary>
        MoneySummaryReply,
        /// <summary>MoneyDetailsRequest</summary>
        MoneyDetailsRequest,
        /// <summary>MoneyDetailsReply</summary>
        MoneyDetailsReply,
        /// <summary>MoneyTransactionsRequest</summary>
        MoneyTransactionsRequest,
        /// <summary>MoneyTransactionsReply</summary>
        MoneyTransactionsReply,
        /// <summary>GestureRequest</summary>
        GestureRequest,
        /// <summary>ActivateGestures</summary>
        ActivateGestures,
        /// <summary>DeactivateGestures</summary>
        DeactivateGestures,
        /// <summary>InventoryUpdate</summary>
        InventoryUpdate,
        /// <summary>MuteListUpdate</summary>
        MuteListUpdate,
        /// <summary>UseCachedMuteList</summary>
        UseCachedMuteList,
        /// <summary>UserLoginLocationReply</summary>
        UserLoginLocationReply,
        /// <summary>UserSimLocationReply</summary>
        UserSimLocationReply,
        /// <summary>UserListReply</summary>
        UserListReply,
        /// <summary>OnlineNotification</summary>
        OnlineNotification,
        /// <summary>OfflineNotification</summary>
        OfflineNotification,
        /// <summary>SetStartLocationRequest</summary>
        SetStartLocationRequest,
        /// <summary>SetStartLocation</summary>
        SetStartLocation,
        /// <summary>UserLoginLocationRequest</summary>
        UserLoginLocationRequest,
        /// <summary>SpaceLoginLocationReply</summary>
        SpaceLoginLocationReply,
        /// <summary>NetTest</summary>
        NetTest,
        /// <summary>SetCPURatio</summary>
        SetCPURatio,
        /// <summary>SimCrashed</summary>
        SimCrashed,
        /// <summary>SimulatorPauseState</summary>
        SimulatorPauseState,
        /// <summary>SimulatorThrottleSettings</summary>
        SimulatorThrottleSettings,
        /// <summary>NameValuePair</summary>
        NameValuePair,
        /// <summary>RemoveNameValuePair</summary>
        RemoveNameValuePair,
        /// <summary>GetNameValuePair</summary>
        GetNameValuePair,
        /// <summary>UpdateAttachment</summary>
        UpdateAttachment,
        /// <summary>RemoveAttachment</summary>
        RemoveAttachment,
        /// <summary>AssetUploadRequest</summary>
        AssetUploadRequest,
        /// <summary>AssetUploadComplete</summary>
        AssetUploadComplete,
        /// <summary>ReputationAgentAssign</summary>
        ReputationAgentAssign,
        /// <summary>ReputationIndividualRequest</summary>
        ReputationIndividualRequest,
        /// <summary>ReputationIndividualReply</summary>
        ReputationIndividualReply,
        /// <summary>EmailMessageRequest</summary>
        EmailMessageRequest,
        /// <summary>EmailMessageReply</summary>
        EmailMessageReply,
        /// <summary>ScriptDataRequest</summary>
        ScriptDataRequest,
        /// <summary>ScriptDataReply</summary>
        ScriptDataReply,
        /// <summary>CreateGroupRequest</summary>
        CreateGroupRequest,
        /// <summary>CreateGroupReply</summary>
        CreateGroupReply,
        /// <summary>UpdateGroupInfo</summary>
        UpdateGroupInfo,
        /// <summary>GroupRoleChanges</summary>
        GroupRoleChanges,
        /// <summary>JoinGroupRequest</summary>
        JoinGroupRequest,
        /// <summary>JoinGroupReply</summary>
        JoinGroupReply,
        /// <summary>EjectGroupMemberRequest</summary>
        EjectGroupMemberRequest,
        /// <summary>EjectGroupMemberReply</summary>
        EjectGroupMemberReply,
        /// <summary>LeaveGroupRequest</summary>
        LeaveGroupRequest,
        /// <summary>LeaveGroupReply</summary>
        LeaveGroupReply,
        /// <summary>InviteGroupRequest</summary>
        InviteGroupRequest,
        /// <summary>InviteGroupResponse</summary>
        InviteGroupResponse,
        /// <summary>GroupProfileRequest</summary>
        GroupProfileRequest,
        /// <summary>GroupProfileReply</summary>
        GroupProfileReply,
        /// <summary>GroupAccountSummaryRequest</summary>
        GroupAccountSummaryRequest,
        /// <summary>GroupAccountSummaryReply</summary>
        GroupAccountSummaryReply,
        /// <summary>GroupAccountDetailsRequest</summary>
        GroupAccountDetailsRequest,
        /// <summary>GroupAccountDetailsReply</summary>
        GroupAccountDetailsReply,
        /// <summary>GroupAccountTransactionsRequest</summary>
        GroupAccountTransactionsRequest,
        /// <summary>GroupAccountTransactionsReply</summary>
        GroupAccountTransactionsReply,
        /// <summary>GroupActiveProposalsRequest</summary>
        GroupActiveProposalsRequest,
        /// <summary>GroupActiveProposalItemReply</summary>
        GroupActiveProposalItemReply,
        /// <summary>GroupVoteHistoryRequest</summary>
        GroupVoteHistoryRequest,
        /// <summary>GroupVoteHistoryItemReply</summary>
        GroupVoteHistoryItemReply,
        /// <summary>StartGroupProposal</summary>
        StartGroupProposal,
        /// <summary>GroupProposalBallot</summary>
        GroupProposalBallot,
        /// <summary>TallyVotes</summary>
        TallyVotes,
        /// <summary>GroupMembersRequest</summary>
        GroupMembersRequest,
        /// <summary>GroupMembersReply</summary>
        GroupMembersReply,
        /// <summary>ActivateGroup</summary>
        ActivateGroup,
        /// <summary>SetGroupContribution</summary>
        SetGroupContribution,
        /// <summary>SetGroupAcceptNotices</summary>
        SetGroupAcceptNotices,
        /// <summary>GroupRoleDataRequest</summary>
        GroupRoleDataRequest,
        /// <summary>GroupRoleDataReply</summary>
        GroupRoleDataReply,
        /// <summary>GroupRoleMembersRequest</summary>
        GroupRoleMembersRequest,
        /// <summary>GroupRoleMembersReply</summary>
        GroupRoleMembersReply,
        /// <summary>GroupTitlesRequest</summary>
        GroupTitlesRequest,
        /// <summary>GroupTitlesReply</summary>
        GroupTitlesReply,
        /// <summary>GroupTitleUpdate</summary>
        GroupTitleUpdate,
        /// <summary>GroupRoleUpdate</summary>
        GroupRoleUpdate,
        /// <summary>LiveHelpGroupRequest</summary>
        LiveHelpGroupRequest,
        /// <summary>LiveHelpGroupReply</summary>
        LiveHelpGroupReply,
        /// <summary>AgentWearablesRequest</summary>
        AgentWearablesRequest,
        /// <summary>AgentWearablesUpdate</summary>
        AgentWearablesUpdate,
        /// <summary>AgentCachedTexture</summary>
        AgentCachedTexture,
        /// <summary>AgentCachedTextureResponse</summary>
        AgentCachedTextureResponse,
        /// <summary>AgentDataUpdateRequest</summary>
        AgentDataUpdateRequest,
        /// <summary>AgentDataUpdate</summary>
        AgentDataUpdate,
        /// <summary>GroupDataUpdate</summary>
        GroupDataUpdate,
        /// <summary>AgentGroupDataUpdate</summary>
        AgentGroupDataUpdate,
        /// <summary>AgentDropGroup</summary>
        AgentDropGroup,
        /// <summary>LogTextMessage</summary>
        LogTextMessage,
        /// <summary>CreateTrustedCircuit</summary>
        CreateTrustedCircuit,
        /// <summary>DenyTrustedCircuit</summary>
        DenyTrustedCircuit,
        /// <summary>RezSingleAttachmentFromInv</summary>
        RezSingleAttachmentFromInv,
        /// <summary>RezMultipleAttachmentsFromInv</summary>
        RezMultipleAttachmentsFromInv,
        /// <summary>DetachAttachmentIntoInv</summary>
        DetachAttachmentIntoInv,
        /// <summary>CreateNewOutfitAttachments</summary>
        CreateNewOutfitAttachments,
        /// <summary>UserInfoRequest</summary>
        UserInfoRequest,
        /// <summary>UserInfoReply</summary>
        UserInfoReply,
        /// <summary>UpdateUserInfo</summary>
        UpdateUserInfo,
        /// <summary>GodExpungeUser</summary>
        GodExpungeUser,
        /// <summary>StartExpungeProcess</summary>
        StartExpungeProcess,
        /// <summary>StartExpungeProcessAck</summary>
        StartExpungeProcessAck,
        /// <summary>StartParcelRename</summary>
        StartParcelRename,
        /// <summary>StartParcelRenameAck</summary>
        StartParcelRenameAck,
        /// <summary>BulkParcelRename</summary>
        BulkParcelRename,
        /// <summary>ParcelRename</summary>
        ParcelRename,
        /// <summary>StartParcelRemove</summary>
        StartParcelRemove,
        /// <summary>StartParcelRemoveAck</summary>
        StartParcelRemoveAck,
        /// <summary>BulkParcelRemove</summary>
        BulkParcelRemove,
        /// <summary>InitiateUpload</summary>
        InitiateUpload,
        /// <summary>InitiateDownload</summary>
        InitiateDownload,
        /// <summary>SystemMessage</summary>
        SystemMessage,
        /// <summary>MapLayerRequest</summary>
        MapLayerRequest,
        /// <summary>MapLayerReply</summary>
        MapLayerReply,
        /// <summary>MapBlockRequest</summary>
        MapBlockRequest,
        /// <summary>MapNameRequest</summary>
        MapNameRequest,
        /// <summary>MapBlockReply</summary>
        MapBlockReply,
        /// <summary>MapItemRequest</summary>
        MapItemRequest,
        /// <summary>MapItemReply</summary>
        MapItemReply,
        /// <summary>SendPostcard</summary>
        SendPostcard,
        /// <summary>RpcChannelRequest</summary>
        RpcChannelRequest,
        /// <summary>RpcChannelReply</summary>
        RpcChannelReply,
        /// <summary>RpcScriptRequestInbound</summary>
        RpcScriptRequestInbound,
        /// <summary>RpcScriptRequestInboundForward</summary>
        RpcScriptRequestInboundForward,
        /// <summary>RpcScriptReplyInbound</summary>
        RpcScriptReplyInbound,
        /// <summary>MailTaskSimRequest</summary>
        MailTaskSimRequest,
        /// <summary>MailTaskSimReply</summary>
        MailTaskSimReply,
        /// <summary>ScriptMailRegistration</summary>
        ScriptMailRegistration,
        /// <summary>MailPingBounce</summary>
        MailPingBounce,
        /// <summary>ParcelMediaCommandMessage</summary>
        ParcelMediaCommandMessage,
        /// <summary>ParcelMediaUpdate</summary>
        ParcelMediaUpdate,
        /// <summary>LandStatRequest</summary>
        LandStatRequest,
        /// <summary>LandStatReply</summary>
        LandStatReply,
        /// <summary>SecuredTemplateChecksumRequest</summary>
        SecuredTemplateChecksumRequest,
        /// <summary>PacketAck</summary>
        PacketAck,
        /// <summary>OpenCircuit</summary>
        OpenCircuit,
        /// <summary>CloseCircuit</summary>
        CloseCircuit,
        /// <summary>TemplateChecksumRequest</summary>
        TemplateChecksumRequest,
        /// <summary>TemplateChecksumReply</summary>
        TemplateChecksumReply,
        /// <summary>ClosestSimulator</summary>
        ClosestSimulator,
        /// <summary>ObjectAdd</summary>
        ObjectAdd,
        /// <summary>MultipleObjectUpdate</summary>
        MultipleObjectUpdate,
        /// <summary>RequestMultipleObjects</summary>
        RequestMultipleObjects,
        /// <summary>ObjectPosition</summary>
        ObjectPosition,
        /// <summary>RequestObjectPropertiesFamily</summary>
        RequestObjectPropertiesFamily,
        /// <summary>CoarseLocationUpdate</summary>
        CoarseLocationUpdate,
        /// <summary>CrossedRegion</summary>
        CrossedRegion,
        /// <summary>ConfirmEnableSimulator</summary>
        ConfirmEnableSimulator,
        /// <summary>ObjectProperties</summary>
        ObjectProperties,
        /// <summary>ObjectPropertiesFamily</summary>
        ObjectPropertiesFamily,
        /// <summary>ParcelPropertiesRequest</summary>
        ParcelPropertiesRequest,
        /// <summary>SimStatus</summary>
        SimStatus,
        /// <summary>GestureUpdate</summary>
        GestureUpdate,
        /// <summary>AttachedSound</summary>
        AttachedSound,
        /// <summary>AttachedSoundGainChange</summary>
        AttachedSoundGainChange,
        /// <summary>AttachedSoundCutoffRadius</summary>
        AttachedSoundCutoffRadius,
        /// <summary>PreloadSound</summary>
        PreloadSound,
        /// <summary>InternalScriptMail</summary>
        InternalScriptMail,
        /// <summary>ViewerEffect</summary>
        ViewerEffect,
        /// <summary>SetSunPhase</summary>
        SetSunPhase,
        /// <summary>StartPingCheck</summary>
        StartPingCheck,
        /// <summary>CompletePingCheck</summary>
        CompletePingCheck,
        /// <summary>NeighborList</summary>
        NeighborList,
        /// <summary>MovedIntoSimulator</summary>
        MovedIntoSimulator,
        /// <summary>AgentUpdate</summary>
        AgentUpdate,
        /// <summary>AgentAnimation</summary>
        AgentAnimation,
        /// <summary>AgentRequestSit</summary>
        AgentRequestSit,
        /// <summary>AgentSit</summary>
        AgentSit,
        /// <summary>RequestImage</summary>
        RequestImage,
        /// <summary>ImageData</summary>
        ImageData,
        /// <summary>ImagePacket</summary>
        ImagePacket,
        /// <summary>LayerData</summary>
        LayerData,
        /// <summary>ObjectUpdate</summary>
        ObjectUpdate,
        /// <summary>ObjectUpdateCompressed</summary>
        ObjectUpdateCompressed,
        /// <summary>ObjectUpdateCached</summary>
        ObjectUpdateCached,
        /// <summary>ImprovedTerseObjectUpdate</summary>
        ImprovedTerseObjectUpdate,
        /// <summary>KillObject</summary>
        KillObject,
        /// <summary>AgentToNewRegion</summary>
        AgentToNewRegion,
        /// <summary>TransferPacket</summary>
        TransferPacket,
        /// <summary>SendXferPacket</summary>
        SendXferPacket,
        /// <summary>ConfirmXferPacket</summary>
        ConfirmXferPacket,
        /// <summary>AvatarAnimation</summary>
        AvatarAnimation,
        /// <summary>AvatarSitResponse</summary>
        AvatarSitResponse,
        /// <summary>CameraConstraint</summary>
        CameraConstraint,
        /// <summary>ParcelProperties</summary>
        ParcelProperties,
        /// <summary>EdgeDataPacket</summary>
        EdgeDataPacket,
        /// <summary>ChildAgentUpdate</summary>
        ChildAgentUpdate,
        /// <summary>ChildAgentAlive</summary>
        ChildAgentAlive,
        /// <summary>ChildAgentPositionUpdate</summary>
        ChildAgentPositionUpdate,
        /// <summary>PassObject</summary>
        PassObject,
        /// <summary>AtomicPassObject</summary>
        AtomicPassObject,
        /// <summary>SoundTrigger</summary>
        SoundTrigger,
    }

    /// <summary>Base class for all packet classes</summary>
    public abstract class Packet
    {
        /// <summary>Either a LowHeader, MediumHeader, or HighHeader representing the first bytes of the packet</summary>
        public abstract Header Header { get; set; }
        /// <summary>The type of this packet, identified by it's frequency and ID</summary>
        public abstract PacketType Type { get; }
        /// <summary>Used internally to track timeouts, do not use</summary>
        public int TickCount;

        /// <summary>Serializes the packet in to a byte array</summary>
        /// <returns>A byte array containing the serialized packet payload, ready to be sent across the wire</returns>
        public abstract byte[] ToBytes();

        /// <summary>Construct a packet in it's native class from a byte array</summary>
        /// <param name="bytes">Byte array containing the packet, starting at position 0</param>
        /// <param name="packetEnd">The last byte of the packet. If the packet was 76 bytes long, packetEnd would be 75</param>
        /// <returns>The native packet class for this type of packet, typecasted to the generic Packet</returns>
        public static Packet BuildPacket(byte[] bytes, ref int packetEnd)
        {
            ushort id;
            int i = 0;
            Header header = Header.BuildHeader(bytes, ref i, ref packetEnd);
            if (header.Zerocoded)
            {
                byte[] zeroBuffer = new byte[8192];
                packetEnd = Helpers.ZeroDecode(bytes, packetEnd + 1, zeroBuffer) - 1;
                bytes = zeroBuffer;
            }

            if (bytes[4] == 0xFF)
            {
                if (bytes[5] == 0xFF)
                {
                    id = (ushort)((bytes[6] << 8) + bytes[7]);
                    switch (id)
                    {
                        case 1:
                            return new TestMessagePacket(header, bytes, ref i);
                        case 2:
                            return new AddCircuitCodePacket(header, bytes, ref i);
                        case 3:
                            return new UseCircuitCodePacket(header, bytes, ref i);
                        case 4:
                            return new LogControlPacket(header, bytes, ref i);
                        case 5:
                            return new RelayLogControlPacket(header, bytes, ref i);
                        case 6:
                            return new LogMessagesPacket(header, bytes, ref i);
                        case 7:
                            return new SimulatorAssignPacket(header, bytes, ref i);
                        case 8:
                            return new SpaceServerSimulatorTimeMessagePacket(header, bytes, ref i);
                        case 9:
                            return new AvatarTextureUpdatePacket(header, bytes, ref i);
                        case 10:
                            return new SimulatorMapUpdatePacket(header, bytes, ref i);
                        case 11:
                            return new SimulatorSetMapPacket(header, bytes, ref i);
                        case 12:
                            return new SubscribeLoadPacket(header, bytes, ref i);
                        case 13:
                            return new UnsubscribeLoadPacket(header, bytes, ref i);
                        case 14:
                            return new SimulatorStartPacket(header, bytes, ref i);
                        case 15:
                            return new SimulatorReadyPacket(header, bytes, ref i);
                        case 16:
                            return new TelehubInfoPacket(header, bytes, ref i);
                        case 17:
                            return new SimulatorPresentAtLocationPacket(header, bytes, ref i);
                        case 18:
                            return new SimulatorLoadPacket(header, bytes, ref i);
                        case 19:
                            return new SimulatorShutdownRequestPacket(header, bytes, ref i);
                        case 20:
                            return new RegionPresenceRequestByRegionIDPacket(header, bytes, ref i);
                        case 21:
                            return new RegionPresenceRequestByHandlePacket(header, bytes, ref i);
                        case 22:
                            return new RegionPresenceResponsePacket(header, bytes, ref i);
                        case 23:
                            return new RecordAgentPresencePacket(header, bytes, ref i);
                        case 24:
                            return new EraseAgentPresencePacket(header, bytes, ref i);
                        case 25:
                            return new AgentPresenceRequestPacket(header, bytes, ref i);
                        case 26:
                            return new AgentPresenceResponsePacket(header, bytes, ref i);
                        case 27:
                            return new UpdateSimulatorPacket(header, bytes, ref i);
                        case 28:
                            return new TrackAgentSessionPacket(header, bytes, ref i);
                        case 29:
                            return new ClearAgentSessionsPacket(header, bytes, ref i);
                        case 30:
                            return new LogDwellTimePacket(header, bytes, ref i);
                        case 31:
                            return new LogFailedMoneyTransactionPacket(header, bytes, ref i);
                        case 32:
                            return new UserReportInternalPacket(header, bytes, ref i);
                        case 33:
                            return new SetSimStatusInDatabasePacket(header, bytes, ref i);
                        case 34:
                            return new SetSimPresenceInDatabasePacket(header, bytes, ref i);
                        case 35:
                            return new EconomyDataRequestPacket(header, bytes, ref i);
                        case 36:
                            return new EconomyDataPacket(header, bytes, ref i);
                        case 37:
                            return new AvatarPickerRequestPacket(header, bytes, ref i);
                        case 38:
                            return new AvatarPickerRequestBackendPacket(header, bytes, ref i);
                        case 39:
                            return new AvatarPickerReplyPacket(header, bytes, ref i);
                        case 40:
                            return new PlacesQueryPacket(header, bytes, ref i);
                        case 41:
                            return new PlacesReplyPacket(header, bytes, ref i);
                        case 42:
                            return new DirFindQueryPacket(header, bytes, ref i);
                        case 43:
                            return new DirFindQueryBackendPacket(header, bytes, ref i);
                        case 44:
                            return new DirPlacesQueryPacket(header, bytes, ref i);
                        case 45:
                            return new DirPlacesQueryBackendPacket(header, bytes, ref i);
                        case 46:
                            return new DirPlacesReplyPacket(header, bytes, ref i);
                        case 47:
                            return new DirPeopleQueryPacket(header, bytes, ref i);
                        case 48:
                            return new DirPeopleQueryBackendPacket(header, bytes, ref i);
                        case 49:
                            return new DirPeopleReplyPacket(header, bytes, ref i);
                        case 50:
                            return new DirEventsReplyPacket(header, bytes, ref i);
                        case 51:
                            return new DirGroupsQueryPacket(header, bytes, ref i);
                        case 52:
                            return new DirGroupsQueryBackendPacket(header, bytes, ref i);
                        case 53:
                            return new DirGroupsReplyPacket(header, bytes, ref i);
                        case 54:
                            return new DirClassifiedQueryPacket(header, bytes, ref i);
                        case 55:
                            return new DirClassifiedQueryBackendPacket(header, bytes, ref i);
                        case 56:
                            return new DirClassifiedReplyPacket(header, bytes, ref i);
                        case 57:
                            return new AvatarClassifiedReplyPacket(header, bytes, ref i);
                        case 58:
                            return new ClassifiedInfoRequestPacket(header, bytes, ref i);
                        case 59:
                            return new ClassifiedInfoReplyPacket(header, bytes, ref i);
                        case 60:
                            return new ClassifiedInfoUpdatePacket(header, bytes, ref i);
                        case 61:
                            return new ClassifiedDeletePacket(header, bytes, ref i);
                        case 62:
                            return new ClassifiedGodDeletePacket(header, bytes, ref i);
                        case 63:
                            return new DirPicksQueryPacket(header, bytes, ref i);
                        case 64:
                            return new DirPicksQueryBackendPacket(header, bytes, ref i);
                        case 65:
                            return new DirPicksReplyPacket(header, bytes, ref i);
                        case 66:
                            return new DirLandQueryPacket(header, bytes, ref i);
                        case 67:
                            return new DirLandQueryBackendPacket(header, bytes, ref i);
                        case 68:
                            return new DirLandReplyPacket(header, bytes, ref i);
                        case 69:
                            return new DirPopularQueryPacket(header, bytes, ref i);
                        case 70:
                            return new DirPopularQueryBackendPacket(header, bytes, ref i);
                        case 71:
                            return new DirPopularReplyPacket(header, bytes, ref i);
                        case 72:
                            return new ParcelInfoRequestPacket(header, bytes, ref i);
                        case 73:
                            return new ParcelInfoReplyPacket(header, bytes, ref i);
                        case 74:
                            return new ParcelObjectOwnersRequestPacket(header, bytes, ref i);
                        case 75:
                            return new OnlineStatusRequestPacket(header, bytes, ref i);
                        case 76:
                            return new OnlineStatusReplyPacket(header, bytes, ref i);
                        case 77:
                            return new ParcelObjectOwnersReplyPacket(header, bytes, ref i);
                        case 78:
                            return new GroupNoticesListRequestPacket(header, bytes, ref i);
                        case 79:
                            return new GroupNoticesListReplyPacket(header, bytes, ref i);
                        case 80:
                            return new GroupNoticeRequestPacket(header, bytes, ref i);
                        case 81:
                            return new GroupNoticeAddPacket(header, bytes, ref i);
                        case 82:
                            return new GroupNoticeDeletePacket(header, bytes, ref i);
                        case 83:
                            return new TeleportRequestPacket(header, bytes, ref i);
                        case 84:
                            return new TeleportLocationRequestPacket(header, bytes, ref i);
                        case 85:
                            return new TeleportLocalPacket(header, bytes, ref i);
                        case 86:
                            return new TeleportLandmarkRequestPacket(header, bytes, ref i);
                        case 87:
                            return new TeleportProgressPacket(header, bytes, ref i);
                        case 88:
                            return new DataAgentAccessRequestPacket(header, bytes, ref i);
                        case 89:
                            return new DataAgentAccessReplyPacket(header, bytes, ref i);
                        case 90:
                            return new DataHomeLocationRequestPacket(header, bytes, ref i);
                        case 91:
                            return new DataHomeLocationReplyPacket(header, bytes, ref i);
                        case 92:
                            return new SpaceLocationTeleportRequestPacket(header, bytes, ref i);
                        case 93:
                            return new SpaceLocationTeleportReplyPacket(header, bytes, ref i);
                        case 94:
                            return new TeleportFinishPacket(header, bytes, ref i);
                        case 95:
                            return new StartLurePacket(header, bytes, ref i);
                        case 96:
                            return new TeleportLureRequestPacket(header, bytes, ref i);
                        case 97:
                            return new TeleportCancelPacket(header, bytes, ref i);
                        case 98:
                            return new CompleteLurePacket(header, bytes, ref i);
                        case 99:
                            return new TeleportStartPacket(header, bytes, ref i);
                        case 100:
                            return new TeleportFailedPacket(header, bytes, ref i);
                        case 101:
                            return new LeaderBoardRequestPacket(header, bytes, ref i);
                        case 102:
                            return new LeaderBoardDataPacket(header, bytes, ref i);
                        case 103:
                            return new RegisterNewAgentPacket(header, bytes, ref i);
                        case 104:
                            return new UndoPacket(header, bytes, ref i);
                        case 105:
                            return new RedoPacket(header, bytes, ref i);
                        case 106:
                            return new UndoLandPacket(header, bytes, ref i);
                        case 107:
                            return new RedoLandPacket(header, bytes, ref i);
                        case 108:
                            return new AgentPausePacket(header, bytes, ref i);
                        case 109:
                            return new AgentResumePacket(header, bytes, ref i);
                        case 110:
                            return new ChatFromViewerPacket(header, bytes, ref i);
                        case 111:
                            return new AgentThrottlePacket(header, bytes, ref i);
                        case 112:
                            return new AgentFOVPacket(header, bytes, ref i);
                        case 113:
                            return new AgentHeightWidthPacket(header, bytes, ref i);
                        case 114:
                            return new AgentSetAppearancePacket(header, bytes, ref i);
                        case 115:
                            return new RefreshViewerPacket(header, bytes, ref i);
                        case 116:
                            return new AgentQuitPacket(header, bytes, ref i);
                        case 117:
                            return new AgentQuitCopyPacket(header, bytes, ref i);
                        case 118:
                            return new ImageNotInDatabasePacket(header, bytes, ref i);
                        case 119:
                            return new RebakeAvatarTexturesPacket(header, bytes, ref i);
                        case 120:
                            return new SetAlwaysRunPacket(header, bytes, ref i);
                        case 121:
                            return new ObjectDeletePacket(header, bytes, ref i);
                        case 122:
                            return new ObjectDuplicatePacket(header, bytes, ref i);
                        case 123:
                            return new ObjectDuplicateOnRayPacket(header, bytes, ref i);
                        case 124:
                            return new ObjectScalePacket(header, bytes, ref i);
                        case 125:
                            return new ObjectRotationPacket(header, bytes, ref i);
                        case 126:
                            return new ObjectFlagUpdatePacket(header, bytes, ref i);
                        case 127:
                            return new ObjectClickActionPacket(header, bytes, ref i);
                        case 128:
                            return new ObjectImagePacket(header, bytes, ref i);
                        case 129:
                            return new ObjectMaterialPacket(header, bytes, ref i);
                        case 130:
                            return new ObjectShapePacket(header, bytes, ref i);
                        case 131:
                            return new ObjectExtraParamsPacket(header, bytes, ref i);
                        case 132:
                            return new ObjectOwnerPacket(header, bytes, ref i);
                        case 133:
                            return new ObjectGroupPacket(header, bytes, ref i);
                        case 134:
                            return new ObjectBuyPacket(header, bytes, ref i);
                        case 135:
                            return new BuyObjectInventoryPacket(header, bytes, ref i);
                        case 136:
                            return new DerezContainerPacket(header, bytes, ref i);
                        case 137:
                            return new ObjectPermissionsPacket(header, bytes, ref i);
                        case 138:
                            return new ObjectSaleInfoPacket(header, bytes, ref i);
                        case 139:
                            return new ObjectNamePacket(header, bytes, ref i);
                        case 140:
                            return new ObjectDescriptionPacket(header, bytes, ref i);
                        case 141:
                            return new ObjectCategoryPacket(header, bytes, ref i);
                        case 142:
                            return new ObjectSelectPacket(header, bytes, ref i);
                        case 143:
                            return new ObjectDeselectPacket(header, bytes, ref i);
                        case 144:
                            return new ObjectAttachPacket(header, bytes, ref i);
                        case 145:
                            return new ObjectDetachPacket(header, bytes, ref i);
                        case 146:
                            return new ObjectDropPacket(header, bytes, ref i);
                        case 147:
                            return new ObjectLinkPacket(header, bytes, ref i);
                        case 148:
                            return new ObjectDelinkPacket(header, bytes, ref i);
                        case 149:
                            return new ObjectHingePacket(header, bytes, ref i);
                        case 150:
                            return new ObjectDehingePacket(header, bytes, ref i);
                        case 151:
                            return new ObjectGrabPacket(header, bytes, ref i);
                        case 152:
                            return new ObjectGrabUpdatePacket(header, bytes, ref i);
                        case 153:
                            return new ObjectDeGrabPacket(header, bytes, ref i);
                        case 154:
                            return new ObjectSpinStartPacket(header, bytes, ref i);
                        case 155:
                            return new ObjectSpinUpdatePacket(header, bytes, ref i);
                        case 156:
                            return new ObjectSpinStopPacket(header, bytes, ref i);
                        case 157:
                            return new ObjectExportSelectedPacket(header, bytes, ref i);
                        case 158:
                            return new ObjectImportPacket(header, bytes, ref i);
                        case 159:
                            return new ModifyLandPacket(header, bytes, ref i);
                        case 160:
                            return new VelocityInterpolateOnPacket(header, bytes, ref i);
                        case 161:
                            return new VelocityInterpolateOffPacket(header, bytes, ref i);
                        case 162:
                            return new StateSavePacket(header, bytes, ref i);
                        case 163:
                            return new ReportAutosaveCrashPacket(header, bytes, ref i);
                        case 164:
                            return new SimWideDeletesPacket(header, bytes, ref i);
                        case 165:
                            return new StateLoadPacket(header, bytes, ref i);
                        case 166:
                            return new TrackAgentPacket(header, bytes, ref i);
                        case 167:
                            return new GrantModificationPacket(header, bytes, ref i);
                        case 168:
                            return new RevokeModificationPacket(header, bytes, ref i);
                        case 169:
                            return new RequestGrantedProxiesPacket(header, bytes, ref i);
                        case 170:
                            return new GrantedProxiesPacket(header, bytes, ref i);
                        case 171:
                            return new AddModifyAbilityPacket(header, bytes, ref i);
                        case 172:
                            return new RemoveModifyAbilityPacket(header, bytes, ref i);
                        case 173:
                            return new ViewerStatsPacket(header, bytes, ref i);
                        case 174:
                            return new ScriptAnswerYesPacket(header, bytes, ref i);
                        case 175:
                            return new UserReportPacket(header, bytes, ref i);
                        case 176:
                            return new AlertMessagePacket(header, bytes, ref i);
                        case 177:
                            return new AgentAlertMessagePacket(header, bytes, ref i);
                        case 178:
                            return new MeanCollisionAlertPacket(header, bytes, ref i);
                        case 179:
                            return new ViewerFrozenMessagePacket(header, bytes, ref i);
                        case 180:
                            return new HealthMessagePacket(header, bytes, ref i);
                        case 181:
                            return new ChatFromSimulatorPacket(header, bytes, ref i);
                        case 182:
                            return new SimStatsPacket(header, bytes, ref i);
                        case 183:
                            return new RequestRegionInfoPacket(header, bytes, ref i);
                        case 184:
                            return new RegionInfoPacket(header, bytes, ref i);
                        case 185:
                            return new GodUpdateRegionInfoPacket(header, bytes, ref i);
                        case 186:
                            return new NearestLandingRegionRequestPacket(header, bytes, ref i);
                        case 187:
                            return new NearestLandingRegionReplyPacket(header, bytes, ref i);
                        case 188:
                            return new NearestLandingRegionUpdatedPacket(header, bytes, ref i);
                        case 189:
                            return new TeleportLandingStatusChangedPacket(header, bytes, ref i);
                        case 190:
                            return new RegionHandshakePacket(header, bytes, ref i);
                        case 191:
                            return new RegionHandshakeReplyPacket(header, bytes, ref i);
                        case 192:
                            return new SimulatorViewerTimeMessagePacket(header, bytes, ref i);
                        case 193:
                            return new EnableSimulatorPacket(header, bytes, ref i);
                        case 194:
                            return new DisableSimulatorPacket(header, bytes, ref i);
                        case 195:
                            return new TransferRequestPacket(header, bytes, ref i);
                        case 196:
                            return new TransferInfoPacket(header, bytes, ref i);
                        case 197:
                            return new TransferAbortPacket(header, bytes, ref i);
                        case 198:
                            return new TransferPriorityPacket(header, bytes, ref i);
                        case 199:
                            return new RequestXferPacket(header, bytes, ref i);
                        case 200:
                            return new AbortXferPacket(header, bytes, ref i);
                        case 201:
                            return new RequestAvatarInfoPacket(header, bytes, ref i);
                        case 202:
                            return new AvatarAppearancePacket(header, bytes, ref i);
                        case 203:
                            return new SetFollowCamPropertiesPacket(header, bytes, ref i);
                        case 204:
                            return new ClearFollowCamPropertiesPacket(header, bytes, ref i);
                        case 205:
                            return new RequestPayPricePacket(header, bytes, ref i);
                        case 206:
                            return new PayPriceReplyPacket(header, bytes, ref i);
                        case 207:
                            return new KickUserPacket(header, bytes, ref i);
                        case 208:
                            return new KickUserAckPacket(header, bytes, ref i);
                        case 209:
                            return new GodKickUserPacket(header, bytes, ref i);
                        case 210:
                            return new SystemKickUserPacket(header, bytes, ref i);
                        case 211:
                            return new EjectUserPacket(header, bytes, ref i);
                        case 212:
                            return new FreezeUserPacket(header, bytes, ref i);
                        case 213:
                            return new AvatarPropertiesRequestPacket(header, bytes, ref i);
                        case 214:
                            return new AvatarPropertiesRequestBackendPacket(header, bytes, ref i);
                        case 215:
                            return new AvatarPropertiesReplyPacket(header, bytes, ref i);
                        case 216:
                            return new AvatarGroupsReplyPacket(header, bytes, ref i);
                        case 217:
                            return new AvatarPropertiesUpdatePacket(header, bytes, ref i);
                        case 218:
                            return new AvatarStatisticsReplyPacket(header, bytes, ref i);
                        case 219:
                            return new AvatarNotesReplyPacket(header, bytes, ref i);
                        case 220:
                            return new AvatarNotesUpdatePacket(header, bytes, ref i);
                        case 221:
                            return new AvatarPicksReplyPacket(header, bytes, ref i);
                        case 222:
                            return new EventInfoRequestPacket(header, bytes, ref i);
                        case 223:
                            return new EventInfoReplyPacket(header, bytes, ref i);
                        case 224:
                            return new EventNotificationAddRequestPacket(header, bytes, ref i);
                        case 225:
                            return new EventNotificationRemoveRequestPacket(header, bytes, ref i);
                        case 226:
                            return new EventGodDeletePacket(header, bytes, ref i);
                        case 227:
                            return new PickInfoRequestPacket(header, bytes, ref i);
                        case 228:
                            return new PickInfoReplyPacket(header, bytes, ref i);
                        case 229:
                            return new PickInfoUpdatePacket(header, bytes, ref i);
                        case 230:
                            return new PickDeletePacket(header, bytes, ref i);
                        case 231:
                            return new PickGodDeletePacket(header, bytes, ref i);
                        case 232:
                            return new ScriptQuestionPacket(header, bytes, ref i);
                        case 233:
                            return new ScriptControlChangePacket(header, bytes, ref i);
                        case 234:
                            return new ScriptDialogPacket(header, bytes, ref i);
                        case 235:
                            return new ScriptDialogReplyPacket(header, bytes, ref i);
                        case 236:
                            return new ForceScriptControlReleasePacket(header, bytes, ref i);
                        case 237:
                            return new RevokePermissionsPacket(header, bytes, ref i);
                        case 238:
                            return new LoadURLPacket(header, bytes, ref i);
                        case 239:
                            return new ScriptTeleportRequestPacket(header, bytes, ref i);
                        case 240:
                            return new ParcelOverlayPacket(header, bytes, ref i);
                        case 241:
                            return new ParcelPropertiesRequestByIDPacket(header, bytes, ref i);
                        case 242:
                            return new ParcelPropertiesUpdatePacket(header, bytes, ref i);
                        case 243:
                            return new ParcelReturnObjectsPacket(header, bytes, ref i);
                        case 244:
                            return new ParcelSetOtherCleanTimePacket(header, bytes, ref i);
                        case 245:
                            return new ParcelDisableObjectsPacket(header, bytes, ref i);
                        case 246:
                            return new ParcelSelectObjectsPacket(header, bytes, ref i);
                        case 247:
                            return new EstateCovenantRequestPacket(header, bytes, ref i);
                        case 248:
                            return new EstateCovenantReplyPacket(header, bytes, ref i);
                        case 249:
                            return new ForceObjectSelectPacket(header, bytes, ref i);
                        case 250:
                            return new ParcelBuyPassPacket(header, bytes, ref i);
                        case 251:
                            return new ParcelDeedToGroupPacket(header, bytes, ref i);
                        case 252:
                            return new ParcelReclaimPacket(header, bytes, ref i);
                        case 253:
                            return new ParcelClaimPacket(header, bytes, ref i);
                        case 254:
                            return new ParcelJoinPacket(header, bytes, ref i);
                        case 255:
                            return new ParcelDividePacket(header, bytes, ref i);
                        case 256:
                            return new ParcelReleasePacket(header, bytes, ref i);
                        case 257:
                            return new ParcelBuyPacket(header, bytes, ref i);
                        case 258:
                            return new ParcelGodForceOwnerPacket(header, bytes, ref i);
                        case 259:
                            return new ParcelAccessListRequestPacket(header, bytes, ref i);
                        case 260:
                            return new ParcelAccessListReplyPacket(header, bytes, ref i);
                        case 261:
                            return new ParcelAccessListUpdatePacket(header, bytes, ref i);
                        case 262:
                            return new ParcelDwellRequestPacket(header, bytes, ref i);
                        case 263:
                            return new ParcelDwellReplyPacket(header, bytes, ref i);
                        case 264:
                            return new RequestParcelTransferPacket(header, bytes, ref i);
                        case 265:
                            return new UpdateParcelPacket(header, bytes, ref i);
                        case 266:
                            return new RemoveParcelPacket(header, bytes, ref i);
                        case 267:
                            return new MergeParcelPacket(header, bytes, ref i);
                        case 268:
                            return new LogParcelChangesPacket(header, bytes, ref i);
                        case 269:
                            return new CheckParcelSalesPacket(header, bytes, ref i);
                        case 270:
                            return new ParcelSalesPacket(header, bytes, ref i);
                        case 271:
                            return new ParcelGodMarkAsContentPacket(header, bytes, ref i);
                        case 272:
                            return new ParcelGodReserveForNewbiePacket(header, bytes, ref i);
                        case 273:
                            return new ViewerStartAuctionPacket(header, bytes, ref i);
                        case 274:
                            return new StartAuctionPacket(header, bytes, ref i);
                        case 275:
                            return new ConfirmAuctionStartPacket(header, bytes, ref i);
                        case 276:
                            return new CompleteAuctionPacket(header, bytes, ref i);
                        case 277:
                            return new CancelAuctionPacket(header, bytes, ref i);
                        case 278:
                            return new CheckParcelAuctionsPacket(header, bytes, ref i);
                        case 279:
                            return new ParcelAuctionsPacket(header, bytes, ref i);
                        case 280:
                            return new UUIDNameRequestPacket(header, bytes, ref i);
                        case 281:
                            return new UUIDNameReplyPacket(header, bytes, ref i);
                        case 282:
                            return new UUIDGroupNameRequestPacket(header, bytes, ref i);
                        case 283:
                            return new UUIDGroupNameReplyPacket(header, bytes, ref i);
                        case 284:
                            return new ChatPassPacket(header, bytes, ref i);
                        case 285:
                            return new ChildAgentDyingPacket(header, bytes, ref i);
                        case 286:
                            return new ChildAgentUnknownPacket(header, bytes, ref i);
                        case 287:
                            return new KillChildAgentsPacket(header, bytes, ref i);
                        case 288:
                            return new GetScriptRunningPacket(header, bytes, ref i);
                        case 289:
                            return new ScriptRunningReplyPacket(header, bytes, ref i);
                        case 290:
                            return new SetScriptRunningPacket(header, bytes, ref i);
                        case 291:
                            return new ScriptResetPacket(header, bytes, ref i);
                        case 292:
                            return new ScriptSensorRequestPacket(header, bytes, ref i);
                        case 293:
                            return new ScriptSensorReplyPacket(header, bytes, ref i);
                        case 294:
                            return new CompleteAgentMovementPacket(header, bytes, ref i);
                        case 295:
                            return new AgentMovementCompletePacket(header, bytes, ref i);
                        case 296:
                            return new LogLoginPacket(header, bytes, ref i);
                        case 297:
                            return new ConnectAgentToUserserverPacket(header, bytes, ref i);
                        case 298:
                            return new ConnectToUserserverPacket(header, bytes, ref i);
                        case 299:
                            return new DataServerLogoutPacket(header, bytes, ref i);
                        case 300:
                            return new LogoutRequestPacket(header, bytes, ref i);
                        case 301:
                            return new FinalizeLogoutPacket(header, bytes, ref i);
                        case 302:
                            return new LogoutReplyPacket(header, bytes, ref i);
                        case 303:
                            return new LogoutDemandPacket(header, bytes, ref i);
                        case 304:
                            return new ViewerLoginLocationRequestPacket(header, bytes, ref i);
                        case 305:
                            return new ViewerSimLocationRequestPacket(header, bytes, ref i);
                        case 306:
                            return new RequestLocationGetAccessPacket(header, bytes, ref i);
                        case 307:
                            return new RequestLocationGetAccessReplyPacket(header, bytes, ref i);
                        case 308:
                            return new UserListRequestPacket(header, bytes, ref i);
                        case 309:
                            return new ImprovedInstantMessagePacket(header, bytes, ref i);
                        case 310:
                            return new StartGroupIMPacket(header, bytes, ref i);
                        case 311:
                            return new DropGroupIMPacket(header, bytes, ref i);
                        case 312:
                            return new GroupIMPacket(header, bytes, ref i);
                        case 313:
                            return new RetrieveInstantMessagesPacket(header, bytes, ref i);
                        case 314:
                            return new DequeueInstantMessagesPacket(header, bytes, ref i);
                        case 315:
                            return new FindAgentPacket(header, bytes, ref i);
                        case 316:
                            return new TrackOnlineStatusPacket(header, bytes, ref i);
                        case 317:
                            return new IgnoreOnlineStatusPacket(header, bytes, ref i);
                        case 318:
                            return new RequestGodlikePowersPacket(header, bytes, ref i);
                        case 319:
                            return new GrantGodlikePowersPacket(header, bytes, ref i);
                        case 320:
                            return new GodlikeMessagePacket(header, bytes, ref i);
                        case 321:
                            return new EstateOwnerMessagePacket(header, bytes, ref i);
                        case 322:
                            return new GenericMessagePacket(header, bytes, ref i);
                        case 323:
                            return new MuteListRequestPacket(header, bytes, ref i);
                        case 324:
                            return new UpdateMuteListEntryPacket(header, bytes, ref i);
                        case 325:
                            return new RemoveMuteListEntryPacket(header, bytes, ref i);
                        case 326:
                            return new UpdateInventoryItemPacket(header, bytes, ref i);
                        case 327:
                            return new UpdateInventoryItemAssetPacket(header, bytes, ref i);
                        case 328:
                            return new MoveInventoryItemPacket(header, bytes, ref i);
                        case 329:
                            return new CopyInventoryItemPacket(header, bytes, ref i);
                        case 330:
                            return new RemoveInventoryItemPacket(header, bytes, ref i);
                        case 331:
                            return new ChangeInventoryItemFlagsPacket(header, bytes, ref i);
                        case 332:
                            return new SaveAssetIntoInventoryPacket(header, bytes, ref i);
                        case 333:
                            return new CreateInventoryFolderPacket(header, bytes, ref i);
                        case 334:
                            return new UpdateInventoryFolderPacket(header, bytes, ref i);
                        case 335:
                            return new MoveInventoryFolderPacket(header, bytes, ref i);
                        case 336:
                            return new RemoveInventoryFolderPacket(header, bytes, ref i);
                        case 337:
                            return new FetchInventoryDescendentsPacket(header, bytes, ref i);
                        case 338:
                            return new InventoryDescendentsPacket(header, bytes, ref i);
                        case 339:
                            return new FetchInventoryPacket(header, bytes, ref i);
                        case 340:
                            return new FetchInventoryReplyPacket(header, bytes, ref i);
                        case 341:
                            return new BulkUpdateInventoryPacket(header, bytes, ref i);
                        case 342:
                            return new RequestInventoryAssetPacket(header, bytes, ref i);
                        case 343:
                            return new InventoryAssetResponsePacket(header, bytes, ref i);
                        case 344:
                            return new RemoveInventoryObjectsPacket(header, bytes, ref i);
                        case 345:
                            return new PurgeInventoryDescendentsPacket(header, bytes, ref i);
                        case 346:
                            return new UpdateTaskInventoryPacket(header, bytes, ref i);
                        case 347:
                            return new RemoveTaskInventoryPacket(header, bytes, ref i);
                        case 348:
                            return new MoveTaskInventoryPacket(header, bytes, ref i);
                        case 349:
                            return new RequestTaskInventoryPacket(header, bytes, ref i);
                        case 350:
                            return new ReplyTaskInventoryPacket(header, bytes, ref i);
                        case 351:
                            return new DeRezObjectPacket(header, bytes, ref i);
                        case 352:
                            return new DeRezAckPacket(header, bytes, ref i);
                        case 353:
                            return new RezObjectPacket(header, bytes, ref i);
                        case 354:
                            return new DeclineInventoryPacket(header, bytes, ref i);
                        case 355:
                            return new TransferInventoryPacket(header, bytes, ref i);
                        case 356:
                            return new TransferInventoryAckPacket(header, bytes, ref i);
                        case 357:
                            return new RequestFriendshipPacket(header, bytes, ref i);
                        case 358:
                            return new AcceptFriendshipPacket(header, bytes, ref i);
                        case 359:
                            return new DeclineFriendshipPacket(header, bytes, ref i);
                        case 360:
                            return new FormFriendshipPacket(header, bytes, ref i);
                        case 361:
                            return new TerminateFriendshipPacket(header, bytes, ref i);
                        case 362:
                            return new OfferCallingCardPacket(header, bytes, ref i);
                        case 363:
                            return new AcceptCallingCardPacket(header, bytes, ref i);
                        case 364:
                            return new DeclineCallingCardPacket(header, bytes, ref i);
                        case 365:
                            return new RezScriptPacket(header, bytes, ref i);
                        case 366:
                            return new CreateInventoryItemPacket(header, bytes, ref i);
                        case 367:
                            return new CreateLandmarkForEventPacket(header, bytes, ref i);
                        case 368:
                            return new EventLocationRequestPacket(header, bytes, ref i);
                        case 369:
                            return new EventLocationReplyPacket(header, bytes, ref i);
                        case 370:
                            return new RegionHandleRequestPacket(header, bytes, ref i);
                        case 371:
                            return new RegionIDAndHandleReplyPacket(header, bytes, ref i);
                        case 372:
                            return new MoneyTransferRequestPacket(header, bytes, ref i);
                        case 373:
                            return new MoneyTransferBackendPacket(header, bytes, ref i);
                        case 374:
                            return new BulkMoneyTransferPacket(header, bytes, ref i);
                        case 375:
                            return new AdjustBalancePacket(header, bytes, ref i);
                        case 376:
                            return new MoneyBalanceRequestPacket(header, bytes, ref i);
                        case 377:
                            return new MoneyBalanceReplyPacket(header, bytes, ref i);
                        case 378:
                            return new RoutedMoneyBalanceReplyPacket(header, bytes, ref i);
                        case 379:
                            return new MoneyHistoryRequestPacket(header, bytes, ref i);
                        case 380:
                            return new MoneyHistoryReplyPacket(header, bytes, ref i);
                        case 381:
                            return new MoneySummaryRequestPacket(header, bytes, ref i);
                        case 382:
                            return new MoneySummaryReplyPacket(header, bytes, ref i);
                        case 383:
                            return new MoneyDetailsRequestPacket(header, bytes, ref i);
                        case 384:
                            return new MoneyDetailsReplyPacket(header, bytes, ref i);
                        case 385:
                            return new MoneyTransactionsRequestPacket(header, bytes, ref i);
                        case 386:
                            return new MoneyTransactionsReplyPacket(header, bytes, ref i);
                        case 387:
                            return new GestureRequestPacket(header, bytes, ref i);
                        case 388:
                            return new ActivateGesturesPacket(header, bytes, ref i);
                        case 389:
                            return new DeactivateGesturesPacket(header, bytes, ref i);
                        case 390:
                            return new InventoryUpdatePacket(header, bytes, ref i);
                        case 391:
                            return new MuteListUpdatePacket(header, bytes, ref i);
                        case 392:
                            return new UseCachedMuteListPacket(header, bytes, ref i);
                        case 393:
                            return new UserLoginLocationReplyPacket(header, bytes, ref i);
                        case 394:
                            return new UserSimLocationReplyPacket(header, bytes, ref i);
                        case 395:
                            return new UserListReplyPacket(header, bytes, ref i);
                        case 396:
                            return new OnlineNotificationPacket(header, bytes, ref i);
                        case 397:
                            return new OfflineNotificationPacket(header, bytes, ref i);
                        case 398:
                            return new SetStartLocationRequestPacket(header, bytes, ref i);
                        case 399:
                            return new SetStartLocationPacket(header, bytes, ref i);
                        case 400:
                            return new UserLoginLocationRequestPacket(header, bytes, ref i);
                        case 401:
                            return new SpaceLoginLocationReplyPacket(header, bytes, ref i);
                        case 402:
                            return new NetTestPacket(header, bytes, ref i);
                        case 403:
                            return new SetCPURatioPacket(header, bytes, ref i);
                        case 404:
                            return new SimCrashedPacket(header, bytes, ref i);
                        case 405:
                            return new SimulatorPauseStatePacket(header, bytes, ref i);
                        case 406:
                            return new SimulatorThrottleSettingsPacket(header, bytes, ref i);
                        case 407:
                            return new NameValuePairPacket(header, bytes, ref i);
                        case 408:
                            return new RemoveNameValuePairPacket(header, bytes, ref i);
                        case 409:
                            return new GetNameValuePairPacket(header, bytes, ref i);
                        case 410:
                            return new UpdateAttachmentPacket(header, bytes, ref i);
                        case 411:
                            return new RemoveAttachmentPacket(header, bytes, ref i);
                        case 412:
                            return new AssetUploadRequestPacket(header, bytes, ref i);
                        case 413:
                            return new AssetUploadCompletePacket(header, bytes, ref i);
                        case 414:
                            return new ReputationAgentAssignPacket(header, bytes, ref i);
                        case 415:
                            return new ReputationIndividualRequestPacket(header, bytes, ref i);
                        case 416:
                            return new ReputationIndividualReplyPacket(header, bytes, ref i);
                        case 417:
                            return new EmailMessageRequestPacket(header, bytes, ref i);
                        case 418:
                            return new EmailMessageReplyPacket(header, bytes, ref i);
                        case 419:
                            return new ScriptDataRequestPacket(header, bytes, ref i);
                        case 420:
                            return new ScriptDataReplyPacket(header, bytes, ref i);
                        case 421:
                            return new CreateGroupRequestPacket(header, bytes, ref i);
                        case 422:
                            return new CreateGroupReplyPacket(header, bytes, ref i);
                        case 423:
                            return new UpdateGroupInfoPacket(header, bytes, ref i);
                        case 424:
                            return new GroupRoleChangesPacket(header, bytes, ref i);
                        case 425:
                            return new JoinGroupRequestPacket(header, bytes, ref i);
                        case 426:
                            return new JoinGroupReplyPacket(header, bytes, ref i);
                        case 427:
                            return new EjectGroupMemberRequestPacket(header, bytes, ref i);
                        case 428:
                            return new EjectGroupMemberReplyPacket(header, bytes, ref i);
                        case 429:
                            return new LeaveGroupRequestPacket(header, bytes, ref i);
                        case 430:
                            return new LeaveGroupReplyPacket(header, bytes, ref i);
                        case 431:
                            return new InviteGroupRequestPacket(header, bytes, ref i);
                        case 432:
                            return new InviteGroupResponsePacket(header, bytes, ref i);
                        case 433:
                            return new GroupProfileRequestPacket(header, bytes, ref i);
                        case 434:
                            return new GroupProfileReplyPacket(header, bytes, ref i);
                        case 435:
                            return new GroupAccountSummaryRequestPacket(header, bytes, ref i);
                        case 436:
                            return new GroupAccountSummaryReplyPacket(header, bytes, ref i);
                        case 437:
                            return new GroupAccountDetailsRequestPacket(header, bytes, ref i);
                        case 438:
                            return new GroupAccountDetailsReplyPacket(header, bytes, ref i);
                        case 439:
                            return new GroupAccountTransactionsRequestPacket(header, bytes, ref i);
                        case 440:
                            return new GroupAccountTransactionsReplyPacket(header, bytes, ref i);
                        case 441:
                            return new GroupActiveProposalsRequestPacket(header, bytes, ref i);
                        case 442:
                            return new GroupActiveProposalItemReplyPacket(header, bytes, ref i);
                        case 443:
                            return new GroupVoteHistoryRequestPacket(header, bytes, ref i);
                        case 444:
                            return new GroupVoteHistoryItemReplyPacket(header, bytes, ref i);
                        case 445:
                            return new StartGroupProposalPacket(header, bytes, ref i);
                        case 446:
                            return new GroupProposalBallotPacket(header, bytes, ref i);
                        case 447:
                            return new TallyVotesPacket(header, bytes, ref i);
                        case 448:
                            return new GroupMembersRequestPacket(header, bytes, ref i);
                        case 449:
                            return new GroupMembersReplyPacket(header, bytes, ref i);
                        case 450:
                            return new ActivateGroupPacket(header, bytes, ref i);
                        case 451:
                            return new SetGroupContributionPacket(header, bytes, ref i);
                        case 452:
                            return new SetGroupAcceptNoticesPacket(header, bytes, ref i);
                        case 453:
                            return new GroupRoleDataRequestPacket(header, bytes, ref i);
                        case 454:
                            return new GroupRoleDataReplyPacket(header, bytes, ref i);
                        case 455:
                            return new GroupRoleMembersRequestPacket(header, bytes, ref i);
                        case 456:
                            return new GroupRoleMembersReplyPacket(header, bytes, ref i);
                        case 457:
                            return new GroupTitlesRequestPacket(header, bytes, ref i);
                        case 458:
                            return new GroupTitlesReplyPacket(header, bytes, ref i);
                        case 459:
                            return new GroupTitleUpdatePacket(header, bytes, ref i);
                        case 460:
                            return new GroupRoleUpdatePacket(header, bytes, ref i);
                        case 461:
                            return new LiveHelpGroupRequestPacket(header, bytes, ref i);
                        case 462:
                            return new LiveHelpGroupReplyPacket(header, bytes, ref i);
                        case 463:
                            return new AgentWearablesRequestPacket(header, bytes, ref i);
                        case 464:
                            return new AgentWearablesUpdatePacket(header, bytes, ref i);
                        case 465:
                            return new AgentCachedTexturePacket(header, bytes, ref i);
                        case 466:
                            return new AgentCachedTextureResponsePacket(header, bytes, ref i);
                        case 467:
                            return new AgentDataUpdateRequestPacket(header, bytes, ref i);
                        case 468:
                            return new AgentDataUpdatePacket(header, bytes, ref i);
                        case 469:
                            return new GroupDataUpdatePacket(header, bytes, ref i);
                        case 470:
                            return new AgentGroupDataUpdatePacket(header, bytes, ref i);
                        case 471:
                            return new AgentDropGroupPacket(header, bytes, ref i);
                        case 472:
                            return new LogTextMessagePacket(header, bytes, ref i);
                        case 473:
                            return new CreateTrustedCircuitPacket(header, bytes, ref i);
                        case 474:
                            return new DenyTrustedCircuitPacket(header, bytes, ref i);
                        case 475:
                            return new RezSingleAttachmentFromInvPacket(header, bytes, ref i);
                        case 476:
                            return new RezMultipleAttachmentsFromInvPacket(header, bytes, ref i);
                        case 477:
                            return new DetachAttachmentIntoInvPacket(header, bytes, ref i);
                        case 478:
                            return new CreateNewOutfitAttachmentsPacket(header, bytes, ref i);
                        case 479:
                            return new UserInfoRequestPacket(header, bytes, ref i);
                        case 480:
                            return new UserInfoReplyPacket(header, bytes, ref i);
                        case 481:
                            return new UpdateUserInfoPacket(header, bytes, ref i);
                        case 482:
                            return new GodExpungeUserPacket(header, bytes, ref i);
                        case 483:
                            return new StartExpungeProcessPacket(header, bytes, ref i);
                        case 484:
                            return new StartExpungeProcessAckPacket(header, bytes, ref i);
                        case 485:
                            return new StartParcelRenamePacket(header, bytes, ref i);
                        case 486:
                            return new StartParcelRenameAckPacket(header, bytes, ref i);
                        case 487:
                            return new BulkParcelRenamePacket(header, bytes, ref i);
                        case 488:
                            return new ParcelRenamePacket(header, bytes, ref i);
                        case 489:
                            return new StartParcelRemovePacket(header, bytes, ref i);
                        case 490:
                            return new StartParcelRemoveAckPacket(header, bytes, ref i);
                        case 491:
                            return new BulkParcelRemovePacket(header, bytes, ref i);
                        case 492:
                            return new InitiateUploadPacket(header, bytes, ref i);
                        case 493:
                            return new InitiateDownloadPacket(header, bytes, ref i);
                        case 494:
                            return new SystemMessagePacket(header, bytes, ref i);
                        case 495:
                            return new MapLayerRequestPacket(header, bytes, ref i);
                        case 496:
                            return new MapLayerReplyPacket(header, bytes, ref i);
                        case 497:
                            return new MapBlockRequestPacket(header, bytes, ref i);
                        case 498:
                            return new MapNameRequestPacket(header, bytes, ref i);
                        case 499:
                            return new MapBlockReplyPacket(header, bytes, ref i);
                        case 500:
                            return new MapItemRequestPacket(header, bytes, ref i);
                        case 501:
                            return new MapItemReplyPacket(header, bytes, ref i);
                        case 502:
                            return new SendPostcardPacket(header, bytes, ref i);
                        case 503:
                            return new RpcChannelRequestPacket(header, bytes, ref i);
                        case 504:
                            return new RpcChannelReplyPacket(header, bytes, ref i);
                        case 505:
                            return new RpcScriptRequestInboundPacket(header, bytes, ref i);
                        case 506:
                            return new RpcScriptRequestInboundForwardPacket(header, bytes, ref i);
                        case 507:
                            return new RpcScriptReplyInboundPacket(header, bytes, ref i);
                        case 508:
                            return new MailTaskSimRequestPacket(header, bytes, ref i);
                        case 509:
                            return new MailTaskSimReplyPacket(header, bytes, ref i);
                        case 510:
                            return new ScriptMailRegistrationPacket(header, bytes, ref i);
                        case 511:
                            return new MailPingBouncePacket(header, bytes, ref i);
                        case 512:
                            return new ParcelMediaCommandMessagePacket(header, bytes, ref i);
                        case 513:
                            return new ParcelMediaUpdatePacket(header, bytes, ref i);
                        case 514:
                            return new LandStatRequestPacket(header, bytes, ref i);
                        case 515:
                            return new LandStatReplyPacket(header, bytes, ref i);
                        case 65530:
                            return new SecuredTemplateChecksumRequestPacket(header, bytes, ref i);
                        case 65531:
                            return new PacketAckPacket(header, bytes, ref i);
                        case 65532:
                            return new OpenCircuitPacket(header, bytes, ref i);
                        case 65533:
                            return new CloseCircuitPacket(header, bytes, ref i);
                        case 65534:
                            return new TemplateChecksumRequestPacket(header, bytes, ref i);
                        case 65535:
                            return new TemplateChecksumReplyPacket(header, bytes, ref i);
                    }
                }
                else
                {
                    id = (ushort)bytes[5];
                    switch (id)
                    {
                        case 1:
                            return new ClosestSimulatorPacket(header, bytes, ref i);
                        case 2:
                            return new ObjectAddPacket(header, bytes, ref i);
                        case 3:
                            return new MultipleObjectUpdatePacket(header, bytes, ref i);
                        case 4:
                            return new RequestMultipleObjectsPacket(header, bytes, ref i);
                        case 5:
                            return new ObjectPositionPacket(header, bytes, ref i);
                        case 6:
                            return new RequestObjectPropertiesFamilyPacket(header, bytes, ref i);
                        case 7:
                            return new CoarseLocationUpdatePacket(header, bytes, ref i);
                        case 8:
                            return new CrossedRegionPacket(header, bytes, ref i);
                        case 9:
                            return new ConfirmEnableSimulatorPacket(header, bytes, ref i);
                        case 10:
                            return new ObjectPropertiesPacket(header, bytes, ref i);
                        case 11:
                            return new ObjectPropertiesFamilyPacket(header, bytes, ref i);
                        case 12:
                            return new ParcelPropertiesRequestPacket(header, bytes, ref i);
                        case 13:
                            return new SimStatusPacket(header, bytes, ref i);
                        case 14:
                            return new GestureUpdatePacket(header, bytes, ref i);
                        case 15:
                            return new AttachedSoundPacket(header, bytes, ref i);
                        case 16:
                            return new AttachedSoundGainChangePacket(header, bytes, ref i);
                        case 17:
                            return new AttachedSoundCutoffRadiusPacket(header, bytes, ref i);
                        case 18:
                            return new PreloadSoundPacket(header, bytes, ref i);
                        case 19:
                            return new InternalScriptMailPacket(header, bytes, ref i);
                        case 20:
                            return new ViewerEffectPacket(header, bytes, ref i);
                        case 21:
                            return new SetSunPhasePacket(header, bytes, ref i);
                    }
                }
            }
            else
            {
                id = (ushort)bytes[4];
                switch (id)
                    {
                        case 1:
                            return new StartPingCheckPacket(header, bytes, ref i);
                        case 2:
                            return new CompletePingCheckPacket(header, bytes, ref i);
                        case 3:
                            return new NeighborListPacket(header, bytes, ref i);
                        case 4:
                            return new MovedIntoSimulatorPacket(header, bytes, ref i);
                        case 5:
                            return new AgentUpdatePacket(header, bytes, ref i);
                        case 6:
                            return new AgentAnimationPacket(header, bytes, ref i);
                        case 7:
                            return new AgentRequestSitPacket(header, bytes, ref i);
                        case 8:
                            return new AgentSitPacket(header, bytes, ref i);
                        case 9:
                            return new RequestImagePacket(header, bytes, ref i);
                        case 10:
                            return new ImageDataPacket(header, bytes, ref i);
                        case 11:
                            return new ImagePacketPacket(header, bytes, ref i);
                        case 12:
                            return new LayerDataPacket(header, bytes, ref i);
                        case 13:
                            return new ObjectUpdatePacket(header, bytes, ref i);
                        case 14:
                            return new ObjectUpdateCompressedPacket(header, bytes, ref i);
                        case 15:
                            return new ObjectUpdateCachedPacket(header, bytes, ref i);
                        case 16:
                            return new ImprovedTerseObjectUpdatePacket(header, bytes, ref i);
                        case 17:
                            return new KillObjectPacket(header, bytes, ref i);
                        case 18:
                            return new AgentToNewRegionPacket(header, bytes, ref i);
                        case 19:
                            return new TransferPacketPacket(header, bytes, ref i);
                        case 20:
                            return new SendXferPacketPacket(header, bytes, ref i);
                        case 21:
                            return new ConfirmXferPacketPacket(header, bytes, ref i);
                        case 22:
                            return new AvatarAnimationPacket(header, bytes, ref i);
                        case 23:
                            return new AvatarSitResponsePacket(header, bytes, ref i);
                        case 24:
                            return new CameraConstraintPacket(header, bytes, ref i);
                        case 25:
                            return new ParcelPropertiesPacket(header, bytes, ref i);
                        case 26:
                            return new EdgeDataPacketPacket(header, bytes, ref i);
                        case 27:
                            return new ChildAgentUpdatePacket(header, bytes, ref i);
                        case 28:
                            return new ChildAgentAlivePacket(header, bytes, ref i);
                        case 29:
                            return new ChildAgentPositionUpdatePacket(header, bytes, ref i);
                        case 30:
                            return new PassObjectPacket(header, bytes, ref i);
                        case 31:
                            return new AtomicPassObjectPacket(header, bytes, ref i);
                        case 32:
                            return new SoundTriggerPacket(header, bytes, ref i);
                }
            }

            throw new MalformedDataException("Unknown packet ID");
        }
    }

    /// <summary>TestMessage packet</summary>
    public class TestMessagePacket : Packet
    {
        /// <summary>TestBlock1 block</summary>
        public class TestBlock1Block
        {
            /// <summary>Test1 field</summary>
            public uint Test1;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TestBlock1Block() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TestBlock1Block(byte[] bytes, ref int i)
            {
                try
                {
                    Test1 = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Test1 % 256);
                bytes[i++] = (byte)((Test1 >> 8) % 256);
                bytes[i++] = (byte)((Test1 >> 16) % 256);
                bytes[i++] = (byte)((Test1 >> 24) % 256);
            }
        }

        /// <summary>NeighborBlock block</summary>
        public class NeighborBlockBlock
        {
            /// <summary>Test0 field</summary>
            public uint Test0;
            /// <summary>Test1 field</summary>
            public uint Test1;
            /// <summary>Test2 field</summary>
            public uint Test2;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NeighborBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NeighborBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Test0 = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Test1 = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Test2 = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Test0 % 256);
                bytes[i++] = (byte)((Test0 >> 8) % 256);
                bytes[i++] = (byte)((Test0 >> 16) % 256);
                bytes[i++] = (byte)((Test0 >> 24) % 256);
                bytes[i++] = (byte)(Test1 % 256);
                bytes[i++] = (byte)((Test1 >> 8) % 256);
                bytes[i++] = (byte)((Test1 >> 16) % 256);
                bytes[i++] = (byte)((Test1 >> 24) % 256);
                bytes[i++] = (byte)(Test2 % 256);
                bytes[i++] = (byte)((Test2 >> 8) % 256);
                bytes[i++] = (byte)((Test2 >> 16) % 256);
                bytes[i++] = (byte)((Test2 >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TestMessage</summary>
        public override PacketType Type { get { return PacketType.TestMessage; } }
        /// <summary>TestBlock1 block</summary>
        public TestBlock1Block TestBlock1;
        /// <summary>NeighborBlock block</summary>
        public NeighborBlockBlock[] NeighborBlock;

        /// <summary>Default constructor</summary>
        public TestMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 1;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TestBlock1 = new TestBlock1Block();
            NeighborBlock = new NeighborBlockBlock[4];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TestMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TestBlock1 = new TestBlock1Block(bytes, ref i);
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TestMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TestBlock1 = new TestBlock1Block(bytes, ref i);
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TestBlock1.Length;;
            for (int j = 0; j < 4; j++) { length += NeighborBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TestBlock1.ToBytes(bytes, ref i);
            for (int j = 0; j < 4; j++) { NeighborBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AddCircuitCode packet</summary>
    public class AddCircuitCodePacket : Packet
    {
        /// <summary>CircuitCode block</summary>
        public class CircuitCodeBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Code field</summary>
            public uint Code;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public CircuitCodeBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public CircuitCodeBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    Code = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Code % 256);
                bytes[i++] = (byte)((Code >> 8) % 256);
                bytes[i++] = (byte)((Code >> 16) % 256);
                bytes[i++] = (byte)((Code >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AddCircuitCode</summary>
        public override PacketType Type { get { return PacketType.AddCircuitCode; } }
        /// <summary>CircuitCode block</summary>
        public CircuitCodeBlock CircuitCode;

        /// <summary>Default constructor</summary>
        public AddCircuitCodePacket()
        {
            Header = new LowHeader();
            Header.ID = 2;
            Header.Reliable = true;
            CircuitCode = new CircuitCodeBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AddCircuitCodePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            CircuitCode = new CircuitCodeBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AddCircuitCodePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            CircuitCode = new CircuitCodeBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += CircuitCode.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            CircuitCode.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UseCircuitCode packet</summary>
    public class UseCircuitCodePacket : Packet
    {
        /// <summary>CircuitCode block</summary>
        public class CircuitCodeBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Code field</summary>
            public uint Code;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public CircuitCodeBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public CircuitCodeBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    Code = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Code % 256);
                bytes[i++] = (byte)((Code >> 8) % 256);
                bytes[i++] = (byte)((Code >> 16) % 256);
                bytes[i++] = (byte)((Code >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UseCircuitCode</summary>
        public override PacketType Type { get { return PacketType.UseCircuitCode; } }
        /// <summary>CircuitCode block</summary>
        public CircuitCodeBlock CircuitCode;

        /// <summary>Default constructor</summary>
        public UseCircuitCodePacket()
        {
            Header = new LowHeader();
            Header.ID = 3;
            Header.Reliable = true;
            CircuitCode = new CircuitCodeBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UseCircuitCodePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            CircuitCode = new CircuitCodeBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UseCircuitCodePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            CircuitCode = new CircuitCodeBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += CircuitCode.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            CircuitCode.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogControl packet</summary>
    public class LogControlPacket : Packet
    {
        /// <summary>Options block</summary>
        public class OptionsBlock
        {
            /// <summary>Mask field</summary>
            public uint Mask;
            /// <summary>Time field</summary>
            public bool Time;
            /// <summary>RemoteInfos field</summary>
            public bool RemoteInfos;
            /// <summary>Location field</summary>
            public bool Location;
            /// <summary>Level field</summary>
            public byte Level;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public OptionsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public OptionsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Mask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Time = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RemoteInfos = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Location = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Level = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Mask % 256);
                bytes[i++] = (byte)((Mask >> 8) % 256);
                bytes[i++] = (byte)((Mask >> 16) % 256);
                bytes[i++] = (byte)((Mask >> 24) % 256);
                bytes[i++] = (byte)((Time) ? 1 : 0);
                bytes[i++] = (byte)((RemoteInfos) ? 1 : 0);
                bytes[i++] = (byte)((Location) ? 1 : 0);
                bytes[i++] = Level;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogControl</summary>
        public override PacketType Type { get { return PacketType.LogControl; } }
        /// <summary>Options block</summary>
        public OptionsBlock Options;

        /// <summary>Default constructor</summary>
        public LogControlPacket()
        {
            Header = new LowHeader();
            Header.ID = 4;
            Header.Reliable = true;
            Options = new OptionsBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogControlPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Options = new OptionsBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogControlPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Options = new OptionsBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Options.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Options.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RelayLogControl packet</summary>
    public class RelayLogControlPacket : Packet
    {
        /// <summary>Options block</summary>
        public class OptionsBlock
        {
            /// <summary>Mask field</summary>
            public uint Mask;
            /// <summary>Time field</summary>
            public bool Time;
            /// <summary>RemoteInfos field</summary>
            public bool RemoteInfos;
            /// <summary>Location field</summary>
            public bool Location;
            /// <summary>Level field</summary>
            public byte Level;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public OptionsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public OptionsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Mask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Time = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RemoteInfos = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Location = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Level = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Mask % 256);
                bytes[i++] = (byte)((Mask >> 8) % 256);
                bytes[i++] = (byte)((Mask >> 16) % 256);
                bytes[i++] = (byte)((Mask >> 24) % 256);
                bytes[i++] = (byte)((Time) ? 1 : 0);
                bytes[i++] = (byte)((RemoteInfos) ? 1 : 0);
                bytes[i++] = (byte)((Location) ? 1 : 0);
                bytes[i++] = Level;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RelayLogControl</summary>
        public override PacketType Type { get { return PacketType.RelayLogControl; } }
        /// <summary>Options block</summary>
        public OptionsBlock Options;

        /// <summary>Default constructor</summary>
        public RelayLogControlPacket()
        {
            Header = new LowHeader();
            Header.ID = 5;
            Header.Reliable = true;
            Options = new OptionsBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RelayLogControlPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Options = new OptionsBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RelayLogControlPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Options = new OptionsBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Options.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Options.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogMessages packet</summary>
    public class LogMessagesPacket : Packet
    {
        /// <summary>Options block</summary>
        public class OptionsBlock
        {
            /// <summary>Enable field</summary>
            public bool Enable;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public OptionsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public OptionsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Enable = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Enable) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogMessages</summary>
        public override PacketType Type { get { return PacketType.LogMessages; } }
        /// <summary>Options block</summary>
        public OptionsBlock Options;

        /// <summary>Default constructor</summary>
        public LogMessagesPacket()
        {
            Header = new LowHeader();
            Header.ID = 6;
            Header.Reliable = true;
            Options = new OptionsBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogMessagesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Options = new OptionsBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogMessagesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Options = new OptionsBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Options.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Options.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorAssign packet</summary>
    public class SimulatorAssignPacket : Packet
    {
        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>SecPerDay field</summary>
            public uint SecPerDay;
            /// <summary>MetersPerGrid field</summary>
            public float MetersPerGrid;
            /// <summary>UsecSinceStart field</summary>
            public ulong UsecSinceStart;
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>SecPerYear field</summary>
            public uint SecPerYear;
            /// <summary>GridsPerEdge field</summary>
            public int GridsPerEdge;
            /// <summary>Handle field</summary>
            public ulong Handle;
            /// <summary>SunAngVelocity field</summary>
            public LLVector3 SunAngVelocity;
            /// <summary>SunDirection field</summary>
            public LLVector3 SunDirection;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 62;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SecPerDay = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    MetersPerGrid = BitConverter.ToSingle(bytes, i); i += 4;
                    UsecSinceStart = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    SecPerYear = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridsPerEdge = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Handle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SunAngVelocity = new LLVector3(bytes, i); i += 12;
                    SunDirection = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(SecPerDay % 256);
                bytes[i++] = (byte)((SecPerDay >> 8) % 256);
                bytes[i++] = (byte)((SecPerDay >> 16) % 256);
                bytes[i++] = (byte)((SecPerDay >> 24) % 256);
                ba = BitConverter.GetBytes(MetersPerGrid);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(UsecSinceStart % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 8) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 16) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 24) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 32) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 40) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 48) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 56) % 256);
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = (byte)(SecPerYear % 256);
                bytes[i++] = (byte)((SecPerYear >> 8) % 256);
                bytes[i++] = (byte)((SecPerYear >> 16) % 256);
                bytes[i++] = (byte)((SecPerYear >> 24) % 256);
                bytes[i++] = (byte)(GridsPerEdge % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 8) % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 16) % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 24) % 256);
                bytes[i++] = (byte)(Handle % 256);
                bytes[i++] = (byte)((Handle >> 8) % 256);
                bytes[i++] = (byte)((Handle >> 16) % 256);
                bytes[i++] = (byte)((Handle >> 24) % 256);
                bytes[i++] = (byte)((Handle >> 32) % 256);
                bytes[i++] = (byte)((Handle >> 40) % 256);
                bytes[i++] = (byte)((Handle >> 48) % 256);
                bytes[i++] = (byte)((Handle >> 56) % 256);
                Array.Copy(SunAngVelocity.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(SunDirection.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>NeighborBlock block</summary>
        public class NeighborBlockBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>PublicPort field</summary>
            public ushort PublicPort;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>PublicIP field</summary>
            public uint PublicIP;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 13;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NeighborBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NeighborBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PublicPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    SimAccess = (byte)bytes[i++];
                    PublicIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(PublicPort % 256);
                bytes[i++] = (byte)((PublicPort >> 8) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = SimAccess;
                bytes[i++] = (byte)(PublicIP % 256);
                bytes[i++] = (byte)((PublicIP >> 8) % 256);
                bytes[i++] = (byte)((PublicIP >> 16) % 256);
                bytes[i++] = (byte)((PublicIP >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorAssign</summary>
        public override PacketType Type { get { return PacketType.SimulatorAssign; } }
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;
        /// <summary>NeighborBlock block</summary>
        public NeighborBlockBlock[] NeighborBlock;

        /// <summary>Default constructor</summary>
        public SimulatorAssignPacket()
        {
            Header = new LowHeader();
            Header.ID = 7;
            Header.Reliable = true;
            Header.Zerocoded = true;
            RegionInfo = new RegionInfoBlock();
            NeighborBlock = new NeighborBlockBlock[4];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorAssignPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorAssignPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionInfo.Length;;
            for (int j = 0; j < 4; j++) { length += NeighborBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            for (int j = 0; j < 4; j++) { NeighborBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SpaceServerSimulatorTimeMessage packet</summary>
    public class SpaceServerSimulatorTimeMessagePacket : Packet
    {
        /// <summary>TimeInfo block</summary>
        public class TimeInfoBlock
        {
            /// <summary>SecPerDay field</summary>
            public uint SecPerDay;
            /// <summary>UsecSinceStart field</summary>
            public ulong UsecSinceStart;
            /// <summary>SecPerYear field</summary>
            public uint SecPerYear;
            /// <summary>SunAngVelocity field</summary>
            public LLVector3 SunAngVelocity;
            /// <summary>SunPhase field</summary>
            public float SunPhase;
            /// <summary>SunDirection field</summary>
            public LLVector3 SunDirection;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TimeInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TimeInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SecPerDay = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    UsecSinceStart = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SecPerYear = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SunAngVelocity = new LLVector3(bytes, i); i += 12;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    SunPhase = BitConverter.ToSingle(bytes, i); i += 4;
                    SunDirection = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(SecPerDay % 256);
                bytes[i++] = (byte)((SecPerDay >> 8) % 256);
                bytes[i++] = (byte)((SecPerDay >> 16) % 256);
                bytes[i++] = (byte)((SecPerDay >> 24) % 256);
                bytes[i++] = (byte)(UsecSinceStart % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 8) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 16) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 24) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 32) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 40) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 48) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 56) % 256);
                bytes[i++] = (byte)(SecPerYear % 256);
                bytes[i++] = (byte)((SecPerYear >> 8) % 256);
                bytes[i++] = (byte)((SecPerYear >> 16) % 256);
                bytes[i++] = (byte)((SecPerYear >> 24) % 256);
                Array.Copy(SunAngVelocity.GetBytes(), 0, bytes, i, 12); i += 12;
                ba = BitConverter.GetBytes(SunPhase);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(SunDirection.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SpaceServerSimulatorTimeMessage</summary>
        public override PacketType Type { get { return PacketType.SpaceServerSimulatorTimeMessage; } }
        /// <summary>TimeInfo block</summary>
        public TimeInfoBlock TimeInfo;

        /// <summary>Default constructor</summary>
        public SpaceServerSimulatorTimeMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 8;
            Header.Reliable = true;
            TimeInfo = new TimeInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SpaceServerSimulatorTimeMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TimeInfo = new TimeInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SpaceServerSimulatorTimeMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TimeInfo = new TimeInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TimeInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TimeInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarTextureUpdate packet</summary>
    public class AvatarTextureUpdatePacket : Packet
    {
        /// <summary>WearableData block</summary>
        public class WearableDataBlock
        {
            /// <summary>TextureIndex field</summary>
            public byte TextureIndex;
            /// <summary>CacheID field</summary>
            public LLUUID CacheID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public WearableDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public WearableDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TextureIndex = (byte)bytes[i++];
                    CacheID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = TextureIndex;
                Array.Copy(CacheID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TextureData block</summary>
        public class TextureDataBlock
        {
            /// <summary>TextureID field</summary>
            public LLUUID TextureID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TextureDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TextureDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TextureID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TextureID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>TexturesChanged field</summary>
            public bool TexturesChanged;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _hostname;
            /// <summary>HostName field</summary>
            public byte[] HostName
            {
                get { return _hostname; }
                set
                {
                    if (value == null) { _hostname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _hostname = new byte[value.Length]; Array.Copy(value, _hostname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (HostName != null) { length += 1 + HostName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    TexturesChanged = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _hostname = new byte[length];
                    Array.Copy(bytes, i, _hostname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((TexturesChanged) ? 1 : 0);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)HostName.Length;
                Array.Copy(HostName, 0, bytes, i, HostName.Length); i += HostName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarTextureUpdate</summary>
        public override PacketType Type { get { return PacketType.AvatarTextureUpdate; } }
        /// <summary>WearableData block</summary>
        public WearableDataBlock[] WearableData;
        /// <summary>TextureData block</summary>
        public TextureDataBlock[] TextureData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarTextureUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 9;
            Header.Reliable = true;
            Header.Zerocoded = true;
            WearableData = new WearableDataBlock[0];
            TextureData = new TextureDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarTextureUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            count = (int)bytes[i++];
            TextureData = new TextureDataBlock[count];
            for (int j = 0; j < count; j++)
            { TextureData[j] = new TextureDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarTextureUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            count = (int)bytes[i++];
            TextureData = new TextureDataBlock[count];
            for (int j = 0; j < count; j++)
            { TextureData[j] = new TextureDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < WearableData.Length; j++) { length += WearableData[j].Length; }
            for (int j = 0; j < TextureData.Length; j++) { length += TextureData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)WearableData.Length;
            for (int j = 0; j < WearableData.Length; j++) { WearableData[j].ToBytes(bytes, ref i); }
            bytes[i++] = (byte)TextureData.Length;
            for (int j = 0; j < TextureData.Length; j++) { TextureData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorMapUpdate packet</summary>
    public class SimulatorMapUpdatePacket : Packet
    {
        /// <summary>MapData block</summary>
        public class MapDataBlock
        {
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MapDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MapDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorMapUpdate</summary>
        public override PacketType Type { get { return PacketType.SimulatorMapUpdate; } }
        /// <summary>MapData block</summary>
        public MapDataBlock MapData;

        /// <summary>Default constructor</summary>
        public SimulatorMapUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 10;
            Header.Reliable = true;
            MapData = new MapDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorMapUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MapData = new MapDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorMapUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MapData = new MapDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MapData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MapData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorSetMap packet</summary>
    public class SimulatorSetMapPacket : Packet
    {
        /// <summary>MapData block</summary>
        public class MapDataBlock
        {
            /// <summary>MapImage field</summary>
            public LLUUID MapImage;
            /// <summary>Type field</summary>
            public int Type;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MapDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MapDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    MapImage = new LLUUID(bytes, i); i += 16;
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(MapImage.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorSetMap</summary>
        public override PacketType Type { get { return PacketType.SimulatorSetMap; } }
        /// <summary>MapData block</summary>
        public MapDataBlock MapData;

        /// <summary>Default constructor</summary>
        public SimulatorSetMapPacket()
        {
            Header = new LowHeader();
            Header.ID = 11;
            Header.Reliable = true;
            MapData = new MapDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorSetMapPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MapData = new MapDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorSetMapPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MapData = new MapDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MapData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MapData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SubscribeLoad packet</summary>
    public class SubscribeLoadPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SubscribeLoad</summary>
        public override PacketType Type { get { return PacketType.SubscribeLoad; } }

        /// <summary>Default constructor</summary>
        public SubscribeLoadPacket()
        {
            Header = new LowHeader();
            Header.ID = 12;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SubscribeLoadPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SubscribeLoadPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UnsubscribeLoad packet</summary>
    public class UnsubscribeLoadPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UnsubscribeLoad</summary>
        public override PacketType Type { get { return PacketType.UnsubscribeLoad; } }

        /// <summary>Default constructor</summary>
        public UnsubscribeLoadPacket()
        {
            Header = new LowHeader();
            Header.ID = 13;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UnsubscribeLoadPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UnsubscribeLoadPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorStart packet</summary>
    public class SimulatorStartPacket : Packet
    {
        /// <summary>PositionSuggestion block</summary>
        public class PositionSuggestionBlock
        {
            /// <summary>Ignore field</summary>
            public bool Ignore;
            /// <summary>GridX field</summary>
            public int GridX;
            /// <summary>GridY field</summary>
            public int GridY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PositionSuggestionBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PositionSuggestionBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Ignore = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GridX = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridY = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Ignore) ? 1 : 0);
                bytes[i++] = (byte)(GridX % 256);
                bytes[i++] = (byte)((GridX >> 8) % 256);
                bytes[i++] = (byte)((GridX >> 16) % 256);
                bytes[i++] = (byte)((GridX >> 24) % 256);
                bytes[i++] = (byte)(GridY % 256);
                bytes[i++] = (byte)((GridY >> 8) % 256);
                bytes[i++] = (byte)((GridY >> 16) % 256);
                bytes[i++] = (byte)((GridY >> 24) % 256);
            }
        }

        /// <summary>ControlPort block</summary>
        public class ControlPortBlock
        {
            /// <summary>PublicPort field</summary>
            public ushort PublicPort;
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>PublicIP field</summary>
            public uint PublicIP;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ControlPortBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ControlPortBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PublicPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    PublicIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(PublicPort % 256);
                bytes[i++] = (byte)((PublicPort >> 8) % 256);
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = (byte)(PublicIP % 256);
                bytes[i++] = (byte)((PublicIP >> 8) % 256);
                bytes[i++] = (byte)((PublicIP >> 16) % 256);
                bytes[i++] = (byte)((PublicIP >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorStart</summary>
        public override PacketType Type { get { return PacketType.SimulatorStart; } }
        /// <summary>PositionSuggestion block</summary>
        public PositionSuggestionBlock PositionSuggestion;
        /// <summary>ControlPort block</summary>
        public ControlPortBlock ControlPort;

        /// <summary>Default constructor</summary>
        public SimulatorStartPacket()
        {
            Header = new LowHeader();
            Header.ID = 14;
            Header.Reliable = true;
            PositionSuggestion = new PositionSuggestionBlock();
            ControlPort = new ControlPortBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorStartPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PositionSuggestion = new PositionSuggestionBlock(bytes, ref i);
            ControlPort = new ControlPortBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorStartPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PositionSuggestion = new PositionSuggestionBlock(bytes, ref i);
            ControlPort = new ControlPortBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PositionSuggestion.Length;            length += ControlPort.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PositionSuggestion.ToBytes(bytes, ref i);
            ControlPort.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorReady packet</summary>
    public class SimulatorReadyPacket : Packet
    {
        /// <summary>TelehubBlock block</summary>
        public class TelehubBlockBlock
        {
            /// <summary>HasTelehub field</summary>
            public bool HasTelehub;
            /// <summary>TelehubPos field</summary>
            public LLVector3 TelehubPos;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 13;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TelehubBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TelehubBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    HasTelehub = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    TelehubPos = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((HasTelehub) ? 1 : 0);
                Array.Copy(TelehubPos.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>SimulatorBlock block</summary>
        public class SimulatorBlockBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>RegionFlags field</summary>
            public uint RegionFlags;
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>ParentEstateID field</summary>
            public uint ParentEstateID;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    RegionFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionID = new LLUUID(bytes, i); i += 16;
                    SimAccess = (byte)bytes[i++];
                    ParentEstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)(RegionFlags % 256);
                bytes[i++] = (byte)((RegionFlags >> 8) % 256);
                bytes[i++] = (byte)((RegionFlags >> 16) % 256);
                bytes[i++] = (byte)((RegionFlags >> 24) % 256);
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SimAccess;
                bytes[i++] = (byte)(ParentEstateID % 256);
                bytes[i++] = (byte)((ParentEstateID >> 8) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 16) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorReady</summary>
        public override PacketType Type { get { return PacketType.SimulatorReady; } }
        /// <summary>TelehubBlock block</summary>
        public TelehubBlockBlock TelehubBlock;
        /// <summary>SimulatorBlock block</summary>
        public SimulatorBlockBlock SimulatorBlock;

        /// <summary>Default constructor</summary>
        public SimulatorReadyPacket()
        {
            Header = new LowHeader();
            Header.ID = 15;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TelehubBlock = new TelehubBlockBlock();
            SimulatorBlock = new SimulatorBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorReadyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TelehubBlock = new TelehubBlockBlock(bytes, ref i);
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorReadyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TelehubBlock = new TelehubBlockBlock(bytes, ref i);
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TelehubBlock.Length;            length += SimulatorBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TelehubBlock.ToBytes(bytes, ref i);
            SimulatorBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TelehubInfo packet</summary>
    public class TelehubInfoPacket : Packet
    {
        /// <summary>TelehubBlock block</summary>
        public class TelehubBlockBlock
        {
            private byte[] _objectname;
            /// <summary>ObjectName field</summary>
            public byte[] ObjectName
            {
                get { return _objectname; }
                set
                {
                    if (value == null) { _objectname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectname = new byte[value.Length]; Array.Copy(value, _objectname, value.Length); }
                }
            }
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>TelehubPos field</summary>
            public LLVector3 TelehubPos;
            /// <summary>TelehubRot field</summary>
            public LLQuaternion TelehubRot;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    if (ObjectName != null) { length += 1 + ObjectName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TelehubBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TelehubBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _objectname = new byte[length];
                    Array.Copy(bytes, i, _objectname, 0, length); i += length;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    TelehubPos = new LLVector3(bytes, i); i += 12;
                    TelehubRot = new LLQuaternion(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)ObjectName.Length;
                Array.Copy(ObjectName, 0, bytes, i, ObjectName.Length); i += ObjectName.Length;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TelehubPos.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(TelehubRot.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>SpawnPointBlock block</summary>
        public class SpawnPointBlockBlock
        {
            /// <summary>SpawnPointPos field</summary>
            public LLVector3 SpawnPointPos;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 13;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SpawnPointBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SpawnPointBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SpawnPointPos = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(SpawnPointPos.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TelehubInfo</summary>
        public override PacketType Type { get { return PacketType.TelehubInfo; } }
        /// <summary>TelehubBlock block</summary>
        public TelehubBlockBlock TelehubBlock;
        /// <summary>SpawnPointBlock block</summary>
        public SpawnPointBlockBlock[] SpawnPointBlock;

        /// <summary>Default constructor</summary>
        public TelehubInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 16;
            Header.Reliable = true;
            TelehubBlock = new TelehubBlockBlock();
            SpawnPointBlock = new SpawnPointBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TelehubInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TelehubBlock = new TelehubBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            SpawnPointBlock = new SpawnPointBlockBlock[count];
            for (int j = 0; j < count; j++)
            { SpawnPointBlock[j] = new SpawnPointBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TelehubInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TelehubBlock = new TelehubBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            SpawnPointBlock = new SpawnPointBlockBlock[count];
            for (int j = 0; j < count; j++)
            { SpawnPointBlock[j] = new SpawnPointBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TelehubBlock.Length;;
            for (int j = 0; j < SpawnPointBlock.Length; j++) { length += SpawnPointBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TelehubBlock.ToBytes(bytes, ref i);
            bytes[i++] = (byte)SpawnPointBlock.Length;
            for (int j = 0; j < SpawnPointBlock.Length; j++) { SpawnPointBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorPresentAtLocation packet</summary>
    public class SimulatorPresentAtLocationPacket : Packet
    {
        /// <summary>TelehubBlock block</summary>
        public class TelehubBlockBlock
        {
            /// <summary>HasTelehub field</summary>
            public bool HasTelehub;
            /// <summary>TelehubPos field</summary>
            public LLVector3 TelehubPos;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 14;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TelehubBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TelehubBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    HasTelehub = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    TelehubPos = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((HasTelehub) ? 1 : 0);
                Array.Copy(TelehubPos.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>SimulatorBlock block</summary>
        public class SimulatorBlockBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>RegionFlags field</summary>
            public uint RegionFlags;
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>ParentEstateID field</summary>
            public uint ParentEstateID;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    RegionFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionID = new LLUUID(bytes, i); i += 16;
                    SimAccess = (byte)bytes[i++];
                    ParentEstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)(RegionFlags % 256);
                bytes[i++] = (byte)((RegionFlags >> 8) % 256);
                bytes[i++] = (byte)((RegionFlags >> 16) % 256);
                bytes[i++] = (byte)((RegionFlags >> 24) % 256);
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SimAccess;
                bytes[i++] = (byte)(ParentEstateID % 256);
                bytes[i++] = (byte)((ParentEstateID >> 8) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 16) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>SimulatorPublicHostBlock block</summary>
        public class SimulatorPublicHostBlockBlock
        {
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>SimulatorIP field</summary>
            public uint SimulatorIP;
            /// <summary>GridX field</summary>
            public uint GridX;
            /// <summary>GridY field</summary>
            public uint GridY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 14;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorPublicHostBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorPublicHostBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    SimulatorIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = (byte)(SimulatorIP % 256);
                bytes[i++] = (byte)((SimulatorIP >> 8) % 256);
                bytes[i++] = (byte)((SimulatorIP >> 16) % 256);
                bytes[i++] = (byte)((SimulatorIP >> 24) % 256);
                bytes[i++] = (byte)(GridX % 256);
                bytes[i++] = (byte)((GridX >> 8) % 256);
                bytes[i++] = (byte)((GridX >> 16) % 256);
                bytes[i++] = (byte)((GridX >> 24) % 256);
                bytes[i++] = (byte)(GridY % 256);
                bytes[i++] = (byte)((GridY >> 8) % 256);
                bytes[i++] = (byte)((GridY >> 16) % 256);
                bytes[i++] = (byte)((GridY >> 24) % 256);
            }
        }

        /// <summary>NeighborBlock block</summary>
        public class NeighborBlockBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>Port field</summary>
            public ushort Port;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NeighborBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NeighborBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorPresentAtLocation</summary>
        public override PacketType Type { get { return PacketType.SimulatorPresentAtLocation; } }
        /// <summary>TelehubBlock block</summary>
        public TelehubBlockBlock[] TelehubBlock;
        /// <summary>SimulatorBlock block</summary>
        public SimulatorBlockBlock SimulatorBlock;
        /// <summary>SimulatorPublicHostBlock block</summary>
        public SimulatorPublicHostBlockBlock SimulatorPublicHostBlock;
        /// <summary>NeighborBlock block</summary>
        public NeighborBlockBlock[] NeighborBlock;

        /// <summary>Default constructor</summary>
        public SimulatorPresentAtLocationPacket()
        {
            Header = new LowHeader();
            Header.ID = 17;
            Header.Reliable = true;
            TelehubBlock = new TelehubBlockBlock[0];
            SimulatorBlock = new SimulatorBlockBlock();
            SimulatorPublicHostBlock = new SimulatorPublicHostBlockBlock();
            NeighborBlock = new NeighborBlockBlock[4];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorPresentAtLocationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            TelehubBlock = new TelehubBlockBlock[count];
            for (int j = 0; j < count; j++)
            { TelehubBlock[j] = new TelehubBlockBlock(bytes, ref i); }
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            SimulatorPublicHostBlock = new SimulatorPublicHostBlockBlock(bytes, ref i);
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorPresentAtLocationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            TelehubBlock = new TelehubBlockBlock[count];
            for (int j = 0; j < count; j++)
            { TelehubBlock[j] = new TelehubBlockBlock(bytes, ref i); }
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            SimulatorPublicHostBlock = new SimulatorPublicHostBlockBlock(bytes, ref i);
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SimulatorBlock.Length;            length += SimulatorPublicHostBlock.Length;;
            for (int j = 0; j < TelehubBlock.Length; j++) { length += TelehubBlock[j].Length; }
            for (int j = 0; j < 4; j++) { length += NeighborBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)TelehubBlock.Length;
            for (int j = 0; j < TelehubBlock.Length; j++) { TelehubBlock[j].ToBytes(bytes, ref i); }
            SimulatorBlock.ToBytes(bytes, ref i);
            SimulatorPublicHostBlock.ToBytes(bytes, ref i);
            for (int j = 0; j < 4; j++) { NeighborBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorLoad packet</summary>
    public class SimulatorLoadPacket : Packet
    {
        /// <summary>SimulatorLoad block</summary>
        public class SimulatorLoadBlock
        {
            /// <summary>CanAcceptAgents field</summary>
            public bool CanAcceptAgents;
            /// <summary>TimeDilation field</summary>
            public float TimeDilation;
            /// <summary>AgentCount field</summary>
            public int AgentCount;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorLoadBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorLoadBlock(byte[] bytes, ref int i)
            {
                try
                {
                    CanAcceptAgents = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TimeDilation = BitConverter.ToSingle(bytes, i); i += 4;
                    AgentCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)((CanAcceptAgents) ? 1 : 0);
                ba = BitConverter.GetBytes(TimeDilation);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(AgentCount % 256);
                bytes[i++] = (byte)((AgentCount >> 8) % 256);
                bytes[i++] = (byte)((AgentCount >> 16) % 256);
                bytes[i++] = (byte)((AgentCount >> 24) % 256);
            }
        }

        /// <summary>AgentList block</summary>
        public class AgentListBlock
        {
            /// <summary>X field</summary>
            public byte X;
            /// <summary>Y field</summary>
            public byte Y;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 7;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentListBlock(byte[] bytes, ref int i)
            {
                try
                {
                    X = (byte)bytes[i++];
                    Y = (byte)bytes[i++];
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = X;
                bytes[i++] = Y;
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorLoad</summary>
        public override PacketType Type { get { return PacketType.SimulatorLoad; } }
        /// <summary>SimulatorLoad block</summary>
        public SimulatorLoadBlock SimulatorLoad;
        /// <summary>AgentList block</summary>
        public AgentListBlock[] AgentList;

        /// <summary>Default constructor</summary>
        public SimulatorLoadPacket()
        {
            Header = new LowHeader();
            Header.ID = 18;
            Header.Reliable = true;
            SimulatorLoad = new SimulatorLoadBlock();
            AgentList = new AgentListBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorLoadPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            SimulatorLoad = new SimulatorLoadBlock(bytes, ref i);
            int count = (int)bytes[i++];
            AgentList = new AgentListBlock[count];
            for (int j = 0; j < count; j++)
            { AgentList[j] = new AgentListBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorLoadPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimulatorLoad = new SimulatorLoadBlock(bytes, ref i);
            int count = (int)bytes[i++];
            AgentList = new AgentListBlock[count];
            for (int j = 0; j < count; j++)
            { AgentList[j] = new AgentListBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SimulatorLoad.Length;;
            for (int j = 0; j < AgentList.Length; j++) { length += AgentList[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimulatorLoad.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentList.Length;
            for (int j = 0; j < AgentList.Length; j++) { AgentList[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorShutdownRequest packet</summary>
    public class SimulatorShutdownRequestPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorShutdownRequest</summary>
        public override PacketType Type { get { return PacketType.SimulatorShutdownRequest; } }

        /// <summary>Default constructor</summary>
        public SimulatorShutdownRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 19;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorShutdownRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorShutdownRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionPresenceRequestByRegionID packet</summary>
    public class RegionPresenceRequestByRegionIDPacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionPresenceRequestByRegionID</summary>
        public override PacketType Type { get { return PacketType.RegionPresenceRequestByRegionID; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock[] RegionData;

        /// <summary>Default constructor</summary>
        public RegionPresenceRequestByRegionIDPacket()
        {
            Header = new LowHeader();
            Header.ID = 20;
            Header.Reliable = true;
            RegionData = new RegionDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionPresenceRequestByRegionIDPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionPresenceRequestByRegionIDPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < RegionData.Length; j++) { length += RegionData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RegionData.Length;
            for (int j = 0; j < RegionData.Length; j++) { RegionData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionPresenceRequestByHandle packet</summary>
    public class RegionPresenceRequestByHandlePacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionPresenceRequestByHandle</summary>
        public override PacketType Type { get { return PacketType.RegionPresenceRequestByHandle; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock[] RegionData;

        /// <summary>Default constructor</summary>
        public RegionPresenceRequestByHandlePacket()
        {
            Header = new LowHeader();
            Header.ID = 21;
            Header.Reliable = true;
            RegionData = new RegionDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionPresenceRequestByHandlePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionPresenceRequestByHandlePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < RegionData.Length; j++) { length += RegionData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RegionData.Length;
            for (int j = 0; j < RegionData.Length; j++) { RegionData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionPresenceResponse packet</summary>
    public class RegionPresenceResponsePacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>ValidUntil field</summary>
            public double ValidUntil;
            /// <summary>InternalRegionIP field</summary>
            public uint InternalRegionIP;
            /// <summary>ExternalRegionIP field</summary>
            public uint ExternalRegionIP;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>RegionPort field</summary>
            public ushort RegionPort;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 43;
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    ValidUntil = BitConverter.ToDouble(bytes, i); i += 8;
                    InternalRegionIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ExternalRegionIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    RegionID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    RegionPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(ValidUntil);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                bytes[i++] = (byte)(InternalRegionIP % 256);
                bytes[i++] = (byte)((InternalRegionIP >> 8) % 256);
                bytes[i++] = (byte)((InternalRegionIP >> 16) % 256);
                bytes[i++] = (byte)((InternalRegionIP >> 24) % 256);
                bytes[i++] = (byte)(ExternalRegionIP % 256);
                bytes[i++] = (byte)((ExternalRegionIP >> 8) % 256);
                bytes[i++] = (byte)((ExternalRegionIP >> 16) % 256);
                bytes[i++] = (byte)((ExternalRegionIP >> 24) % 256);
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(RegionPort % 256);
                bytes[i++] = (byte)((RegionPort >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionPresenceResponse</summary>
        public override PacketType Type { get { return PacketType.RegionPresenceResponse; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock[] RegionData;

        /// <summary>Default constructor</summary>
        public RegionPresenceResponsePacket()
        {
            Header = new LowHeader();
            Header.ID = 22;
            Header.Reliable = true;
            Header.Zerocoded = true;
            RegionData = new RegionDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionPresenceResponsePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionPresenceResponsePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < RegionData.Length; j++) { length += RegionData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RegionData.Length;
            for (int j = 0; j < RegionData.Length; j++) { RegionData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RecordAgentPresence packet</summary>
    public class RecordAgentPresencePacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>LocalX field</summary>
            public short LocalX;
            /// <summary>LocalY field</summary>
            public short LocalY;
            /// <summary>Status field</summary>
            public int Status;
            /// <summary>SecureSessionID field</summary>
            public LLUUID SecureSessionID;
            /// <summary>EstateID field</summary>
            public uint EstateID;
            /// <summary>TimeToLive field</summary>
            public int TimeToLive;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 65;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    LocalX = (short)(bytes[i++] + (bytes[i++] << 8));
                    LocalY = (short)(bytes[i++] + (bytes[i++] << 8));
                    Status = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SecureSessionID = new LLUUID(bytes, i); i += 16;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TimeToLive = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(LocalX % 256);
                bytes[i++] = (byte)((LocalX >> 8) % 256);
                bytes[i++] = (byte)(LocalY % 256);
                bytes[i++] = (byte)((LocalY >> 8) % 256);
                bytes[i++] = (byte)(Status % 256);
                bytes[i++] = (byte)((Status >> 8) % 256);
                bytes[i++] = (byte)((Status >> 16) % 256);
                bytes[i++] = (byte)((Status >> 24) % 256);
                Array.Copy(SecureSessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
                bytes[i++] = (byte)(TimeToLive % 256);
                bytes[i++] = (byte)((TimeToLive >> 8) % 256);
                bytes[i++] = (byte)((TimeToLive >> 16) % 256);
                bytes[i++] = (byte)((TimeToLive >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RecordAgentPresence</summary>
        public override PacketType Type { get { return PacketType.RecordAgentPresence; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock[] AgentData;

        /// <summary>Default constructor</summary>
        public RecordAgentPresencePacket()
        {
            Header = new LowHeader();
            Header.ID = 23;
            Header.Reliable = true;
            RegionData = new RegionDataBlock();
            AgentData = new AgentDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RecordAgentPresencePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionData = new RegionDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RecordAgentPresencePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionData = new RegionDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionData.Length;;
            for (int j = 0; j < AgentData.Length; j++) { length += AgentData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentData.Length;
            for (int j = 0; j < AgentData.Length; j++) { AgentData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EraseAgentPresence packet</summary>
    public class EraseAgentPresencePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EraseAgentPresence</summary>
        public override PacketType Type { get { return PacketType.EraseAgentPresence; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock[] AgentData;

        /// <summary>Default constructor</summary>
        public EraseAgentPresencePacket()
        {
            Header = new LowHeader();
            Header.ID = 24;
            Header.Reliable = true;
            AgentData = new AgentDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EraseAgentPresencePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EraseAgentPresencePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentData.Length; j++) { length += AgentData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentData.Length;
            for (int j = 0; j < AgentData.Length; j++) { AgentData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentPresenceRequest packet</summary>
    public class AgentPresenceRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentPresenceRequest</summary>
        public override PacketType Type { get { return PacketType.AgentPresenceRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock[] AgentData;

        /// <summary>Default constructor</summary>
        public AgentPresenceRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 25;
            Header.Reliable = true;
            AgentData = new AgentDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentPresenceRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentPresenceRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentData.Length; j++) { length += AgentData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentData.Length;
            for (int j = 0; j < AgentData.Length; j++) { AgentData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentPresenceResponse packet</summary>
    public class AgentPresenceResponsePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ValidUntil field</summary>
            public double ValidUntil;
            /// <summary>RegionIP field</summary>
            public uint RegionIP;
            /// <summary>RegionPort field</summary>
            public ushort RegionPort;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 35;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    ValidUntil = BitConverter.ToDouble(bytes, i); i += 8;
                    RegionIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(ValidUntil);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                bytes[i++] = (byte)(RegionIP % 256);
                bytes[i++] = (byte)((RegionIP >> 8) % 256);
                bytes[i++] = (byte)((RegionIP >> 16) % 256);
                bytes[i++] = (byte)((RegionIP >> 24) % 256);
                bytes[i++] = (byte)(RegionPort % 256);
                bytes[i++] = (byte)((RegionPort >> 8) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentPresenceResponse</summary>
        public override PacketType Type { get { return PacketType.AgentPresenceResponse; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock[] AgentData;

        /// <summary>Default constructor</summary>
        public AgentPresenceResponsePacket()
        {
            Header = new LowHeader();
            Header.ID = 26;
            Header.Reliable = true;
            AgentData = new AgentDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentPresenceResponsePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentPresenceResponsePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentData = new AgentDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentData[j] = new AgentDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentData.Length; j++) { length += AgentData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentData.Length;
            for (int j = 0; j < AgentData.Length; j++) { AgentData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateSimulator packet</summary>
    public class UpdateSimulatorPacket : Packet
    {
        /// <summary>SimulatorInfo block</summary>
        public class SimulatorInfoBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    RegionID = new LLUUID(bytes, i); i += 16;
                    SimAccess = (byte)bytes[i++];
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SimAccess;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateSimulator</summary>
        public override PacketType Type { get { return PacketType.UpdateSimulator; } }
        /// <summary>SimulatorInfo block</summary>
        public SimulatorInfoBlock SimulatorInfo;

        /// <summary>Default constructor</summary>
        public UpdateSimulatorPacket()
        {
            Header = new LowHeader();
            Header.ID = 27;
            Header.Reliable = true;
            SimulatorInfo = new SimulatorInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateSimulatorPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            SimulatorInfo = new SimulatorInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateSimulatorPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimulatorInfo = new SimulatorInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SimulatorInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimulatorInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TrackAgentSession packet</summary>
    public class TrackAgentSessionPacket : Packet
    {
        /// <summary>SessionInfo block</summary>
        public class SessionInfoBlock
        {
            /// <summary>GlobalX field</summary>
            public double GlobalX;
            /// <summary>GlobalY field</summary>
            public double GlobalY;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>ViewerPort field</summary>
            public ushort ViewerPort;
            /// <summary>ViewerIP field</summary>
            public uint ViewerIP;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 39;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SessionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SessionInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    GlobalX = BitConverter.ToDouble(bytes, i); i += 8;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    GlobalY = BitConverter.ToDouble(bytes, i); i += 8;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    ViewerPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    ViewerIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(GlobalX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                ba = BitConverter.GetBytes(GlobalY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ViewerPort % 256);
                bytes[i++] = (byte)((ViewerPort >> 8) % 256);
                bytes[i++] = (byte)(ViewerIP % 256);
                bytes[i++] = (byte)((ViewerIP >> 8) % 256);
                bytes[i++] = (byte)((ViewerIP >> 16) % 256);
                bytes[i++] = (byte)((ViewerIP >> 24) % 256);
            }
        }

        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionX field</summary>
            public float RegionX;
            /// <summary>RegionY field</summary>
            public float RegionY;
            /// <summary>SpaceIP field</summary>
            public uint SpaceIP;
            /// <summary>AgentCount field</summary>
            public uint AgentCount;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    RegionX = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    RegionY = BitConverter.ToSingle(bytes, i); i += 4;
                    SpaceIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentCount = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(RegionX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(RegionY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(SpaceIP % 256);
                bytes[i++] = (byte)((SpaceIP >> 8) % 256);
                bytes[i++] = (byte)((SpaceIP >> 16) % 256);
                bytes[i++] = (byte)((SpaceIP >> 24) % 256);
                bytes[i++] = (byte)(AgentCount % 256);
                bytes[i++] = (byte)((AgentCount >> 8) % 256);
                bytes[i++] = (byte)((AgentCount >> 16) % 256);
                bytes[i++] = (byte)((AgentCount >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TrackAgentSession</summary>
        public override PacketType Type { get { return PacketType.TrackAgentSession; } }
        /// <summary>SessionInfo block</summary>
        public SessionInfoBlock[] SessionInfo;
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public TrackAgentSessionPacket()
        {
            Header = new LowHeader();
            Header.ID = 28;
            Header.Reliable = true;
            SessionInfo = new SessionInfoBlock[0];
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TrackAgentSessionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            SessionInfo = new SessionInfoBlock[count];
            for (int j = 0; j < count; j++)
            { SessionInfo[j] = new SessionInfoBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TrackAgentSessionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            SessionInfo = new SessionInfoBlock[count];
            for (int j = 0; j < count; j++)
            { SessionInfo[j] = new SessionInfoBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionData.Length;;
            for (int j = 0; j < SessionInfo.Length; j++) { length += SessionInfo[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)SessionInfo.Length;
            for (int j = 0; j < SessionInfo.Length; j++) { SessionInfo[j].ToBytes(bytes, ref i); }
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClearAgentSessions packet</summary>
    public class ClearAgentSessionsPacket : Packet
    {
        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>RegionX field</summary>
            public uint RegionX;
            /// <summary>RegionY field</summary>
            public uint RegionY;
            /// <summary>SpaceIP field</summary>
            public uint SpaceIP;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SpaceIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionX % 256);
                bytes[i++] = (byte)((RegionX >> 8) % 256);
                bytes[i++] = (byte)((RegionX >> 16) % 256);
                bytes[i++] = (byte)((RegionX >> 24) % 256);
                bytes[i++] = (byte)(RegionY % 256);
                bytes[i++] = (byte)((RegionY >> 8) % 256);
                bytes[i++] = (byte)((RegionY >> 16) % 256);
                bytes[i++] = (byte)((RegionY >> 24) % 256);
                bytes[i++] = (byte)(SpaceIP % 256);
                bytes[i++] = (byte)((SpaceIP >> 8) % 256);
                bytes[i++] = (byte)((SpaceIP >> 16) % 256);
                bytes[i++] = (byte)((SpaceIP >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClearAgentSessions</summary>
        public override PacketType Type { get { return PacketType.ClearAgentSessions; } }
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;

        /// <summary>Default constructor</summary>
        public ClearAgentSessionsPacket()
        {
            Header = new LowHeader();
            Header.ID = 29;
            Header.Reliable = true;
            RegionInfo = new RegionInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClearAgentSessionsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClearAgentSessionsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogDwellTime packet</summary>
    public class LogDwellTimePacket : Packet
    {
        /// <summary>DwellInfo block</summary>
        public class DwellInfoBlock
        {
            /// <summary>Duration field</summary>
            public float Duration;
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RegionX field</summary>
            public uint RegionX;
            /// <summary>RegionY field</summary>
            public uint RegionY;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DwellInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DwellInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Duration = BitConverter.ToSingle(bytes, i); i += 4;
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RegionX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Duration);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionX % 256);
                bytes[i++] = (byte)((RegionX >> 8) % 256);
                bytes[i++] = (byte)((RegionX >> 16) % 256);
                bytes[i++] = (byte)((RegionX >> 24) % 256);
                bytes[i++] = (byte)(RegionY % 256);
                bytes[i++] = (byte)((RegionY >> 8) % 256);
                bytes[i++] = (byte)((RegionY >> 16) % 256);
                bytes[i++] = (byte)((RegionY >> 24) % 256);
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogDwellTime</summary>
        public override PacketType Type { get { return PacketType.LogDwellTime; } }
        /// <summary>DwellInfo block</summary>
        public DwellInfoBlock DwellInfo;

        /// <summary>Default constructor</summary>
        public LogDwellTimePacket()
        {
            Header = new LowHeader();
            Header.ID = 30;
            Header.Reliable = true;
            DwellInfo = new DwellInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogDwellTimePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DwellInfo = new DwellInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogDwellTimePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DwellInfo = new DwellInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DwellInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DwellInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogFailedMoneyTransaction packet</summary>
    public class LogFailedMoneyTransactionPacket : Packet
    {
        /// <summary>TransactionData block</summary>
        public class TransactionDataBlock
        {
            /// <summary>FailureType field</summary>
            public byte FailureType;
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>Amount field</summary>
            public int Amount;
            /// <summary>SimulatorIP field</summary>
            public uint SimulatorIP;
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>GridX field</summary>
            public uint GridX;
            /// <summary>GridY field</summary>
            public uint GridY;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;
            /// <summary>TransactionTime field</summary>
            public uint TransactionTime;
            /// <summary>TransactionType field</summary>
            public int TransactionType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 74;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FailureType = (byte)bytes[i++];
                    DestID = new LLUUID(bytes, i); i += 16;
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SimulatorIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (byte)bytes[i++];
                    GridX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SourceID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                    TransactionTime = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = FailureType;
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)(SimulatorIP % 256);
                bytes[i++] = (byte)((SimulatorIP >> 8) % 256);
                bytes[i++] = (byte)((SimulatorIP >> 16) % 256);
                bytes[i++] = (byte)((SimulatorIP >> 24) % 256);
                bytes[i++] = Flags;
                bytes[i++] = (byte)(GridX % 256);
                bytes[i++] = (byte)((GridX >> 8) % 256);
                bytes[i++] = (byte)((GridX >> 16) % 256);
                bytes[i++] = (byte)((GridX >> 24) % 256);
                bytes[i++] = (byte)(GridY % 256);
                bytes[i++] = (byte)((GridY >> 8) % 256);
                bytes[i++] = (byte)((GridY >> 16) % 256);
                bytes[i++] = (byte)((GridY >> 24) % 256);
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TransactionTime % 256);
                bytes[i++] = (byte)((TransactionTime >> 8) % 256);
                bytes[i++] = (byte)((TransactionTime >> 16) % 256);
                bytes[i++] = (byte)((TransactionTime >> 24) % 256);
                bytes[i++] = (byte)(TransactionType % 256);
                bytes[i++] = (byte)((TransactionType >> 8) % 256);
                bytes[i++] = (byte)((TransactionType >> 16) % 256);
                bytes[i++] = (byte)((TransactionType >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogFailedMoneyTransaction</summary>
        public override PacketType Type { get { return PacketType.LogFailedMoneyTransaction; } }
        /// <summary>TransactionData block</summary>
        public TransactionDataBlock TransactionData;

        /// <summary>Default constructor</summary>
        public LogFailedMoneyTransactionPacket()
        {
            Header = new LowHeader();
            Header.ID = 31;
            Header.Reliable = true;
            TransactionData = new TransactionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogFailedMoneyTransactionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogFailedMoneyTransactionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransactionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransactionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserReportInternal packet</summary>
    public class UserReportInternalPacket : Packet
    {
        /// <summary>MeanCollision block</summary>
        public class MeanCollisionBlock
        {
            /// <summary>Mag field</summary>
            public float Mag;
            /// <summary>Time field</summary>
            public uint Time;
            /// <summary>Perp field</summary>
            public LLUUID Perp;
            /// <summary>Type field</summary>
            public byte Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MeanCollisionBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MeanCollisionBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Mag = BitConverter.ToSingle(bytes, i); i += 4;
                    Time = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Perp = new LLUUID(bytes, i); i += 16;
                    Type = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Mag);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(Time % 256);
                bytes[i++] = (byte)((Time >> 8) % 256);
                bytes[i++] = (byte)((Time >> 16) % 256);
                bytes[i++] = (byte)((Time >> 24) % 256);
                Array.Copy(Perp.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Type;
            }
        }

        /// <summary>ReportData block</summary>
        public class ReportDataBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _details;
            /// <summary>Details field</summary>
            public byte[] Details
            {
                get { return _details; }
                set
                {
                    if (value == null) { _details = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _details = new byte[value.Length]; Array.Copy(value, _details, value.Length); }
                }
            }
            private byte[] _versionstring;
            /// <summary>VersionString field</summary>
            public byte[] VersionString
            {
                get { return _versionstring; }
                set
                {
                    if (value == null) { _versionstring = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _versionstring = new byte[value.Length]; Array.Copy(value, _versionstring, value.Length); }
                }
            }
            /// <summary>AgentPosition field</summary>
            public LLVector3 AgentPosition;
            /// <summary>ReportType field</summary>
            public byte ReportType;
            /// <summary>Category field</summary>
            public byte Category;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            private byte[] _summary;
            /// <summary>Summary field</summary>
            public byte[] Summary
            {
                get { return _summary; }
                set
                {
                    if (value == null) { _summary = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _summary = new byte[value.Length]; Array.Copy(value, _summary, value.Length); }
                }
            }
            /// <summary>ReporterID field</summary>
            public LLUUID ReporterID;
            /// <summary>ScreenshotID field</summary>
            public LLUUID ScreenshotID;
            /// <summary>LastOwnerID field</summary>
            public LLUUID LastOwnerID;
            /// <summary>ViewerPosition field</summary>
            public LLVector3 ViewerPosition;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 122;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (Details != null) { length += 2 + Details.Length; }
                    if (VersionString != null) { length += 1 + VersionString.Length; }
                    if (Summary != null) { length += 1 + Summary.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReportDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReportDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _details = new byte[length];
                    Array.Copy(bytes, i, _details, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _versionstring = new byte[length];
                    Array.Copy(bytes, i, _versionstring, 0, length); i += length;
                    AgentPosition = new LLVector3(bytes, i); i += 12;
                    ReportType = (byte)bytes[i++];
                    Category = (byte)bytes[i++];
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _summary = new byte[length];
                    Array.Copy(bytes, i, _summary, 0, length); i += length;
                    ReporterID = new LLUUID(bytes, i); i += 16;
                    ScreenshotID = new LLUUID(bytes, i); i += 16;
                    LastOwnerID = new LLUUID(bytes, i); i += 16;
                    ViewerPosition = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Details.Length % 256);
                bytes[i++] = (byte)((Details.Length >> 8) % 256);
                Array.Copy(Details, 0, bytes, i, Details.Length); i += Details.Length;
                bytes[i++] = (byte)VersionString.Length;
                Array.Copy(VersionString, 0, bytes, i, VersionString.Length); i += VersionString.Length;
                Array.Copy(AgentPosition.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = ReportType;
                bytes[i++] = Category;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Summary.Length;
                Array.Copy(Summary, 0, bytes, i, Summary.Length); i += Summary.Length;
                Array.Copy(ReporterID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ScreenshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(LastOwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ViewerPosition.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserReportInternal</summary>
        public override PacketType Type { get { return PacketType.UserReportInternal; } }
        /// <summary>MeanCollision block</summary>
        public MeanCollisionBlock[] MeanCollision;
        /// <summary>ReportData block</summary>
        public ReportDataBlock ReportData;

        /// <summary>Default constructor</summary>
        public UserReportInternalPacket()
        {
            Header = new LowHeader();
            Header.ID = 32;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MeanCollision = new MeanCollisionBlock[0];
            ReportData = new ReportDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserReportInternalPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            MeanCollision = new MeanCollisionBlock[count];
            for (int j = 0; j < count; j++)
            { MeanCollision[j] = new MeanCollisionBlock(bytes, ref i); }
            ReportData = new ReportDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserReportInternalPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            MeanCollision = new MeanCollisionBlock[count];
            for (int j = 0; j < count; j++)
            { MeanCollision[j] = new MeanCollisionBlock(bytes, ref i); }
            ReportData = new ReportDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ReportData.Length;;
            for (int j = 0; j < MeanCollision.Length; j++) { length += MeanCollision[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)MeanCollision.Length;
            for (int j = 0; j < MeanCollision.Length; j++) { MeanCollision[j].ToBytes(bytes, ref i); }
            ReportData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetSimStatusInDatabase packet</summary>
    public class SetSimStatusInDatabasePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>X field</summary>
            public int X;
            /// <summary>Y field</summary>
            public int Y;
            /// <summary>PID field</summary>
            public int PID;
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            private byte[] _status;
            /// <summary>Status field</summary>
            public byte[] Status
            {
                get { return _status; }
                set
                {
                    if (value == null) { _status = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _status = new byte[value.Length]; Array.Copy(value, _status, value.Length); }
                }
            }
            /// <summary>AgentCount field</summary>
            public int AgentCount;
            private byte[] _hostname;
            /// <summary>HostName field</summary>
            public byte[] HostName
            {
                get { return _hostname; }
                set
                {
                    if (value == null) { _hostname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _hostname = new byte[value.Length]; Array.Copy(value, _hostname, value.Length); }
                }
            }
            /// <summary>TimeToLive field</summary>
            public int TimeToLive;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    if (Status != null) { length += 1 + Status.Length; }
                    if (HostName != null) { length += 1 + HostName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    X = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Y = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _status = new byte[length];
                    Array.Copy(bytes, i, _status, 0, length); i += length;
                    AgentCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _hostname = new byte[length];
                    Array.Copy(bytes, i, _hostname, 0, length); i += length;
                    TimeToLive = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(X % 256);
                bytes[i++] = (byte)((X >> 8) % 256);
                bytes[i++] = (byte)((X >> 16) % 256);
                bytes[i++] = (byte)((X >> 24) % 256);
                bytes[i++] = (byte)(Y % 256);
                bytes[i++] = (byte)((Y >> 8) % 256);
                bytes[i++] = (byte)((Y >> 16) % 256);
                bytes[i++] = (byte)((Y >> 24) % 256);
                bytes[i++] = (byte)(PID % 256);
                bytes[i++] = (byte)((PID >> 8) % 256);
                bytes[i++] = (byte)((PID >> 16) % 256);
                bytes[i++] = (byte)((PID >> 24) % 256);
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Status.Length;
                Array.Copy(Status, 0, bytes, i, Status.Length); i += Status.Length;
                bytes[i++] = (byte)(AgentCount % 256);
                bytes[i++] = (byte)((AgentCount >> 8) % 256);
                bytes[i++] = (byte)((AgentCount >> 16) % 256);
                bytes[i++] = (byte)((AgentCount >> 24) % 256);
                bytes[i++] = (byte)HostName.Length;
                Array.Copy(HostName, 0, bytes, i, HostName.Length); i += HostName.Length;
                bytes[i++] = (byte)(TimeToLive % 256);
                bytes[i++] = (byte)((TimeToLive >> 8) % 256);
                bytes[i++] = (byte)((TimeToLive >> 16) % 256);
                bytes[i++] = (byte)((TimeToLive >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetSimStatusInDatabase</summary>
        public override PacketType Type { get { return PacketType.SetSimStatusInDatabase; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public SetSimStatusInDatabasePacket()
        {
            Header = new LowHeader();
            Header.ID = 33;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetSimStatusInDatabasePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetSimStatusInDatabasePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetSimPresenceInDatabase packet</summary>
    public class SetSimPresenceInDatabasePacket : Packet
    {
        /// <summary>SimData block</summary>
        public class SimDataBlock
        {
            /// <summary>PID field</summary>
            public int PID;
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            private byte[] _status;
            /// <summary>Status field</summary>
            public byte[] Status
            {
                get { return _status; }
                set
                {
                    if (value == null) { _status = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _status = new byte[value.Length]; Array.Copy(value, _status, value.Length); }
                }
            }
            /// <summary>AgentCount field</summary>
            public int AgentCount;
            /// <summary>GridX field</summary>
            public uint GridX;
            /// <summary>GridY field</summary>
            public uint GridY;
            private byte[] _hostname;
            /// <summary>HostName field</summary>
            public byte[] HostName
            {
                get { return _hostname; }
                set
                {
                    if (value == null) { _hostname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _hostname = new byte[value.Length]; Array.Copy(value, _hostname, value.Length); }
                }
            }
            /// <summary>TimeToLive field</summary>
            public int TimeToLive;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    if (Status != null) { length += 1 + Status.Length; }
                    if (HostName != null) { length += 1 + HostName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    PID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _status = new byte[length];
                    Array.Copy(bytes, i, _status, 0, length); i += length;
                    AgentCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _hostname = new byte[length];
                    Array.Copy(bytes, i, _hostname, 0, length); i += length;
                    TimeToLive = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(PID % 256);
                bytes[i++] = (byte)((PID >> 8) % 256);
                bytes[i++] = (byte)((PID >> 16) % 256);
                bytes[i++] = (byte)((PID >> 24) % 256);
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Status.Length;
                Array.Copy(Status, 0, bytes, i, Status.Length); i += Status.Length;
                bytes[i++] = (byte)(AgentCount % 256);
                bytes[i++] = (byte)((AgentCount >> 8) % 256);
                bytes[i++] = (byte)((AgentCount >> 16) % 256);
                bytes[i++] = (byte)((AgentCount >> 24) % 256);
                bytes[i++] = (byte)(GridX % 256);
                bytes[i++] = (byte)((GridX >> 8) % 256);
                bytes[i++] = (byte)((GridX >> 16) % 256);
                bytes[i++] = (byte)((GridX >> 24) % 256);
                bytes[i++] = (byte)(GridY % 256);
                bytes[i++] = (byte)((GridY >> 8) % 256);
                bytes[i++] = (byte)((GridY >> 16) % 256);
                bytes[i++] = (byte)((GridY >> 24) % 256);
                bytes[i++] = (byte)HostName.Length;
                Array.Copy(HostName, 0, bytes, i, HostName.Length); i += HostName.Length;
                bytes[i++] = (byte)(TimeToLive % 256);
                bytes[i++] = (byte)((TimeToLive >> 8) % 256);
                bytes[i++] = (byte)((TimeToLive >> 16) % 256);
                bytes[i++] = (byte)((TimeToLive >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetSimPresenceInDatabase</summary>
        public override PacketType Type { get { return PacketType.SetSimPresenceInDatabase; } }
        /// <summary>SimData block</summary>
        public SimDataBlock SimData;

        /// <summary>Default constructor</summary>
        public SetSimPresenceInDatabasePacket()
        {
            Header = new LowHeader();
            Header.ID = 34;
            Header.Reliable = true;
            SimData = new SimDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetSimPresenceInDatabasePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            SimData = new SimDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetSimPresenceInDatabasePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimData = new SimDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SimData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EconomyDataRequest packet</summary>
    public class EconomyDataRequestPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EconomyDataRequest</summary>
        public override PacketType Type { get { return PacketType.EconomyDataRequest; } }

        /// <summary>Default constructor</summary>
        public EconomyDataRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 35;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EconomyDataRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EconomyDataRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EconomyData packet</summary>
    public class EconomyDataPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>PriceParcelClaimFactor field</summary>
            public float PriceParcelClaimFactor;
            /// <summary>ObjectCapacity field</summary>
            public int ObjectCapacity;
            /// <summary>EnergyEfficiency field</summary>
            public float EnergyEfficiency;
            /// <summary>ObjectCount field</summary>
            public int ObjectCount;
            /// <summary>TeleportPriceExponent field</summary>
            public float TeleportPriceExponent;
            /// <summary>PriceGroupCreate field</summary>
            public int PriceGroupCreate;
            /// <summary>PriceObjectRent field</summary>
            public float PriceObjectRent;
            /// <summary>PricePublicObjectDelete field</summary>
            public int PricePublicObjectDelete;
            /// <summary>PriceEnergyUnit field</summary>
            public int PriceEnergyUnit;
            /// <summary>TeleportMinPrice field</summary>
            public int TeleportMinPrice;
            /// <summary>PricePublicObjectDecay field</summary>
            public int PricePublicObjectDecay;
            /// <summary>PriceObjectClaim field</summary>
            public int PriceObjectClaim;
            /// <summary>PriceParcelClaim field</summary>
            public int PriceParcelClaim;
            /// <summary>PriceObjectScaleFactor field</summary>
            public float PriceObjectScaleFactor;
            /// <summary>PriceRentLight field</summary>
            public int PriceRentLight;
            /// <summary>PriceParcelRent field</summary>
            public int PriceParcelRent;
            /// <summary>PriceUpload field</summary>
            public int PriceUpload;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 68;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    PriceParcelClaimFactor = BitConverter.ToSingle(bytes, i); i += 4;
                    ObjectCapacity = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    EnergyEfficiency = BitConverter.ToSingle(bytes, i); i += 4;
                    ObjectCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TeleportPriceExponent = BitConverter.ToSingle(bytes, i); i += 4;
                    PriceGroupCreate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    PriceObjectRent = BitConverter.ToSingle(bytes, i); i += 4;
                    PricePublicObjectDelete = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PriceEnergyUnit = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TeleportMinPrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PricePublicObjectDecay = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PriceObjectClaim = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PriceParcelClaim = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    PriceObjectScaleFactor = BitConverter.ToSingle(bytes, i); i += 4;
                    PriceRentLight = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PriceParcelRent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PriceUpload = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(PriceParcelClaimFactor);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(ObjectCapacity % 256);
                bytes[i++] = (byte)((ObjectCapacity >> 8) % 256);
                bytes[i++] = (byte)((ObjectCapacity >> 16) % 256);
                bytes[i++] = (byte)((ObjectCapacity >> 24) % 256);
                ba = BitConverter.GetBytes(EnergyEfficiency);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(ObjectCount % 256);
                bytes[i++] = (byte)((ObjectCount >> 8) % 256);
                bytes[i++] = (byte)((ObjectCount >> 16) % 256);
                bytes[i++] = (byte)((ObjectCount >> 24) % 256);
                ba = BitConverter.GetBytes(TeleportPriceExponent);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(PriceGroupCreate % 256);
                bytes[i++] = (byte)((PriceGroupCreate >> 8) % 256);
                bytes[i++] = (byte)((PriceGroupCreate >> 16) % 256);
                bytes[i++] = (byte)((PriceGroupCreate >> 24) % 256);
                ba = BitConverter.GetBytes(PriceObjectRent);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(PricePublicObjectDelete % 256);
                bytes[i++] = (byte)((PricePublicObjectDelete >> 8) % 256);
                bytes[i++] = (byte)((PricePublicObjectDelete >> 16) % 256);
                bytes[i++] = (byte)((PricePublicObjectDelete >> 24) % 256);
                bytes[i++] = (byte)(PriceEnergyUnit % 256);
                bytes[i++] = (byte)((PriceEnergyUnit >> 8) % 256);
                bytes[i++] = (byte)((PriceEnergyUnit >> 16) % 256);
                bytes[i++] = (byte)((PriceEnergyUnit >> 24) % 256);
                bytes[i++] = (byte)(TeleportMinPrice % 256);
                bytes[i++] = (byte)((TeleportMinPrice >> 8) % 256);
                bytes[i++] = (byte)((TeleportMinPrice >> 16) % 256);
                bytes[i++] = (byte)((TeleportMinPrice >> 24) % 256);
                bytes[i++] = (byte)(PricePublicObjectDecay % 256);
                bytes[i++] = (byte)((PricePublicObjectDecay >> 8) % 256);
                bytes[i++] = (byte)((PricePublicObjectDecay >> 16) % 256);
                bytes[i++] = (byte)((PricePublicObjectDecay >> 24) % 256);
                bytes[i++] = (byte)(PriceObjectClaim % 256);
                bytes[i++] = (byte)((PriceObjectClaim >> 8) % 256);
                bytes[i++] = (byte)((PriceObjectClaim >> 16) % 256);
                bytes[i++] = (byte)((PriceObjectClaim >> 24) % 256);
                bytes[i++] = (byte)(PriceParcelClaim % 256);
                bytes[i++] = (byte)((PriceParcelClaim >> 8) % 256);
                bytes[i++] = (byte)((PriceParcelClaim >> 16) % 256);
                bytes[i++] = (byte)((PriceParcelClaim >> 24) % 256);
                ba = BitConverter.GetBytes(PriceObjectScaleFactor);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(PriceRentLight % 256);
                bytes[i++] = (byte)((PriceRentLight >> 8) % 256);
                bytes[i++] = (byte)((PriceRentLight >> 16) % 256);
                bytes[i++] = (byte)((PriceRentLight >> 24) % 256);
                bytes[i++] = (byte)(PriceParcelRent % 256);
                bytes[i++] = (byte)((PriceParcelRent >> 8) % 256);
                bytes[i++] = (byte)((PriceParcelRent >> 16) % 256);
                bytes[i++] = (byte)((PriceParcelRent >> 24) % 256);
                bytes[i++] = (byte)(PriceUpload % 256);
                bytes[i++] = (byte)((PriceUpload >> 8) % 256);
                bytes[i++] = (byte)((PriceUpload >> 16) % 256);
                bytes[i++] = (byte)((PriceUpload >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EconomyData</summary>
        public override PacketType Type { get { return PacketType.EconomyData; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public EconomyDataPacket()
        {
            Header = new LowHeader();
            Header.ID = 36;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EconomyDataPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EconomyDataPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPickerRequest packet</summary>
    public class AvatarPickerRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPickerRequest</summary>
        public override PacketType Type { get { return PacketType.AvatarPickerRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPickerRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 37;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPickerRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPickerRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPickerRequestBackend packet</summary>
    public class AvatarPickerRequestBackendPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GodLevel field</summary>
            public byte GodLevel;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 49;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GodLevel = (byte)bytes[i++];
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = GodLevel;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPickerRequestBackend</summary>
        public override PacketType Type { get { return PacketType.AvatarPickerRequestBackend; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPickerRequestBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 38;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPickerRequestBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPickerRequestBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPickerReply packet</summary>
    public class AvatarPickerReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _lastname;
            /// <summary>LastName field</summary>
            public byte[] LastName
            {
                get { return _lastname; }
                set
                {
                    if (value == null) { _lastname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lastname = new byte[value.Length]; Array.Copy(value, _lastname, value.Length); }
                }
            }
            private byte[] _firstname;
            /// <summary>FirstName field</summary>
            public byte[] FirstName
            {
                get { return _firstname; }
                set
                {
                    if (value == null) { _firstname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _firstname = new byte[value.Length]; Array.Copy(value, _firstname, value.Length); }
                }
            }
            /// <summary>AvatarID field</summary>
            public LLUUID AvatarID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (LastName != null) { length += 1 + LastName.Length; }
                    if (FirstName != null) { length += 1 + FirstName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _lastname = new byte[length];
                    Array.Copy(bytes, i, _lastname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _firstname = new byte[length];
                    Array.Copy(bytes, i, _firstname, 0, length); i += length;
                    AvatarID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)LastName.Length;
                Array.Copy(LastName, 0, bytes, i, LastName.Length); i += LastName.Length;
                bytes[i++] = (byte)FirstName.Length;
                Array.Copy(FirstName, 0, bytes, i, FirstName.Length); i += FirstName.Length;
                Array.Copy(AvatarID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPickerReply</summary>
        public override PacketType Type { get { return PacketType.AvatarPickerReply; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPickerReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 39;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPickerReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPickerReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PlacesQuery packet</summary>
    public class PlacesQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>Category field</summary>
            public sbyte Category;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    Category = (sbyte)bytes[i++];
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)Category;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TransactionData block</summary>
        public class TransactionDataBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PlacesQuery</summary>
        public override PacketType Type { get { return PacketType.PlacesQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>TransactionData block</summary>
        public TransactionDataBlock TransactionData;

        /// <summary>Default constructor</summary>
        public PlacesQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 40;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
            TransactionData = new TransactionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PlacesQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PlacesQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;            length += TransactionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            TransactionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PlacesReply packet</summary>
    public class PlacesReplyPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>BillableArea field</summary>
            public int BillableArea;
            /// <summary>ActualArea field</summary>
            public int ActualArea;
            /// <summary>GlobalX field</summary>
            public float GlobalX;
            /// <summary>GlobalY field</summary>
            public float GlobalY;
            /// <summary>GlobalZ field</summary>
            public float GlobalZ;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>Price field</summary>
            public int Price;
            /// <summary>Dwell field</summary>
            public float Dwell;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 62;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 1 + Desc.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    BillableArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ActualArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    GlobalX = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    GlobalY = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    GlobalZ = BitConverter.ToSingle(bytes, i); i += 4;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    Flags = (byte)bytes[i++];
                    Price = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Dwell = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)(BillableArea % 256);
                bytes[i++] = (byte)((BillableArea >> 8) % 256);
                bytes[i++] = (byte)((BillableArea >> 16) % 256);
                bytes[i++] = (byte)((BillableArea >> 24) % 256);
                bytes[i++] = (byte)(ActualArea % 256);
                bytes[i++] = (byte)((ActualArea >> 8) % 256);
                bytes[i++] = (byte)((ActualArea >> 16) % 256);
                bytes[i++] = (byte)((ActualArea >> 24) % 256);
                ba = BitConverter.GetBytes(GlobalX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(GlobalY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(GlobalZ);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)Desc.Length;
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Flags;
                bytes[i++] = (byte)(Price % 256);
                bytes[i++] = (byte)((Price >> 8) % 256);
                bytes[i++] = (byte)((Price >> 16) % 256);
                bytes[i++] = (byte)((Price >> 24) % 256);
                ba = BitConverter.GetBytes(Dwell);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TransactionData block</summary>
        public class TransactionDataBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PlacesReply</summary>
        public override PacketType Type { get { return PacketType.PlacesReply; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock[] QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>TransactionData block</summary>
        public TransactionDataBlock TransactionData;

        /// <summary>Default constructor</summary>
        public PlacesReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 41;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock[0];
            AgentData = new AgentDataBlock();
            TransactionData = new TransactionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PlacesReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryData = new QueryDataBlock[count];
            for (int j = 0; j < count; j++)
            { QueryData[j] = new QueryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PlacesReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryData = new QueryDataBlock[count];
            for (int j = 0; j < count; j++)
            { QueryData[j] = new QueryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += TransactionData.Length;;
            for (int j = 0; j < QueryData.Length; j++) { length += QueryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryData.Length;
            for (int j = 0; j < QueryData.Length; j++) { QueryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            TransactionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirFindQuery packet</summary>
    public class DirFindQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>QueryStart field</summary>
            public int QueryStart;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    QueryStart = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(QueryStart % 256);
                bytes[i++] = (byte)((QueryStart >> 8) % 256);
                bytes[i++] = (byte)((QueryStart >> 16) % 256);
                bytes[i++] = (byte)((QueryStart >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirFindQuery</summary>
        public override PacketType Type { get { return PacketType.DirFindQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirFindQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 42;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirFindQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirFindQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirFindQueryBackend packet</summary>
    public class DirFindQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>SpaceIP field</summary>
            public uint SpaceIP;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>QueryStart field</summary>
            public int QueryStart;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    SpaceIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    QueryStart = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SpaceIP % 256);
                bytes[i++] = (byte)((SpaceIP >> 8) % 256);
                bytes[i++] = (byte)((SpaceIP >> 16) % 256);
                bytes[i++] = (byte)((SpaceIP >> 24) % 256);
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(QueryStart % 256);
                bytes[i++] = (byte)((QueryStart >> 8) % 256);
                bytes[i++] = (byte)((QueryStart >> 16) % 256);
                bytes[i++] = (byte)((QueryStart >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirFindQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirFindQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirFindQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 43;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirFindQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirFindQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPlacesQuery packet</summary>
    public class DirPlacesQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Category field</summary>
            public sbyte Category;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>QueryStart field</summary>
            public int QueryStart;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Category = (sbyte)bytes[i++];
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    QueryStart = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Category;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(QueryStart % 256);
                bytes[i++] = (byte)((QueryStart >> 8) % 256);
                bytes[i++] = (byte)((QueryStart >> 16) % 256);
                bytes[i++] = (byte)((QueryStart >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPlacesQuery</summary>
        public override PacketType Type { get { return PacketType.DirPlacesQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPlacesQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 44;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPlacesQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPlacesQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPlacesQueryBackend packet</summary>
    public class DirPlacesQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Category field</summary>
            public sbyte Category;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>QueryStart field</summary>
            public int QueryStart;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 30;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Category = (sbyte)bytes[i++];
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    QueryStart = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Category;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(QueryStart % 256);
                bytes[i++] = (byte)((QueryStart >> 8) % 256);
                bytes[i++] = (byte)((QueryStart >> 16) % 256);
                bytes[i++] = (byte)((QueryStart >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPlacesQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirPlacesQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPlacesQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 45;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPlacesQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPlacesQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPlacesReply packet</summary>
    public class DirPlacesReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            /// <summary>ReservedNewbie field</summary>
            public bool ReservedNewbie;
            /// <summary>ForSale field</summary>
            public bool ForSale;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Auction field</summary>
            public bool Auction;
            /// <summary>Dwell field</summary>
            public float Dwell;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ReservedNewbie = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ForSale = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Auction = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Dwell = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)((ReservedNewbie) ? 1 : 0);
                bytes[i++] = (byte)((ForSale) ? 1 : 0);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)((Auction) ? 1 : 0);
                ba = BitConverter.GetBytes(Dwell);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPlacesReply</summary>
        public override PacketType Type { get { return PacketType.DirPlacesReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock[] QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPlacesReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 46;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPlacesReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            count = (int)bytes[i++];
            QueryData = new QueryDataBlock[count];
            for (int j = 0; j < count; j++)
            { QueryData[j] = new QueryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPlacesReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            count = (int)bytes[i++];
            QueryData = new QueryDataBlock[count];
            for (int j = 0; j < count; j++)
            { QueryData[j] = new QueryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            for (int j = 0; j < QueryData.Length; j++) { length += QueryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            bytes[i++] = (byte)QueryData.Length;
            for (int j = 0; j < QueryData.Length; j++) { QueryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPeopleQuery packet</summary>
    public class DirPeopleQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>SkillFlags field</summary>
            public uint SkillFlags;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Online field</summary>
            public byte Online;
            private byte[] _reputation;
            /// <summary>Reputation field</summary>
            public byte[] Reputation
            {
                get { return _reputation; }
                set
                {
                    if (value == null) { _reputation = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _reputation = new byte[value.Length]; Array.Copy(value, _reputation, value.Length); }
                }
            }
            private byte[] _distance;
            /// <summary>Distance field</summary>
            public byte[] Distance
            {
                get { return _distance; }
                set
                {
                    if (value == null) { _distance = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _distance = new byte[value.Length]; Array.Copy(value, _distance, value.Length); }
                }
            }
            private byte[] _group;
            /// <summary>Group field</summary>
            public byte[] Group
            {
                get { return _group; }
                set
                {
                    if (value == null) { _group = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _group = new byte[value.Length]; Array.Copy(value, _group, value.Length); }
                }
            }
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }
            /// <summary>WantToFlags field</summary>
            public uint WantToFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Reputation != null) { length += 1 + Reputation.Length; }
                    if (Distance != null) { length += 1 + Distance.Length; }
                    if (Group != null) { length += 1 + Group.Length; }
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    SkillFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Online = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _reputation = new byte[length];
                    Array.Copy(bytes, i, _reputation, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _distance = new byte[length];
                    Array.Copy(bytes, i, _distance, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _group = new byte[length];
                    Array.Copy(bytes, i, _group, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                    WantToFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SkillFlags % 256);
                bytes[i++] = (byte)((SkillFlags >> 8) % 256);
                bytes[i++] = (byte)((SkillFlags >> 16) % 256);
                bytes[i++] = (byte)((SkillFlags >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Online;
                bytes[i++] = (byte)Reputation.Length;
                Array.Copy(Reputation, 0, bytes, i, Reputation.Length); i += Reputation.Length;
                bytes[i++] = (byte)Distance.Length;
                Array.Copy(Distance, 0, bytes, i, Distance.Length); i += Distance.Length;
                bytes[i++] = (byte)Group.Length;
                Array.Copy(Group, 0, bytes, i, Group.Length); i += Group.Length;
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
                bytes[i++] = (byte)(WantToFlags % 256);
                bytes[i++] = (byte)((WantToFlags >> 8) % 256);
                bytes[i++] = (byte)((WantToFlags >> 16) % 256);
                bytes[i++] = (byte)((WantToFlags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPeopleQuery</summary>
        public override PacketType Type { get { return PacketType.DirPeopleQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPeopleQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 47;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPeopleQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPeopleQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPeopleQueryBackend packet</summary>
    public class DirPeopleQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>SpaceIP field</summary>
            public uint SpaceIP;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>SkillFlags field</summary>
            public uint SkillFlags;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Online field</summary>
            public byte Online;
            private byte[] _reputation;
            /// <summary>Reputation field</summary>
            public byte[] Reputation
            {
                get { return _reputation; }
                set
                {
                    if (value == null) { _reputation = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _reputation = new byte[value.Length]; Array.Copy(value, _reputation, value.Length); }
                }
            }
            private byte[] _distance;
            /// <summary>Distance field</summary>
            public byte[] Distance
            {
                get { return _distance; }
                set
                {
                    if (value == null) { _distance = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _distance = new byte[value.Length]; Array.Copy(value, _distance, value.Length); }
                }
            }
            private byte[] _group;
            /// <summary>Group field</summary>
            public byte[] Group
            {
                get { return _group; }
                set
                {
                    if (value == null) { _group = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _group = new byte[value.Length]; Array.Copy(value, _group, value.Length); }
                }
            }
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }
            /// <summary>EstateID field</summary>
            public uint EstateID;
            /// <summary>WantToFlags field</summary>
            public uint WantToFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 34;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Reputation != null) { length += 1 + Reputation.Length; }
                    if (Distance != null) { length += 1 + Distance.Length; }
                    if (Group != null) { length += 1 + Group.Length; }
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    SpaceIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    SkillFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Online = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _reputation = new byte[length];
                    Array.Copy(bytes, i, _reputation, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _distance = new byte[length];
                    Array.Copy(bytes, i, _distance, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _group = new byte[length];
                    Array.Copy(bytes, i, _group, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    WantToFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SpaceIP % 256);
                bytes[i++] = (byte)((SpaceIP >> 8) % 256);
                bytes[i++] = (byte)((SpaceIP >> 16) % 256);
                bytes[i++] = (byte)((SpaceIP >> 24) % 256);
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                bytes[i++] = (byte)(SkillFlags % 256);
                bytes[i++] = (byte)((SkillFlags >> 8) % 256);
                bytes[i++] = (byte)((SkillFlags >> 16) % 256);
                bytes[i++] = (byte)((SkillFlags >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Online;
                bytes[i++] = (byte)Reputation.Length;
                Array.Copy(Reputation, 0, bytes, i, Reputation.Length); i += Reputation.Length;
                bytes[i++] = (byte)Distance.Length;
                Array.Copy(Distance, 0, bytes, i, Distance.Length); i += Distance.Length;
                bytes[i++] = (byte)Group.Length;
                Array.Copy(Group, 0, bytes, i, Group.Length); i += Group.Length;
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
                bytes[i++] = (byte)(WantToFlags % 256);
                bytes[i++] = (byte)((WantToFlags >> 8) % 256);
                bytes[i++] = (byte)((WantToFlags >> 16) % 256);
                bytes[i++] = (byte)((WantToFlags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPeopleQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirPeopleQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPeopleQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 48;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPeopleQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPeopleQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPeopleReply packet</summary>
    public class DirPeopleReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _lastname;
            /// <summary>LastName field</summary>
            public byte[] LastName
            {
                get { return _lastname; }
                set
                {
                    if (value == null) { _lastname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lastname = new byte[value.Length]; Array.Copy(value, _lastname, value.Length); }
                }
            }
            private byte[] _firstname;
            /// <summary>FirstName field</summary>
            public byte[] FirstName
            {
                get { return _firstname; }
                set
                {
                    if (value == null) { _firstname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _firstname = new byte[value.Length]; Array.Copy(value, _firstname, value.Length); }
                }
            }
            /// <summary>Online field</summary>
            public bool Online;
            /// <summary>Reputation field</summary>
            public int Reputation;
            private byte[] _group;
            /// <summary>Group field</summary>
            public byte[] Group
            {
                get { return _group; }
                set
                {
                    if (value == null) { _group = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _group = new byte[value.Length]; Array.Copy(value, _group, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 22;
                    if (LastName != null) { length += 1 + LastName.Length; }
                    if (FirstName != null) { length += 1 + FirstName.Length; }
                    if (Group != null) { length += 1 + Group.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _lastname = new byte[length];
                    Array.Copy(bytes, i, _lastname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _firstname = new byte[length];
                    Array.Copy(bytes, i, _firstname, 0, length); i += length;
                    Online = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Reputation = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _group = new byte[length];
                    Array.Copy(bytes, i, _group, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)LastName.Length;
                Array.Copy(LastName, 0, bytes, i, LastName.Length); i += LastName.Length;
                bytes[i++] = (byte)FirstName.Length;
                Array.Copy(FirstName, 0, bytes, i, FirstName.Length); i += FirstName.Length;
                bytes[i++] = (byte)((Online) ? 1 : 0);
                bytes[i++] = (byte)(Reputation % 256);
                bytes[i++] = (byte)((Reputation >> 8) % 256);
                bytes[i++] = (byte)((Reputation >> 16) % 256);
                bytes[i++] = (byte)((Reputation >> 24) % 256);
                bytes[i++] = (byte)Group.Length;
                Array.Copy(Group, 0, bytes, i, Group.Length); i += Group.Length;
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPeopleReply</summary>
        public override PacketType Type { get { return PacketType.DirPeopleReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPeopleReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 49;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPeopleReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPeopleReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirEventsReply packet</summary>
    public class DirEventsReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _date;
            /// <summary>Date field</summary>
            public byte[] Date
            {
                get { return _date; }
                set
                {
                    if (value == null) { _date = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _date = new byte[value.Length]; Array.Copy(value, _date, value.Length); }
                }
            }
            /// <summary>EventID field</summary>
            public uint EventID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>EventFlags field</summary>
            public uint EventFlags;
            /// <summary>UnixTime field</summary>
            public uint UnixTime;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Date != null) { length += 1 + Date.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _date = new byte[length];
                    Array.Copy(bytes, i, _date, 0, length); i += length;
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    EventFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    UnixTime = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)Date.Length;
                Array.Copy(Date, 0, bytes, i, Date.Length); i += Date.Length;
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EventFlags % 256);
                bytes[i++] = (byte)((EventFlags >> 8) % 256);
                bytes[i++] = (byte)((EventFlags >> 16) % 256);
                bytes[i++] = (byte)((EventFlags >> 24) % 256);
                bytes[i++] = (byte)(UnixTime % 256);
                bytes[i++] = (byte)((UnixTime >> 8) % 256);
                bytes[i++] = (byte)((UnixTime >> 16) % 256);
                bytes[i++] = (byte)((UnixTime >> 24) % 256);
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirEventsReply</summary>
        public override PacketType Type { get { return PacketType.DirEventsReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirEventsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 50;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirEventsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirEventsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirGroupsQuery packet</summary>
    public class DirGroupsQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirGroupsQuery</summary>
        public override PacketType Type { get { return PacketType.DirGroupsQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirGroupsQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 51;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirGroupsQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirGroupsQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirGroupsQueryBackend packet</summary>
    public class DirGroupsQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirGroupsQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirGroupsQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirGroupsQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 52;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirGroupsQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirGroupsQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirGroupsReply packet</summary>
    public class DirGroupsReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            /// <summary>Members field</summary>
            public int Members;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>MembershipFee field</summary>
            public int MembershipFee;
            /// <summary>OpenEnrollment field</summary>
            public bool OpenEnrollment;
            private byte[] _groupname;
            /// <summary>GroupName field</summary>
            public byte[] GroupName
            {
                get { return _groupname; }
                set
                {
                    if (value == null) { _groupname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _groupname = new byte[value.Length]; Array.Copy(value, _groupname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    if (GroupName != null) { length += 1 + GroupName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Members = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    MembershipFee = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OpenEnrollment = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _groupname = new byte[length];
                    Array.Copy(bytes, i, _groupname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Members % 256);
                bytes[i++] = (byte)((Members >> 8) % 256);
                bytes[i++] = (byte)((Members >> 16) % 256);
                bytes[i++] = (byte)((Members >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MembershipFee % 256);
                bytes[i++] = (byte)((MembershipFee >> 8) % 256);
                bytes[i++] = (byte)((MembershipFee >> 16) % 256);
                bytes[i++] = (byte)((MembershipFee >> 24) % 256);
                bytes[i++] = (byte)((OpenEnrollment) ? 1 : 0);
                bytes[i++] = (byte)GroupName.Length;
                Array.Copy(GroupName, 0, bytes, i, GroupName.Length); i += GroupName.Length;
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirGroupsReply</summary>
        public override PacketType Type { get { return PacketType.DirGroupsReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirGroupsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 53;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirGroupsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirGroupsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirClassifiedQuery packet</summary>
    public class DirClassifiedQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Category field</summary>
            public uint Category;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Category = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Category % 256);
                bytes[i++] = (byte)((Category >> 8) % 256);
                bytes[i++] = (byte)((Category >> 16) % 256);
                bytes[i++] = (byte)((Category >> 24) % 256);
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirClassifiedQuery</summary>
        public override PacketType Type { get { return PacketType.DirClassifiedQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirClassifiedQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 54;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirClassifiedQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirClassifiedQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirClassifiedQueryBackend packet</summary>
    public class DirClassifiedQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Category field</summary>
            public uint Category;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Category = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Category % 256);
                bytes[i++] = (byte)((Category >> 8) % 256);
                bytes[i++] = (byte)((Category >> 16) % 256);
                bytes[i++] = (byte)((Category >> 24) % 256);
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirClassifiedQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirClassifiedQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirClassifiedQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 55;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirClassifiedQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirClassifiedQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirClassifiedReply packet</summary>
    public class DirClassifiedReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            /// <summary>ClassifiedFlags field</summary>
            public byte ClassifiedFlags;
            /// <summary>CreationDate field</summary>
            public uint CreationDate;
            /// <summary>ClassifiedID field</summary>
            public LLUUID ClassifiedID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>PriceForListing field</summary>
            public int PriceForListing;
            /// <summary>ExpirationDate field</summary>
            public uint ExpirationDate;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 30;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ClassifiedFlags = (byte)bytes[i++];
                    CreationDate = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ClassifiedID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    PriceForListing = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ExpirationDate = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ClassifiedFlags;
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                Array.Copy(ClassifiedID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(PriceForListing % 256);
                bytes[i++] = (byte)((PriceForListing >> 8) % 256);
                bytes[i++] = (byte)((PriceForListing >> 16) % 256);
                bytes[i++] = (byte)((PriceForListing >> 24) % 256);
                bytes[i++] = (byte)(ExpirationDate % 256);
                bytes[i++] = (byte)((ExpirationDate >> 8) % 256);
                bytes[i++] = (byte)((ExpirationDate >> 16) % 256);
                bytes[i++] = (byte)((ExpirationDate >> 24) % 256);
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirClassifiedReply</summary>
        public override PacketType Type { get { return PacketType.DirClassifiedReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirClassifiedReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 56;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirClassifiedReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirClassifiedReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarClassifiedReply packet</summary>
    public class AvatarClassifiedReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ClassifiedID field</summary>
            public LLUUID ClassifiedID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ClassifiedID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ClassifiedID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    TargetID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarClassifiedReply</summary>
        public override PacketType Type { get { return PacketType.AvatarClassifiedReply; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarClassifiedReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 57;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarClassifiedReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarClassifiedReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClassifiedInfoRequest packet</summary>
    public class ClassifiedInfoRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ClassifiedID field</summary>
            public LLUUID ClassifiedID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ClassifiedID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ClassifiedID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClassifiedInfoRequest</summary>
        public override PacketType Type { get { return PacketType.ClassifiedInfoRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ClassifiedInfoRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 58;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClassifiedInfoRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClassifiedInfoRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClassifiedInfoReply packet</summary>
    public class ClassifiedInfoReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ClassifiedFlags field</summary>
            public byte ClassifiedFlags;
            /// <summary>CreationDate field</summary>
            public uint CreationDate;
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>ClassifiedID field</summary>
            public LLUUID ClassifiedID;
            /// <summary>PosGlobal field</summary>
            public LLVector3d PosGlobal;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            private byte[] _parcelname;
            /// <summary>ParcelName field</summary>
            public byte[] ParcelName
            {
                get { return _parcelname; }
                set
                {
                    if (value == null) { _parcelname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _parcelname = new byte[value.Length]; Array.Copy(value, _parcelname, value.Length); }
                }
            }
            /// <summary>Category field</summary>
            public uint Category;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>PriceForListing field</summary>
            public int PriceForListing;
            /// <summary>ExpirationDate field</summary>
            public uint ExpirationDate;
            /// <summary>ParentEstate field</summary>
            public uint ParentEstate;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 109;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 2 + Desc.Length; }
                    if (ParcelName != null) { length += 1 + ParcelName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ClassifiedFlags = (byte)bytes[i++];
                    CreationDate = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    ClassifiedID = new LLUUID(bytes, i); i += 16;
                    PosGlobal = new LLVector3d(bytes, i); i += 24;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _parcelname = new byte[length];
                    Array.Copy(bytes, i, _parcelname, 0, length); i += length;
                    Category = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    PriceForListing = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ExpirationDate = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParentEstate = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ClassifiedFlags;
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(ClassifiedID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(PosGlobal.GetBytes(), 0, bytes, i, 24); i += 24;
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Desc.Length % 256);
                bytes[i++] = (byte)((Desc.Length >> 8) % 256);
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                bytes[i++] = (byte)ParcelName.Length;
                Array.Copy(ParcelName, 0, bytes, i, ParcelName.Length); i += ParcelName.Length;
                bytes[i++] = (byte)(Category % 256);
                bytes[i++] = (byte)((Category >> 8) % 256);
                bytes[i++] = (byte)((Category >> 16) % 256);
                bytes[i++] = (byte)((Category >> 24) % 256);
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(PriceForListing % 256);
                bytes[i++] = (byte)((PriceForListing >> 8) % 256);
                bytes[i++] = (byte)((PriceForListing >> 16) % 256);
                bytes[i++] = (byte)((PriceForListing >> 24) % 256);
                bytes[i++] = (byte)(ExpirationDate % 256);
                bytes[i++] = (byte)((ExpirationDate >> 8) % 256);
                bytes[i++] = (byte)((ExpirationDate >> 16) % 256);
                bytes[i++] = (byte)((ExpirationDate >> 24) % 256);
                bytes[i++] = (byte)(ParentEstate % 256);
                bytes[i++] = (byte)((ParentEstate >> 8) % 256);
                bytes[i++] = (byte)((ParentEstate >> 16) % 256);
                bytes[i++] = (byte)((ParentEstate >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClassifiedInfoReply</summary>
        public override PacketType Type { get { return PacketType.ClassifiedInfoReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ClassifiedInfoReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 59;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClassifiedInfoReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClassifiedInfoReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClassifiedInfoUpdate packet</summary>
    public class ClassifiedInfoUpdatePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ClassifiedFlags field</summary>
            public byte ClassifiedFlags;
            /// <summary>ClassifiedID field</summary>
            public LLUUID ClassifiedID;
            /// <summary>PosGlobal field</summary>
            public LLVector3d PosGlobal;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            /// <summary>Category field</summary>
            public uint Category;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>PriceForListing field</summary>
            public int PriceForListing;
            /// <summary>ParentEstate field</summary>
            public uint ParentEstate;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 85;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 2 + Desc.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ClassifiedFlags = (byte)bytes[i++];
                    ClassifiedID = new LLUUID(bytes, i); i += 16;
                    PosGlobal = new LLVector3d(bytes, i); i += 24;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    Category = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    PriceForListing = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParentEstate = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ClassifiedFlags;
                Array.Copy(ClassifiedID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(PosGlobal.GetBytes(), 0, bytes, i, 24); i += 24;
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Desc.Length % 256);
                bytes[i++] = (byte)((Desc.Length >> 8) % 256);
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                bytes[i++] = (byte)(Category % 256);
                bytes[i++] = (byte)((Category >> 8) % 256);
                bytes[i++] = (byte)((Category >> 16) % 256);
                bytes[i++] = (byte)((Category >> 24) % 256);
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(PriceForListing % 256);
                bytes[i++] = (byte)((PriceForListing >> 8) % 256);
                bytes[i++] = (byte)((PriceForListing >> 16) % 256);
                bytes[i++] = (byte)((PriceForListing >> 24) % 256);
                bytes[i++] = (byte)(ParentEstate % 256);
                bytes[i++] = (byte)((ParentEstate >> 8) % 256);
                bytes[i++] = (byte)((ParentEstate >> 16) % 256);
                bytes[i++] = (byte)((ParentEstate >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClassifiedInfoUpdate</summary>
        public override PacketType Type { get { return PacketType.ClassifiedInfoUpdate; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ClassifiedInfoUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 60;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClassifiedInfoUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClassifiedInfoUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClassifiedDelete packet</summary>
    public class ClassifiedDeletePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ClassifiedID field</summary>
            public LLUUID ClassifiedID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ClassifiedID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ClassifiedID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClassifiedDelete</summary>
        public override PacketType Type { get { return PacketType.ClassifiedDelete; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ClassifiedDeletePacket()
        {
            Header = new LowHeader();
            Header.ID = 61;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClassifiedDeletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClassifiedDeletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClassifiedGodDelete packet</summary>
    public class ClassifiedGodDeletePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ClassifiedID field</summary>
            public LLUUID ClassifiedID;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ClassifiedID = new LLUUID(bytes, i); i += 16;
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ClassifiedID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClassifiedGodDelete</summary>
        public override PacketType Type { get { return PacketType.ClassifiedGodDelete; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ClassifiedGodDeletePacket()
        {
            Header = new LowHeader();
            Header.ID = 62;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClassifiedGodDeletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClassifiedGodDeletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPicksQuery packet</summary>
    public class DirPicksQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPicksQuery</summary>
        public override PacketType Type { get { return PacketType.DirPicksQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPicksQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 63;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPicksQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPicksQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPicksQueryBackend packet</summary>
    public class DirPicksQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPicksQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirPicksQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPicksQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 64;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPicksQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPicksQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPicksReply packet</summary>
    public class DirPicksReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            /// <summary>Enabled field</summary>
            public bool Enabled;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>PickID field</summary>
            public LLUUID PickID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Enabled = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    PickID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Enabled) ? 1 : 0);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(PickID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPicksReply</summary>
        public override PacketType Type { get { return PacketType.DirPicksReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPicksReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 65;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPicksReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPicksReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirLandQuery packet</summary>
    public class DirLandQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>ReservedNewbie field</summary>
            public bool ReservedNewbie;
            /// <summary>ForSale field</summary>
            public bool ForSale;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Auction field</summary>
            public bool Auction;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 23;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ReservedNewbie = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ForSale = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Auction = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((ReservedNewbie) ? 1 : 0);
                bytes[i++] = (byte)((ForSale) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Auction) ? 1 : 0);
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirLandQuery</summary>
        public override PacketType Type { get { return PacketType.DirLandQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirLandQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 66;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirLandQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirLandQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirLandQueryBackend packet</summary>
    public class DirLandQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>ReservedNewbie field</summary>
            public bool ReservedNewbie;
            /// <summary>ForSale field</summary>
            public bool ForSale;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>Auction field</summary>
            public bool Auction;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ReservedNewbie = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ForSale = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    Auction = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((ReservedNewbie) ? 1 : 0);
                bytes[i++] = (byte)((ForSale) ? 1 : 0);
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Auction) ? 1 : 0);
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirLandQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirLandQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirLandQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 67;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirLandQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirLandQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirLandReply packet</summary>
    public class DirLandReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            /// <summary>ReservedNewbie field</summary>
            public bool ReservedNewbie;
            /// <summary>ActualArea field</summary>
            public int ActualArea;
            /// <summary>ForSale field</summary>
            public bool ForSale;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Auction field</summary>
            public bool Auction;
            /// <summary>SalePrice field</summary>
            public int SalePrice;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ReservedNewbie = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ActualArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ForSale = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Auction = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((ReservedNewbie) ? 1 : 0);
                bytes[i++] = (byte)(ActualArea % 256);
                bytes[i++] = (byte)((ActualArea >> 8) % 256);
                bytes[i++] = (byte)((ActualArea >> 16) % 256);
                bytes[i++] = (byte)((ActualArea >> 24) % 256);
                bytes[i++] = (byte)((ForSale) ? 1 : 0);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)((Auction) ? 1 : 0);
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirLandReply</summary>
        public override PacketType Type { get { return PacketType.DirLandReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirLandReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 68;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirLandReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirLandReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPopularQuery packet</summary>
    public class DirPopularQueryPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPopularQuery</summary>
        public override PacketType Type { get { return PacketType.DirPopularQuery; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPopularQueryPacket()
        {
            Header = new LowHeader();
            Header.ID = 69;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPopularQueryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPopularQueryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPopularQueryBackend packet</summary>
    public class DirPopularQueryBackendPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPopularQueryBackend</summary>
        public override PacketType Type { get { return PacketType.DirPopularQueryBackend; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPopularQueryBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 70;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPopularQueryBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPopularQueryBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DirPopularReply packet</summary>
    public class DirPopularReplyPacket : Packet
    {
        /// <summary>QueryReplies block</summary>
        public class QueryRepliesBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Dwell field</summary>
            public float Dwell;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryRepliesBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryRepliesBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Dwell = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                ba = BitConverter.GetBytes(Dwell);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DirPopularReply</summary>
        public override PacketType Type { get { return PacketType.DirPopularReply; } }
        /// <summary>QueryReplies block</summary>
        public QueryRepliesBlock[] QueryReplies;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DirPopularReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 71;
            Header.Reliable = true;
            Header.Zerocoded = true;
            QueryReplies = new QueryRepliesBlock[0];
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DirPopularReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DirPopularReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            QueryReplies = new QueryRepliesBlock[count];
            for (int j = 0; j < count; j++)
            { QueryReplies[j] = new QueryRepliesBlock(bytes, ref i); }
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;            length += AgentData.Length;;
            for (int j = 0; j < QueryReplies.Length; j++) { length += QueryReplies[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)QueryReplies.Length;
            for (int j = 0; j < QueryReplies.Length; j++) { QueryReplies[j].ToBytes(bytes, ref i); }
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelInfoRequest packet</summary>
    public class ParcelInfoRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelInfoRequest</summary>
        public override PacketType Type { get { return PacketType.ParcelInfoRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelInfoRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 72;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelInfoRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelInfoRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelInfoReply packet</summary>
    public class ParcelInfoReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>BillableArea field</summary>
            public int BillableArea;
            /// <summary>ActualArea field</summary>
            public int ActualArea;
            /// <summary>GlobalX field</summary>
            public float GlobalX;
            /// <summary>GlobalY field</summary>
            public float GlobalY;
            /// <summary>GlobalZ field</summary>
            public float GlobalZ;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>AuctionID field</summary>
            public int AuctionID;
            /// <summary>Dwell field</summary>
            public float Dwell;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 81;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 1 + Desc.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    BillableArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ActualArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    GlobalX = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    GlobalY = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    GlobalZ = BitConverter.ToSingle(bytes, i); i += 4;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    Flags = (byte)bytes[i++];
                    AuctionID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Dwell = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)(BillableArea % 256);
                bytes[i++] = (byte)((BillableArea >> 8) % 256);
                bytes[i++] = (byte)((BillableArea >> 16) % 256);
                bytes[i++] = (byte)((BillableArea >> 24) % 256);
                bytes[i++] = (byte)(ActualArea % 256);
                bytes[i++] = (byte)((ActualArea >> 8) % 256);
                bytes[i++] = (byte)((ActualArea >> 16) % 256);
                bytes[i++] = (byte)((ActualArea >> 24) % 256);
                ba = BitConverter.GetBytes(GlobalX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(GlobalY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(GlobalZ);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)Desc.Length;
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Flags;
                bytes[i++] = (byte)(AuctionID % 256);
                bytes[i++] = (byte)((AuctionID >> 8) % 256);
                bytes[i++] = (byte)((AuctionID >> 16) % 256);
                bytes[i++] = (byte)((AuctionID >> 24) % 256);
                ba = BitConverter.GetBytes(Dwell);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelInfoReply</summary>
        public override PacketType Type { get { return PacketType.ParcelInfoReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelInfoReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 73;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelInfoReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelInfoReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelObjectOwnersRequest packet</summary>
    public class ParcelObjectOwnersRequestPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelObjectOwnersRequest</summary>
        public override PacketType Type { get { return PacketType.ParcelObjectOwnersRequest; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelObjectOwnersRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 74;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelObjectOwnersRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelObjectOwnersRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>OnlineStatusRequest packet</summary>
    public class OnlineStatusRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SpaceIP field</summary>
            public uint SpaceIP;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 41;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SpaceIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SpaceIP % 256);
                bytes[i++] = (byte)((SpaceIP >> 8) % 256);
                bytes[i++] = (byte)((SpaceIP >> 16) % 256);
                bytes[i++] = (byte)((SpaceIP >> 24) % 256);
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.OnlineStatusRequest</summary>
        public override PacketType Type { get { return PacketType.OnlineStatusRequest; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public OnlineStatusRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 75;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public OnlineStatusRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public OnlineStatusRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>OnlineStatusReply packet</summary>
    public class OnlineStatusReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.OnlineStatusReply</summary>
        public override PacketType Type { get { return PacketType.OnlineStatusReply; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public OnlineStatusReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 76;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public OnlineStatusReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public OnlineStatusReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelObjectOwnersReply packet</summary>
    public class ParcelObjectOwnersReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>OnlineStatus field</summary>
            public bool OnlineStatus;
            /// <summary>IsGroupOwned field</summary>
            public bool IsGroupOwned;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>Count field</summary>
            public int Count;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 23;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    OnlineStatus = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    IsGroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    Count = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((OnlineStatus) ? 1 : 0);
                bytes[i++] = (byte)((IsGroupOwned) ? 1 : 0);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Count % 256);
                bytes[i++] = (byte)((Count >> 8) % 256);
                bytes[i++] = (byte)((Count >> 16) % 256);
                bytes[i++] = (byte)((Count >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelObjectOwnersReply</summary>
        public override PacketType Type { get { return PacketType.ParcelObjectOwnersReply; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;

        /// <summary>Default constructor</summary>
        public ParcelObjectOwnersReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 77;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelObjectOwnersReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelObjectOwnersReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupNoticesListRequest packet</summary>
    public class GroupNoticesListRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupNoticesListRequest</summary>
        public override PacketType Type { get { return PacketType.GroupNoticesListRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupNoticesListRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 78;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupNoticesListRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupNoticesListRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupNoticesListReply packet</summary>
    public class GroupNoticesListReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>Timestamp field</summary>
            public uint Timestamp;
            private byte[] _subject;
            /// <summary>Subject field</summary>
            public byte[] Subject
            {
                get { return _subject; }
                set
                {
                    if (value == null) { _subject = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _subject = new byte[value.Length]; Array.Copy(value, _subject, value.Length); }
                }
            }
            /// <summary>HasAttachment field</summary>
            public bool HasAttachment;
            /// <summary>NoticeID field</summary>
            public LLUUID NoticeID;
            private byte[] _fromname;
            /// <summary>FromName field</summary>
            public byte[] FromName
            {
                get { return _fromname; }
                set
                {
                    if (value == null) { _fromname = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _fromname = new byte[value.Length]; Array.Copy(value, _fromname, value.Length); }
                }
            }
            /// <summary>AssetType field</summary>
            public byte AssetType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 23;
                    if (Subject != null) { length += 2 + Subject.Length; }
                    if (FromName != null) { length += 2 + FromName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Timestamp = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _subject = new byte[length];
                    Array.Copy(bytes, i, _subject, 0, length); i += length;
                    HasAttachment = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    NoticeID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _fromname = new byte[length];
                    Array.Copy(bytes, i, _fromname, 0, length); i += length;
                    AssetType = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Timestamp % 256);
                bytes[i++] = (byte)((Timestamp >> 8) % 256);
                bytes[i++] = (byte)((Timestamp >> 16) % 256);
                bytes[i++] = (byte)((Timestamp >> 24) % 256);
                bytes[i++] = (byte)(Subject.Length % 256);
                bytes[i++] = (byte)((Subject.Length >> 8) % 256);
                Array.Copy(Subject, 0, bytes, i, Subject.Length); i += Subject.Length;
                bytes[i++] = (byte)((HasAttachment) ? 1 : 0);
                Array.Copy(NoticeID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(FromName.Length % 256);
                bytes[i++] = (byte)((FromName.Length >> 8) % 256);
                Array.Copy(FromName, 0, bytes, i, FromName.Length); i += FromName.Length;
                bytes[i++] = AssetType;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupNoticesListReply</summary>
        public override PacketType Type { get { return PacketType.GroupNoticesListReply; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupNoticesListReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 79;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupNoticesListReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupNoticesListReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupNoticeRequest packet</summary>
    public class GroupNoticeRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>GroupNoticeID field</summary>
            public LLUUID GroupNoticeID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupNoticeID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupNoticeID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupNoticeRequest</summary>
        public override PacketType Type { get { return PacketType.GroupNoticeRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupNoticeRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 80;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupNoticeRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupNoticeRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupNoticeAdd packet</summary>
    public class GroupNoticeAddPacket : Packet
    {
        /// <summary>MessageBlock block</summary>
        public class MessageBlockBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>Dialog field</summary>
            public byte Dialog;
            /// <summary>ToGroupID field</summary>
            public LLUUID ToGroupID;
            private byte[] _binarybucket;
            /// <summary>BinaryBucket field</summary>
            public byte[] BinaryBucket
            {
                get { return _binarybucket; }
                set
                {
                    if (value == null) { _binarybucket = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _binarybucket = new byte[value.Length]; Array.Copy(value, _binarybucket, value.Length); }
                }
            }
            private byte[] _fromagentname;
            /// <summary>FromAgentName field</summary>
            public byte[] FromAgentName
            {
                get { return _fromagentname; }
                set
                {
                    if (value == null) { _fromagentname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _fromagentname = new byte[value.Length]; Array.Copy(value, _fromagentname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    if (Message != null) { length += 2 + Message.Length; }
                    if (BinaryBucket != null) { length += 2 + BinaryBucket.Length; }
                    if (FromAgentName != null) { length += 1 + FromAgentName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MessageBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MessageBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    Dialog = (byte)bytes[i++];
                    ToGroupID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _binarybucket = new byte[length];
                    Array.Copy(bytes, i, _binarybucket, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _fromagentname = new byte[length];
                    Array.Copy(bytes, i, _fromagentname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = Dialog;
                Array.Copy(ToGroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(BinaryBucket.Length % 256);
                bytes[i++] = (byte)((BinaryBucket.Length >> 8) % 256);
                Array.Copy(BinaryBucket, 0, bytes, i, BinaryBucket.Length); i += BinaryBucket.Length;
                bytes[i++] = (byte)FromAgentName.Length;
                Array.Copy(FromAgentName, 0, bytes, i, FromAgentName.Length); i += FromAgentName.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupNoticeAdd</summary>
        public override PacketType Type { get { return PacketType.GroupNoticeAdd; } }
        /// <summary>MessageBlock block</summary>
        public MessageBlockBlock MessageBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupNoticeAddPacket()
        {
            Header = new LowHeader();
            Header.ID = 81;
            Header.Reliable = true;
            MessageBlock = new MessageBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupNoticeAddPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MessageBlock = new MessageBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupNoticeAddPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MessageBlock = new MessageBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MessageBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MessageBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupNoticeDelete packet</summary>
    public class GroupNoticeDeletePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>GroupNoticeID field</summary>
            public LLUUID GroupNoticeID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupNoticeID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupNoticeID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupNoticeDelete</summary>
        public override PacketType Type { get { return PacketType.GroupNoticeDelete; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupNoticeDeletePacket()
        {
            Header = new LowHeader();
            Header.ID = 82;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupNoticeDeletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupNoticeDeletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportRequest packet</summary>
    public class TeleportRequestPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 40;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionID = new LLUUID(bytes, i); i += 16;
                    LookAt = new LLVector3(bytes, i); i += 12;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportRequest</summary>
        public override PacketType Type { get { return PacketType.TeleportRequest; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public TeleportRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 83;
            Header.Reliable = true;
            Info = new InfoBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportLocationRequest packet</summary>
    public class TeleportLocationRequestPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LookAt = new LLVector3(bytes, i); i += 12;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportLocationRequest</summary>
        public override PacketType Type { get { return PacketType.TeleportLocationRequest; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public TeleportLocationRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 84;
            Header.Reliable = true;
            Info = new InfoBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportLocationRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportLocationRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportLocal packet</summary>
    public class TeleportLocalPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LookAt = new LLVector3(bytes, i); i += 12;
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportLocal</summary>
        public override PacketType Type { get { return PacketType.TeleportLocal; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public TeleportLocalPacket()
        {
            Header = new LowHeader();
            Header.ID = 85;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportLocalPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportLocalPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportLandmarkRequest packet</summary>
    public class TeleportLandmarkRequestPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>LandmarkID field</summary>
            public LLUUID LandmarkID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    LandmarkID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(LandmarkID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportLandmarkRequest</summary>
        public override PacketType Type { get { return PacketType.TeleportLandmarkRequest; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public TeleportLandmarkRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 86;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportLandmarkRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportLandmarkRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportProgress packet</summary>
    public class TeleportProgressPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportProgress</summary>
        public override PacketType Type { get { return PacketType.TeleportProgress; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public TeleportProgressPacket()
        {
            Header = new LowHeader();
            Header.ID = 87;
            Header.Reliable = true;
            Info = new InfoBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportProgressPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportProgressPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DataAgentAccessRequest packet</summary>
    public class DataAgentAccessRequestPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>LocationPos field</summary>
            public LLVector3 LocationPos;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>LocationLookAt field</summary>
            public LLVector3 LocationLookAt;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 56;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocationPos = new LLVector3(bytes, i); i += 12;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LocationLookAt = new LLVector3(bytes, i); i += 12;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(LocationPos.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                Array.Copy(LocationLookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DataAgentAccessRequest</summary>
        public override PacketType Type { get { return PacketType.DataAgentAccessRequest; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public DataAgentAccessRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 88;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DataAgentAccessRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DataAgentAccessRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DataAgentAccessReply packet</summary>
    public class DataAgentAccessReplyPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DataAgentAccessReply</summary>
        public override PacketType Type { get { return PacketType.DataAgentAccessReply; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public DataAgentAccessReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 89;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DataAgentAccessReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DataAgentAccessReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DataHomeLocationRequest packet</summary>
    public class DataHomeLocationRequestPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DataHomeLocationRequest</summary>
        public override PacketType Type { get { return PacketType.DataHomeLocationRequest; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public DataHomeLocationRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 90;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DataHomeLocationRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DataHomeLocationRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DataHomeLocationReply packet</summary>
    public class DataHomeLocationReplyPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LookAt = new LLVector3(bytes, i); i += 12;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DataHomeLocationReply</summary>
        public override PacketType Type { get { return PacketType.DataHomeLocationReply; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public DataHomeLocationReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 91;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DataHomeLocationReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DataHomeLocationReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SpaceLocationTeleportRequest packet</summary>
    public class SpaceLocationTeleportRequestPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>TravelAccess field</summary>
            public byte TravelAccess;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>ParentEstateID field</summary>
            public uint ParentEstateID;
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 77;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    TravelAccess = (byte)bytes[i++];
                    SessionID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LookAt = new LLVector3(bytes, i); i += 12;
                    ParentEstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = TravelAccess;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(ParentEstateID % 256);
                bytes[i++] = (byte)((ParentEstateID >> 8) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 16) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 24) % 256);
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SpaceLocationTeleportRequest</summary>
        public override PacketType Type { get { return PacketType.SpaceLocationTeleportRequest; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public SpaceLocationTeleportRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 92;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SpaceLocationTeleportRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SpaceLocationTeleportRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SpaceLocationTeleportReply packet</summary>
    public class SpaceLocationTeleportReplyPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SimPort field</summary>
            public ushort SimPort;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>SimIP field</summary>
            public uint SimIP;
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 63;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SimPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SimAccess = (byte)bytes[i++];
                    LookAt = new LLVector3(bytes, i); i += 12;
                    SimIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SimPort % 256);
                bytes[i++] = (byte)((SimPort >> 8) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                bytes[i++] = SimAccess;
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(SimIP % 256);
                bytes[i++] = (byte)((SimIP >> 8) % 256);
                bytes[i++] = (byte)((SimIP >> 16) % 256);
                bytes[i++] = (byte)((SimIP >> 24) % 256);
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SpaceLocationTeleportReply</summary>
        public override PacketType Type { get { return PacketType.SpaceLocationTeleportReply; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public SpaceLocationTeleportReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 93;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SpaceLocationTeleportReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SpaceLocationTeleportReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportFinish packet</summary>
    public class TeleportFinishPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            private byte[] _seedcapability;
            /// <summary>SeedCapability field</summary>
            public byte[] SeedCapability
            {
                get { return _seedcapability; }
                set
                {
                    if (value == null) { _seedcapability = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _seedcapability = new byte[value.Length]; Array.Copy(value, _seedcapability, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SimPort field</summary>
            public ushort SimPort;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>SimIP field</summary>
            public uint SimIP;
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 39;
                    if (SeedCapability != null) { length += 2 + SeedCapability.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _seedcapability = new byte[length];
                    Array.Copy(bytes, i, _seedcapability, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SimPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SimAccess = (byte)bytes[i++];
                    SimIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SeedCapability.Length % 256);
                bytes[i++] = (byte)((SeedCapability.Length >> 8) % 256);
                Array.Copy(SeedCapability, 0, bytes, i, SeedCapability.Length); i += SeedCapability.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SimPort % 256);
                bytes[i++] = (byte)((SimPort >> 8) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                bytes[i++] = SimAccess;
                bytes[i++] = (byte)(SimIP % 256);
                bytes[i++] = (byte)((SimIP >> 8) % 256);
                bytes[i++] = (byte)((SimIP >> 16) % 256);
                bytes[i++] = (byte)((SimIP >> 24) % 256);
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportFinish</summary>
        public override PacketType Type { get { return PacketType.TeleportFinish; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public TeleportFinishPacket()
        {
            Header = new LowHeader();
            Header.ID = 94;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportFinishPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportFinishPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartLure packet</summary>
    public class StartLurePacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;
            /// <summary>LureType field</summary>
            public byte LureType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    TargetID = new LLUUID(bytes, i); i += 16;
                    LureType = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = LureType;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartLure</summary>
        public override PacketType Type { get { return PacketType.StartLure; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public StartLurePacket()
        {
            Header = new LowHeader();
            Header.ID = 95;
            Header.Reliable = true;
            Info = new InfoBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartLurePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartLurePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportLureRequest packet</summary>
    public class TeleportLureRequestPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>LureID field</summary>
            public LLUUID LureID;
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 52;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    LureID = new LLUUID(bytes, i); i += 16;
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(LureID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportLureRequest</summary>
        public override PacketType Type { get { return PacketType.TeleportLureRequest; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public TeleportLureRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 96;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportLureRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportLureRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportCancel packet</summary>
    public class TeleportCancelPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportCancel</summary>
        public override PacketType Type { get { return PacketType.TeleportCancel; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public TeleportCancelPacket()
        {
            Header = new LowHeader();
            Header.ID = 97;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportCancelPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportCancelPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CompleteLure packet</summary>
    public class CompleteLurePacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>TravelAccess field</summary>
            public byte TravelAccess;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;
            /// <summary>LureID field</summary>
            public LLUUID LureID;
            /// <summary>ParentEstateID field</summary>
            public uint ParentEstateID;
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 61;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    TravelAccess = (byte)bytes[i++];
                    SessionID = new LLUUID(bytes, i); i += 16;
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LureID = new LLUUID(bytes, i); i += 16;
                    ParentEstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = TravelAccess;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
                Array.Copy(LureID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ParentEstateID % 256);
                bytes[i++] = (byte)((ParentEstateID >> 8) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 16) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 24) % 256);
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CompleteLure</summary>
        public override PacketType Type { get { return PacketType.CompleteLure; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public CompleteLurePacket()
        {
            Header = new LowHeader();
            Header.ID = 98;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CompleteLurePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CompleteLurePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportStart packet</summary>
    public class TeleportStartPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>TeleportFlags field</summary>
            public uint TeleportFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TeleportFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TeleportFlags % 256);
                bytes[i++] = (byte)((TeleportFlags >> 8) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 16) % 256);
                bytes[i++] = (byte)((TeleportFlags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportStart</summary>
        public override PacketType Type { get { return PacketType.TeleportStart; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public TeleportStartPacket()
        {
            Header = new LowHeader();
            Header.ID = 99;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportStartPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportStartPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportFailed packet</summary>
    public class TeleportFailedPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _reason;
            /// <summary>Reason field</summary>
            public byte[] Reason
            {
                get { return _reason; }
                set
                {
                    if (value == null) { _reason = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _reason = new byte[value.Length]; Array.Copy(value, _reason, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Reason != null) { length += 1 + Reason.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _reason = new byte[length];
                    Array.Copy(bytes, i, _reason, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Reason.Length;
                Array.Copy(Reason, 0, bytes, i, Reason.Length); i += Reason.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportFailed</summary>
        public override PacketType Type { get { return PacketType.TeleportFailed; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;

        /// <summary>Default constructor</summary>
        public TeleportFailedPacket()
        {
            Header = new LowHeader();
            Header.ID = 100;
            Header.Reliable = true;
            Info = new InfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportFailedPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportFailedPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Info.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LeaderBoardRequest packet</summary>
    public class LeaderBoardRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Type field</summary>
            public int Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LeaderBoardRequest</summary>
        public override PacketType Type { get { return PacketType.LeaderBoardRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public LeaderBoardRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 101;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LeaderBoardRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LeaderBoardRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LeaderBoardData packet</summary>
    public class LeaderBoardDataPacket : Packet
    {
        /// <summary>BoardData block</summary>
        public class BoardDataBlock
        {
            private byte[] _timestring;
            /// <summary>TimeString field</summary>
            public byte[] TimeString
            {
                get { return _timestring; }
                set
                {
                    if (value == null) { _timestring = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _timestring = new byte[value.Length]; Array.Copy(value, _timestring, value.Length); }
                }
            }
            /// <summary>MaxPlace field</summary>
            public int MaxPlace;
            /// <summary>MinPlace field</summary>
            public int MinPlace;
            /// <summary>Type field</summary>
            public int Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    if (TimeString != null) { length += 1 + TimeString.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public BoardDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public BoardDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _timestring = new byte[length];
                    Array.Copy(bytes, i, _timestring, 0, length); i += length;
                    MaxPlace = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MinPlace = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)TimeString.Length;
                Array.Copy(TimeString, 0, bytes, i, TimeString.Length); i += TimeString.Length;
                bytes[i++] = (byte)(MaxPlace % 256);
                bytes[i++] = (byte)((MaxPlace >> 8) % 256);
                bytes[i++] = (byte)((MaxPlace >> 16) % 256);
                bytes[i++] = (byte)((MaxPlace >> 24) % 256);
                bytes[i++] = (byte)(MinPlace % 256);
                bytes[i++] = (byte)((MinPlace >> 8) % 256);
                bytes[i++] = (byte)((MinPlace >> 16) % 256);
                bytes[i++] = (byte)((MinPlace >> 24) % 256);
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
            }
        }

        /// <summary>Entry block</summary>
        public class EntryBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Name field</summary>
            public byte[] Name;
            /// <summary>Sequence field</summary>
            public int Sequence;
            /// <summary>Place field</summary>
            public int Place;
            /// <summary>Score field</summary>
            public int Score;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 61;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EntryBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EntryBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    Name = new byte[32];
                    Array.Copy(bytes, i, Name, 0, 32); i += 32;
                    Sequence = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Place = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Score = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Name, 0, bytes, i, 32);i += 32;
                bytes[i++] = (byte)(Sequence % 256);
                bytes[i++] = (byte)((Sequence >> 8) % 256);
                bytes[i++] = (byte)((Sequence >> 16) % 256);
                bytes[i++] = (byte)((Sequence >> 24) % 256);
                bytes[i++] = (byte)(Place % 256);
                bytes[i++] = (byte)((Place >> 8) % 256);
                bytes[i++] = (byte)((Place >> 16) % 256);
                bytes[i++] = (byte)((Place >> 24) % 256);
                bytes[i++] = (byte)(Score % 256);
                bytes[i++] = (byte)((Score >> 8) % 256);
                bytes[i++] = (byte)((Score >> 16) % 256);
                bytes[i++] = (byte)((Score >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LeaderBoardData</summary>
        public override PacketType Type { get { return PacketType.LeaderBoardData; } }
        /// <summary>BoardData block</summary>
        public BoardDataBlock BoardData;
        /// <summary>Entry block</summary>
        public EntryBlock[] Entry;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public LeaderBoardDataPacket()
        {
            Header = new LowHeader();
            Header.ID = 102;
            Header.Reliable = true;
            Header.Zerocoded = true;
            BoardData = new BoardDataBlock();
            Entry = new EntryBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LeaderBoardDataPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            BoardData = new BoardDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Entry = new EntryBlock[count];
            for (int j = 0; j < count; j++)
            { Entry[j] = new EntryBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LeaderBoardDataPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            BoardData = new BoardDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Entry = new EntryBlock[count];
            for (int j = 0; j < count; j++)
            { Entry[j] = new EntryBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += BoardData.Length;            length += AgentData.Length;;
            for (int j = 0; j < Entry.Length; j++) { length += Entry[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            BoardData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Entry.Length;
            for (int j = 0; j < Entry.Length; j++) { Entry[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegisterNewAgent packet</summary>
    public class RegisterNewAgentPacket : Packet
    {
        /// <summary>HelloBlock block</summary>
        public class HelloBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>LocationID field</summary>
            public uint LocationID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 37;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HelloBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HelloBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegisterNewAgent</summary>
        public override PacketType Type { get { return PacketType.RegisterNewAgent; } }
        /// <summary>HelloBlock block</summary>
        public HelloBlockBlock HelloBlock;

        /// <summary>Default constructor</summary>
        public RegisterNewAgentPacket()
        {
            Header = new LowHeader();
            Header.ID = 103;
            Header.Reliable = true;
            HelloBlock = new HelloBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegisterNewAgentPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            HelloBlock = new HelloBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegisterNewAgentPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            HelloBlock = new HelloBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += HelloBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            HelloBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>Undo packet</summary>
    public class UndoPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.Undo</summary>
        public override PacketType Type { get { return PacketType.Undo; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UndoPacket()
        {
            Header = new LowHeader();
            Header.ID = 104;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UndoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UndoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>Redo packet</summary>
    public class RedoPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.Redo</summary>
        public override PacketType Type { get { return PacketType.Redo; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RedoPacket()
        {
            Header = new LowHeader();
            Header.ID = 105;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RedoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RedoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UndoLand packet</summary>
    public class UndoLandPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UndoLand</summary>
        public override PacketType Type { get { return PacketType.UndoLand; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UndoLandPacket()
        {
            Header = new LowHeader();
            Header.ID = 106;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UndoLandPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UndoLandPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RedoLand packet</summary>
    public class RedoLandPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RedoLand</summary>
        public override PacketType Type { get { return PacketType.RedoLand; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RedoLandPacket()
        {
            Header = new LowHeader();
            Header.ID = 107;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RedoLandPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RedoLandPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentPause packet</summary>
    public class AgentPausePacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>SerialNum field</summary>
            public uint SerialNum;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SerialNum = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SerialNum % 256);
                bytes[i++] = (byte)((SerialNum >> 8) % 256);
                bytes[i++] = (byte)((SerialNum >> 16) % 256);
                bytes[i++] = (byte)((SerialNum >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentPause</summary>
        public override PacketType Type { get { return PacketType.AgentPause; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public AgentPausePacket()
        {
            Header = new LowHeader();
            Header.ID = 108;
            Header.Reliable = true;
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentPausePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentPausePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentResume packet</summary>
    public class AgentResumePacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>SerialNum field</summary>
            public uint SerialNum;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SerialNum = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SerialNum % 256);
                bytes[i++] = (byte)((SerialNum >> 8) % 256);
                bytes[i++] = (byte)((SerialNum >> 16) % 256);
                bytes[i++] = (byte)((SerialNum >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentResume</summary>
        public override PacketType Type { get { return PacketType.AgentResume; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public AgentResumePacket()
        {
            Header = new LowHeader();
            Header.ID = 109;
            Header.Reliable = true;
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentResumePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentResumePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChatFromViewer packet</summary>
    public class ChatFromViewerPacket : Packet
    {
        /// <summary>ChatData block</summary>
        public class ChatDataBlock
        {
            /// <summary>Channel field</summary>
            public int Channel;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>Type field</summary>
            public byte Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (Message != null) { length += 2 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ChatDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ChatDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Channel = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    Type = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Channel % 256);
                bytes[i++] = (byte)((Channel >> 8) % 256);
                bytes[i++] = (byte)((Channel >> 16) % 256);
                bytes[i++] = (byte)((Channel >> 24) % 256);
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = Type;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChatFromViewer</summary>
        public override PacketType Type { get { return PacketType.ChatFromViewer; } }
        /// <summary>ChatData block</summary>
        public ChatDataBlock ChatData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ChatFromViewerPacket()
        {
            Header = new LowHeader();
            Header.ID = 110;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ChatData = new ChatDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChatFromViewerPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ChatData = new ChatDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChatFromViewerPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ChatData = new ChatDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ChatData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ChatData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentThrottle packet</summary>
    public class AgentThrottlePacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>GenCounter field</summary>
            public uint GenCounter;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    GenCounter = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(GenCounter % 256);
                bytes[i++] = (byte)((GenCounter >> 8) % 256);
                bytes[i++] = (byte)((GenCounter >> 16) % 256);
                bytes[i++] = (byte)((GenCounter >> 24) % 256);
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
            }
        }

        /// <summary>Throttle block</summary>
        public class ThrottleBlock
        {
            private byte[] _throttles;
            /// <summary>Throttles field</summary>
            public byte[] Throttles
            {
                get { return _throttles; }
                set
                {
                    if (value == null) { _throttles = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _throttles = new byte[value.Length]; Array.Copy(value, _throttles, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Throttles != null) { length += 1 + Throttles.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ThrottleBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ThrottleBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _throttles = new byte[length];
                    Array.Copy(bytes, i, _throttles, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Throttles.Length;
                Array.Copy(Throttles, 0, bytes, i, Throttles.Length); i += Throttles.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentThrottle</summary>
        public override PacketType Type { get { return PacketType.AgentThrottle; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;
        /// <summary>Throttle block</summary>
        public ThrottleBlock Throttle;

        /// <summary>Default constructor</summary>
        public AgentThrottlePacket()
        {
            Header = new LowHeader();
            Header.ID = 111;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Sender = new SenderBlock();
            Throttle = new ThrottleBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentThrottlePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
            Throttle = new ThrottleBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentThrottlePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
            Throttle = new ThrottleBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Sender.Length;            length += Throttle.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            Throttle.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentFOV packet</summary>
    public class AgentFOVPacket : Packet
    {
        /// <summary>FOVBlock block</summary>
        public class FOVBlockBlock
        {
            /// <summary>VerticalAngle field</summary>
            public float VerticalAngle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FOVBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FOVBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    VerticalAngle = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(VerticalAngle);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>GenCounter field</summary>
            public uint GenCounter;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    GenCounter = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(GenCounter % 256);
                bytes[i++] = (byte)((GenCounter >> 8) % 256);
                bytes[i++] = (byte)((GenCounter >> 16) % 256);
                bytes[i++] = (byte)((GenCounter >> 24) % 256);
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentFOV</summary>
        public override PacketType Type { get { return PacketType.AgentFOV; } }
        /// <summary>FOVBlock block</summary>
        public FOVBlockBlock FOVBlock;
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public AgentFOVPacket()
        {
            Header = new LowHeader();
            Header.ID = 112;
            Header.Reliable = true;
            FOVBlock = new FOVBlockBlock();
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentFOVPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            FOVBlock = new FOVBlockBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentFOVPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            FOVBlock = new FOVBlockBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += FOVBlock.Length;            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            FOVBlock.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentHeightWidth packet</summary>
    public class AgentHeightWidthPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>GenCounter field</summary>
            public uint GenCounter;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    GenCounter = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(GenCounter % 256);
                bytes[i++] = (byte)((GenCounter >> 8) % 256);
                bytes[i++] = (byte)((GenCounter >> 16) % 256);
                bytes[i++] = (byte)((GenCounter >> 24) % 256);
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
            }
        }

        /// <summary>HeightWidthBlock block</summary>
        public class HeightWidthBlockBlock
        {
            /// <summary>Height field</summary>
            public ushort Height;
            /// <summary>Width field</summary>
            public ushort Width;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HeightWidthBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HeightWidthBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Height = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Width = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Height % 256);
                bytes[i++] = (byte)((Height >> 8) % 256);
                bytes[i++] = (byte)(Width % 256);
                bytes[i++] = (byte)((Width >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentHeightWidth</summary>
        public override PacketType Type { get { return PacketType.AgentHeightWidth; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;
        /// <summary>HeightWidthBlock block</summary>
        public HeightWidthBlockBlock HeightWidthBlock;

        /// <summary>Default constructor</summary>
        public AgentHeightWidthPacket()
        {
            Header = new LowHeader();
            Header.ID = 113;
            Header.Reliable = true;
            Sender = new SenderBlock();
            HeightWidthBlock = new HeightWidthBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentHeightWidthPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
            HeightWidthBlock = new HeightWidthBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentHeightWidthPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
            HeightWidthBlock = new HeightWidthBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Sender.Length;            length += HeightWidthBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            HeightWidthBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentSetAppearance packet</summary>
    public class AgentSetAppearancePacket : Packet
    {
        /// <summary>VisualParam block</summary>
        public class VisualParamBlock
        {
            /// <summary>ParamValue field</summary>
            public byte ParamValue;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public VisualParamBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public VisualParamBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParamValue = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ParamValue;
            }
        }

        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            private byte[] _textureentry;
            /// <summary>TextureEntry field</summary>
            public byte[] TextureEntry
            {
                get { return _textureentry; }
                set
                {
                    if (value == null) { _textureentry = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _textureentry = new byte[value.Length]; Array.Copy(value, _textureentry, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (TextureEntry != null) { length += 2 + TextureEntry.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _textureentry = new byte[length];
                    Array.Copy(bytes, i, _textureentry, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TextureEntry.Length % 256);
                bytes[i++] = (byte)((TextureEntry.Length >> 8) % 256);
                Array.Copy(TextureEntry, 0, bytes, i, TextureEntry.Length); i += TextureEntry.Length;
            }
        }

        /// <summary>WearableData block</summary>
        public class WearableDataBlock
        {
            /// <summary>TextureIndex field</summary>
            public byte TextureIndex;
            /// <summary>CacheID field</summary>
            public LLUUID CacheID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public WearableDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public WearableDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TextureIndex = (byte)bytes[i++];
                    CacheID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = TextureIndex;
                Array.Copy(CacheID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>SerialNum field</summary>
            public uint SerialNum;
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Size field</summary>
            public LLVector3 Size;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SerialNum = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ID = new LLUUID(bytes, i); i += 16;
                    Size = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SerialNum % 256);
                bytes[i++] = (byte)((SerialNum >> 8) % 256);
                bytes[i++] = (byte)((SerialNum >> 16) % 256);
                bytes[i++] = (byte)((SerialNum >> 24) % 256);
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Size.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentSetAppearance</summary>
        public override PacketType Type { get { return PacketType.AgentSetAppearance; } }
        /// <summary>VisualParam block</summary>
        public VisualParamBlock[] VisualParam;
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>WearableData block</summary>
        public WearableDataBlock[] WearableData;
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public AgentSetAppearancePacket()
        {
            Header = new LowHeader();
            Header.ID = 114;
            Header.Reliable = true;
            Header.Zerocoded = true;
            VisualParam = new VisualParamBlock[0];
            ObjectData = new ObjectDataBlock();
            WearableData = new WearableDataBlock[0];
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentSetAppearancePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            VisualParam = new VisualParamBlock[count];
            for (int j = 0; j < count; j++)
            { VisualParam[j] = new VisualParamBlock(bytes, ref i); }
            ObjectData = new ObjectDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentSetAppearancePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            VisualParam = new VisualParamBlock[count];
            for (int j = 0; j < count; j++)
            { VisualParam[j] = new VisualParamBlock(bytes, ref i); }
            ObjectData = new ObjectDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += Sender.Length;;
            for (int j = 0; j < VisualParam.Length; j++) { length += VisualParam[j].Length; }
            for (int j = 0; j < WearableData.Length; j++) { length += WearableData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)VisualParam.Length;
            for (int j = 0; j < VisualParam.Length; j++) { VisualParam[j].ToBytes(bytes, ref i); }
            ObjectData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)WearableData.Length;
            for (int j = 0; j < WearableData.Length; j++) { WearableData[j].ToBytes(bytes, ref i); }
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RefreshViewer packet</summary>
    public class RefreshViewerPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RefreshViewer</summary>
        public override PacketType Type { get { return PacketType.RefreshViewer; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public RefreshViewerPacket()
        {
            Header = new LowHeader();
            Header.ID = 115;
            Header.Reliable = true;
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RefreshViewerPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RefreshViewerPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentQuit packet</summary>
    public class AgentQuitPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentQuit</summary>
        public override PacketType Type { get { return PacketType.AgentQuit; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentQuitPacket()
        {
            Header = new LowHeader();
            Header.ID = 116;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentQuitPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentQuitPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentQuitCopy packet</summary>
    public class AgentQuitCopyPacket : Packet
    {
        /// <summary>FuseBlock block</summary>
        public class FuseBlockBlock
        {
            /// <summary>ViewerCircuitCode field</summary>
            public uint ViewerCircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FuseBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FuseBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ViewerCircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ViewerCircuitCode % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 8) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 16) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentQuitCopy</summary>
        public override PacketType Type { get { return PacketType.AgentQuitCopy; } }
        /// <summary>FuseBlock block</summary>
        public FuseBlockBlock FuseBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentQuitCopyPacket()
        {
            Header = new LowHeader();
            Header.ID = 117;
            Header.Reliable = true;
            FuseBlock = new FuseBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentQuitCopyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            FuseBlock = new FuseBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentQuitCopyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            FuseBlock = new FuseBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += FuseBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            FuseBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ImageNotInDatabase packet</summary>
    public class ImageNotInDatabasePacket : Packet
    {
        /// <summary>ImageID block</summary>
        public class ImageIDBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ImageIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ImageIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ImageNotInDatabase</summary>
        public override PacketType Type { get { return PacketType.ImageNotInDatabase; } }
        /// <summary>ImageID block</summary>
        public ImageIDBlock ImageID;

        /// <summary>Default constructor</summary>
        public ImageNotInDatabasePacket()
        {
            Header = new LowHeader();
            Header.ID = 118;
            Header.Reliable = true;
            ImageID = new ImageIDBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ImageNotInDatabasePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ImageID = new ImageIDBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ImageNotInDatabasePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ImageID = new ImageIDBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ImageID.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ImageID.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RebakeAvatarTextures packet</summary>
    public class RebakeAvatarTexturesPacket : Packet
    {
        /// <summary>TextureData block</summary>
        public class TextureDataBlock
        {
            /// <summary>TextureID field</summary>
            public LLUUID TextureID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TextureDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TextureDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TextureID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TextureID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RebakeAvatarTextures</summary>
        public override PacketType Type { get { return PacketType.RebakeAvatarTextures; } }
        /// <summary>TextureData block</summary>
        public TextureDataBlock TextureData;

        /// <summary>Default constructor</summary>
        public RebakeAvatarTexturesPacket()
        {
            Header = new LowHeader();
            Header.ID = 119;
            Header.Reliable = true;
            TextureData = new TextureDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RebakeAvatarTexturesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TextureData = new TextureDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RebakeAvatarTexturesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TextureData = new TextureDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TextureData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TextureData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetAlwaysRun packet</summary>
    public class SetAlwaysRunPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>AlwaysRun field</summary>
            public bool AlwaysRun;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    AlwaysRun = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AlwaysRun) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetAlwaysRun</summary>
        public override PacketType Type { get { return PacketType.SetAlwaysRun; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public SetAlwaysRunPacket()
        {
            Header = new LowHeader();
            Header.ID = 120;
            Header.Reliable = true;
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetAlwaysRunPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetAlwaysRunPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDelete packet</summary>
    public class ObjectDeletePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Force field</summary>
            public bool Force;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    Force = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Force) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDelete</summary>
        public override PacketType Type { get { return PacketType.ObjectDelete; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDeletePacket()
        {
            Header = new LowHeader();
            Header.ID = 121;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDeletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDeletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDuplicate packet</summary>
    public class ObjectDuplicatePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>SharedData block</summary>
        public class SharedDataBlock
        {
            /// <summary>DuplicateFlags field</summary>
            public uint DuplicateFlags;
            /// <summary>Offset field</summary>
            public LLVector3 Offset;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SharedDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SharedDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    DuplicateFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Offset = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(DuplicateFlags % 256);
                bytes[i++] = (byte)((DuplicateFlags >> 8) % 256);
                bytes[i++] = (byte)((DuplicateFlags >> 16) % 256);
                bytes[i++] = (byte)((DuplicateFlags >> 24) % 256);
                Array.Copy(Offset.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDuplicate</summary>
        public override PacketType Type { get { return PacketType.ObjectDuplicate; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>SharedData block</summary>
        public SharedDataBlock SharedData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDuplicatePacket()
        {
            Header = new LowHeader();
            Header.ID = 122;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            SharedData = new SharedDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDuplicatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            SharedData = new SharedDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDuplicatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            SharedData = new SharedDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SharedData.Length;            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            SharedData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDuplicateOnRay packet</summary>
    public class ObjectDuplicateOnRayPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>DuplicateFlags field</summary>
            public uint DuplicateFlags;
            /// <summary>CopyRotates field</summary>
            public bool CopyRotates;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>RayStart field</summary>
            public LLVector3 RayStart;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>RayEndIsIntersection field</summary>
            public bool RayEndIsIntersection;
            /// <summary>RayEnd field</summary>
            public LLVector3 RayEnd;
            /// <summary>BypassRaycast field</summary>
            public bool BypassRaycast;
            /// <summary>CopyCenters field</summary>
            public bool CopyCenters;
            /// <summary>RayTargetID field</summary>
            public LLUUID RayTargetID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 96;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    DuplicateFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CopyRotates = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    RayStart = new LLVector3(bytes, i); i += 12;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    RayEndIsIntersection = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RayEnd = new LLVector3(bytes, i); i += 12;
                    BypassRaycast = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CopyCenters = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RayTargetID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(DuplicateFlags % 256);
                bytes[i++] = (byte)((DuplicateFlags >> 8) % 256);
                bytes[i++] = (byte)((DuplicateFlags >> 16) % 256);
                bytes[i++] = (byte)((DuplicateFlags >> 24) % 256);
                bytes[i++] = (byte)((CopyRotates) ? 1 : 0);
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RayStart.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((RayEndIsIntersection) ? 1 : 0);
                Array.Copy(RayEnd.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)((BypassRaycast) ? 1 : 0);
                bytes[i++] = (byte)((CopyCenters) ? 1 : 0);
                Array.Copy(RayTargetID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDuplicateOnRay</summary>
        public override PacketType Type { get { return PacketType.ObjectDuplicateOnRay; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDuplicateOnRayPacket()
        {
            Header = new LowHeader();
            Header.ID = 123;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDuplicateOnRayPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDuplicateOnRayPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectScale packet</summary>
    public class ObjectScalePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            /// <summary>Scale field</summary>
            public LLVector3 Scale;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Scale = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                Array.Copy(Scale.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectScale</summary>
        public override PacketType Type { get { return PacketType.ObjectScale; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectScalePacket()
        {
            Header = new LowHeader();
            Header.ID = 124;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectScalePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectScalePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectRotation packet</summary>
    public class ObjectRotationPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            /// <summary>Rotation field</summary>
            public LLQuaternion Rotation;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Rotation = new LLQuaternion(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                Array.Copy(Rotation.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectRotation</summary>
        public override PacketType Type { get { return PacketType.ObjectRotation; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectRotationPacket()
        {
            Header = new LowHeader();
            Header.ID = 125;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectRotationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectRotationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectFlagUpdate packet</summary>
    public class ObjectFlagUpdatePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>IsTemporary field</summary>
            public bool IsTemporary;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            /// <summary>UsePhysics field</summary>
            public bool UsePhysics;
            /// <summary>CastsShadows field</summary>
            public bool CastsShadows;
            /// <summary>IsPhantom field</summary>
            public bool IsPhantom;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 40;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    IsTemporary = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    UsePhysics = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CastsShadows = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    IsPhantom = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((IsTemporary) ? 1 : 0);
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                bytes[i++] = (byte)((UsePhysics) ? 1 : 0);
                bytes[i++] = (byte)((CastsShadows) ? 1 : 0);
                bytes[i++] = (byte)((IsPhantom) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectFlagUpdate</summary>
        public override PacketType Type { get { return PacketType.ObjectFlagUpdate; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectFlagUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 126;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectFlagUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectFlagUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectClickAction packet</summary>
    public class ObjectClickActionPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ClickAction field</summary>
            public byte ClickAction;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ClickAction = (byte)bytes[i++];
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ClickAction;
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectClickAction</summary>
        public override PacketType Type { get { return PacketType.ObjectClickAction; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectClickActionPacket()
        {
            Header = new LowHeader();
            Header.ID = 127;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectClickActionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectClickActionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectImage packet</summary>
    public class ObjectImagePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            private byte[] _mediaurl;
            /// <summary>MediaURL field</summary>
            public byte[] MediaURL
            {
                get { return _mediaurl; }
                set
                {
                    if (value == null) { _mediaurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mediaurl = new byte[value.Length]; Array.Copy(value, _mediaurl, value.Length); }
                }
            }
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            private byte[] _textureentry;
            /// <summary>TextureEntry field</summary>
            public byte[] TextureEntry
            {
                get { return _textureentry; }
                set
                {
                    if (value == null) { _textureentry = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _textureentry = new byte[value.Length]; Array.Copy(value, _textureentry, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (MediaURL != null) { length += 1 + MediaURL.Length; }
                    if (TextureEntry != null) { length += 2 + TextureEntry.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _mediaurl = new byte[length];
                    Array.Copy(bytes, i, _mediaurl, 0, length); i += length;
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _textureentry = new byte[length];
                    Array.Copy(bytes, i, _textureentry, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)MediaURL.Length;
                Array.Copy(MediaURL, 0, bytes, i, MediaURL.Length); i += MediaURL.Length;
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                bytes[i++] = (byte)(TextureEntry.Length % 256);
                bytes[i++] = (byte)((TextureEntry.Length >> 8) % 256);
                Array.Copy(TextureEntry, 0, bytes, i, TextureEntry.Length); i += TextureEntry.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectImage</summary>
        public override PacketType Type { get { return PacketType.ObjectImage; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectImagePacket()
        {
            Header = new LowHeader();
            Header.ID = 128;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectImagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectImagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectMaterial packet</summary>
    public class ObjectMaterialPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>Material field</summary>
            public byte Material;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Material = (byte)bytes[i++];
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = Material;
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectMaterial</summary>
        public override PacketType Type { get { return PacketType.ObjectMaterial; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectMaterialPacket()
        {
            Header = new LowHeader();
            Header.ID = 129;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectMaterialPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectMaterialPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectShape packet</summary>
    public class ObjectShapePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>PathTwistBegin field</summary>
            public sbyte PathTwistBegin;
            /// <summary>PathEnd field</summary>
            public byte PathEnd;
            /// <summary>ProfileBegin field</summary>
            public byte ProfileBegin;
            /// <summary>PathRadiusOffset field</summary>
            public sbyte PathRadiusOffset;
            /// <summary>PathSkew field</summary>
            public sbyte PathSkew;
            /// <summary>ProfileCurve field</summary>
            public byte ProfileCurve;
            /// <summary>PathScaleX field</summary>
            public byte PathScaleX;
            /// <summary>PathScaleY field</summary>
            public byte PathScaleY;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            /// <summary>PathShearX field</summary>
            public byte PathShearX;
            /// <summary>PathShearY field</summary>
            public byte PathShearY;
            /// <summary>PathTaperX field</summary>
            public sbyte PathTaperX;
            /// <summary>PathTaperY field</summary>
            public sbyte PathTaperY;
            /// <summary>ProfileEnd field</summary>
            public byte ProfileEnd;
            /// <summary>PathBegin field</summary>
            public byte PathBegin;
            /// <summary>PathCurve field</summary>
            public byte PathCurve;
            /// <summary>PathTwist field</summary>
            public sbyte PathTwist;
            /// <summary>ProfileHollow field</summary>
            public byte ProfileHollow;
            /// <summary>PathRevolutions field</summary>
            public byte PathRevolutions;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 23;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PathTwistBegin = (sbyte)bytes[i++];
                    PathEnd = (byte)bytes[i++];
                    ProfileBegin = (byte)bytes[i++];
                    PathRadiusOffset = (sbyte)bytes[i++];
                    PathSkew = (sbyte)bytes[i++];
                    ProfileCurve = (byte)bytes[i++];
                    PathScaleX = (byte)bytes[i++];
                    PathScaleY = (byte)bytes[i++];
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PathShearX = (byte)bytes[i++];
                    PathShearY = (byte)bytes[i++];
                    PathTaperX = (sbyte)bytes[i++];
                    PathTaperY = (sbyte)bytes[i++];
                    ProfileEnd = (byte)bytes[i++];
                    PathBegin = (byte)bytes[i++];
                    PathCurve = (byte)bytes[i++];
                    PathTwist = (sbyte)bytes[i++];
                    ProfileHollow = (byte)bytes[i++];
                    PathRevolutions = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)PathTwistBegin;
                bytes[i++] = PathEnd;
                bytes[i++] = ProfileBegin;
                bytes[i++] = (byte)PathRadiusOffset;
                bytes[i++] = (byte)PathSkew;
                bytes[i++] = ProfileCurve;
                bytes[i++] = PathScaleX;
                bytes[i++] = PathScaleY;
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                bytes[i++] = PathShearX;
                bytes[i++] = PathShearY;
                bytes[i++] = (byte)PathTaperX;
                bytes[i++] = (byte)PathTaperY;
                bytes[i++] = ProfileEnd;
                bytes[i++] = PathBegin;
                bytes[i++] = PathCurve;
                bytes[i++] = (byte)PathTwist;
                bytes[i++] = ProfileHollow;
                bytes[i++] = PathRevolutions;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectShape</summary>
        public override PacketType Type { get { return PacketType.ObjectShape; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectShapePacket()
        {
            Header = new LowHeader();
            Header.ID = 130;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectShapePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectShapePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectExtraParams packet</summary>
    public class ObjectExtraParamsPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ParamInUse field</summary>
            public bool ParamInUse;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            private byte[] _paramdata;
            /// <summary>ParamData field</summary>
            public byte[] ParamData
            {
                get { return _paramdata; }
                set
                {
                    if (value == null) { _paramdata = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _paramdata = new byte[value.Length]; Array.Copy(value, _paramdata, value.Length); }
                }
            }
            /// <summary>ParamSize field</summary>
            public uint ParamSize;
            /// <summary>ParamType field</summary>
            public ushort ParamType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    if (ParamData != null) { length += 1 + ParamData.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ParamInUse = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _paramdata = new byte[length];
                    Array.Copy(bytes, i, _paramdata, 0, length); i += length;
                    ParamSize = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParamType = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((ParamInUse) ? 1 : 0);
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                bytes[i++] = (byte)ParamData.Length;
                Array.Copy(ParamData, 0, bytes, i, ParamData.Length); i += ParamData.Length;
                bytes[i++] = (byte)(ParamSize % 256);
                bytes[i++] = (byte)((ParamSize >> 8) % 256);
                bytes[i++] = (byte)((ParamSize >> 16) % 256);
                bytes[i++] = (byte)((ParamSize >> 24) % 256);
                bytes[i++] = (byte)(ParamType % 256);
                bytes[i++] = (byte)((ParamType >> 8) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectExtraParams</summary>
        public override PacketType Type { get { return PacketType.ObjectExtraParams; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectExtraParamsPacket()
        {
            Header = new LowHeader();
            Header.ID = 131;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectExtraParamsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectExtraParamsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectOwner packet</summary>
    public class ObjectOwnerPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>HeaderData block</summary>
        public class HeaderDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>Override field</summary>
            public bool Override;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HeaderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HeaderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    Override = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Override) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectOwner</summary>
        public override PacketType Type { get { return PacketType.ObjectOwner; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>HeaderData block</summary>
        public HeaderDataBlock HeaderData;

        /// <summary>Default constructor</summary>
        public ObjectOwnerPacket()
        {
            Header = new LowHeader();
            Header.ID = 132;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
            HeaderData = new HeaderDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectOwnerPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectOwnerPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += HeaderData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            HeaderData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectGroup packet</summary>
    public class ObjectGroupPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectGroup</summary>
        public override PacketType Type { get { return PacketType.ObjectGroup; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectGroupPacket()
        {
            Header = new LowHeader();
            Header.ID = 133;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectGroupPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectGroupPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectBuy packet</summary>
    public class ObjectBuyPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 10;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SaleType = (byte)bytes[i++];
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>CategoryID field</summary>
            public LLUUID CategoryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 64;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    CategoryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CategoryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectBuy</summary>
        public override PacketType Type { get { return PacketType.ObjectBuy; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectBuyPacket()
        {
            Header = new LowHeader();
            Header.ID = 134;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectBuyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectBuyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>BuyObjectInventory packet</summary>
    public class BuyObjectInventoryPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.BuyObjectInventory</summary>
        public override PacketType Type { get { return PacketType.BuyObjectInventory; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public BuyObjectInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 135;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public BuyObjectInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public BuyObjectInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DerezContainer packet</summary>
    public class DerezContainerPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Delete field</summary>
            public bool Delete;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    Delete = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Delete) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DerezContainer</summary>
        public override PacketType Type { get { return PacketType.DerezContainer; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public DerezContainerPacket()
        {
            Header = new LowHeader();
            Header.ID = 136;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DerezContainerPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DerezContainerPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectPermissions packet</summary>
    public class ObjectPermissionsPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>Set field</summary>
            public byte Set;
            /// <summary>Mask field</summary>
            public uint Mask;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            /// <summary>Field field</summary>
            public byte Field;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 11;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Set = (byte)bytes[i++];
                    Mask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Field = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = Set;
                bytes[i++] = (byte)(Mask % 256);
                bytes[i++] = (byte)((Mask >> 8) % 256);
                bytes[i++] = (byte)((Mask >> 16) % 256);
                bytes[i++] = (byte)((Mask >> 24) % 256);
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                bytes[i++] = Field;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>HeaderData block</summary>
        public class HeaderDataBlock
        {
            /// <summary>Override field</summary>
            public bool Override;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HeaderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HeaderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Override = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Override) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectPermissions</summary>
        public override PacketType Type { get { return PacketType.ObjectPermissions; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>HeaderData block</summary>
        public HeaderDataBlock HeaderData;

        /// <summary>Default constructor</summary>
        public ObjectPermissionsPacket()
        {
            Header = new LowHeader();
            Header.ID = 137;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
            HeaderData = new HeaderDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectPermissionsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectPermissionsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += HeaderData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            HeaderData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectSaleInfo packet</summary>
    public class ObjectSaleInfoPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>SalePrice field</summary>
            public int SalePrice;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 10;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectSaleInfo</summary>
        public override PacketType Type { get { return PacketType.ObjectSaleInfo; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectSaleInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 138;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectSaleInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectSaleInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectName packet</summary>
    public class ObjectNamePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectName</summary>
        public override PacketType Type { get { return PacketType.ObjectName; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectNamePacket()
        {
            Header = new LowHeader();
            Header.ID = 139;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectNamePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectNamePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDescription packet</summary>
    public class ObjectDescriptionPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDescription</summary>
        public override PacketType Type { get { return PacketType.ObjectDescription; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDescriptionPacket()
        {
            Header = new LowHeader();
            Header.ID = 140;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDescriptionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDescriptionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectCategory packet</summary>
    public class ObjectCategoryPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;
            /// <summary>Category field</summary>
            public uint Category;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Category = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(Category % 256);
                bytes[i++] = (byte)((Category >> 8) % 256);
                bytes[i++] = (byte)((Category >> 16) % 256);
                bytes[i++] = (byte)((Category >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectCategory</summary>
        public override PacketType Type { get { return PacketType.ObjectCategory; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectCategoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 141;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectCategoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectCategoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectSelect packet</summary>
    public class ObjectSelectPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectSelect</summary>
        public override PacketType Type { get { return PacketType.ObjectSelect; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectSelectPacket()
        {
            Header = new LowHeader();
            Header.ID = 142;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectSelectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectSelectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDeselect packet</summary>
    public class ObjectDeselectPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDeselect</summary>
        public override PacketType Type { get { return PacketType.ObjectDeselect; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDeselectPacket()
        {
            Header = new LowHeader();
            Header.ID = 143;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDeselectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDeselectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectAttach packet</summary>
    public class ObjectAttachPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            /// <summary>Rotation field</summary>
            public LLQuaternion Rotation;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Rotation = new LLQuaternion(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                Array.Copy(Rotation.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AttachmentPoint field</summary>
            public byte AttachmentPoint;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AttachmentPoint = (byte)bytes[i++];
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = AttachmentPoint;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectAttach</summary>
        public override PacketType Type { get { return PacketType.ObjectAttach; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectAttachPacket()
        {
            Header = new LowHeader();
            Header.ID = 144;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectAttachPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectAttachPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDetach packet</summary>
    public class ObjectDetachPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDetach</summary>
        public override PacketType Type { get { return PacketType.ObjectDetach; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDetachPacket()
        {
            Header = new LowHeader();
            Header.ID = 145;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDetachPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDetachPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDrop packet</summary>
    public class ObjectDropPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDrop</summary>
        public override PacketType Type { get { return PacketType.ObjectDrop; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDropPacket()
        {
            Header = new LowHeader();
            Header.ID = 146;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDropPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDropPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectLink packet</summary>
    public class ObjectLinkPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectLink</summary>
        public override PacketType Type { get { return PacketType.ObjectLink; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectLinkPacket()
        {
            Header = new LowHeader();
            Header.ID = 147;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectLinkPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectLinkPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDelink packet</summary>
    public class ObjectDelinkPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDelink</summary>
        public override PacketType Type { get { return PacketType.ObjectDelink; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDelinkPacket()
        {
            Header = new LowHeader();
            Header.ID = 148;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDelinkPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDelinkPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectHinge packet</summary>
    public class ObjectHingePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>JointType block</summary>
        public class JointTypeBlock
        {
            /// <summary>Type field</summary>
            public byte Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public JointTypeBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public JointTypeBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Type = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = Type;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectHinge</summary>
        public override PacketType Type { get { return PacketType.ObjectHinge; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>JointType block</summary>
        public JointTypeBlock JointType;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectHingePacket()
        {
            Header = new LowHeader();
            Header.ID = 149;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            JointType = new JointTypeBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectHingePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            JointType = new JointTypeBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectHingePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            JointType = new JointTypeBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += JointType.Length;            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            JointType.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDehinge packet</summary>
    public class ObjectDehingePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDehinge</summary>
        public override PacketType Type { get { return PacketType.ObjectDehinge; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectDehingePacket()
        {
            Header = new LowHeader();
            Header.ID = 150;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDehingePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDehingePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectGrab packet</summary>
    public class ObjectGrabPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>GrabOffset field</summary>
            public LLVector3 GrabOffset;
            /// <summary>LocalID field</summary>
            public uint LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GrabOffset = new LLVector3(bytes, i); i += 12;
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GrabOffset.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectGrab</summary>
        public override PacketType Type { get { return PacketType.ObjectGrab; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public ObjectGrabPacket()
        {
            Header = new LowHeader();
            Header.ID = 151;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectGrabPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectGrabPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectGrabUpdate packet</summary>
    public class ObjectGrabUpdatePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>TimeSinceLast field</summary>
            public uint TimeSinceLast;
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>GrabOffsetInitial field</summary>
            public LLVector3 GrabOffsetInitial;
            /// <summary>GrabPosition field</summary>
            public LLVector3 GrabPosition;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TimeSinceLast = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    GrabOffsetInitial = new LLVector3(bytes, i); i += 12;
                    GrabPosition = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TimeSinceLast % 256);
                bytes[i++] = (byte)((TimeSinceLast >> 8) % 256);
                bytes[i++] = (byte)((TimeSinceLast >> 16) % 256);
                bytes[i++] = (byte)((TimeSinceLast >> 24) % 256);
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GrabOffsetInitial.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(GrabPosition.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectGrabUpdate</summary>
        public override PacketType Type { get { return PacketType.ObjectGrabUpdate; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectGrabUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 152;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectGrabUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectGrabUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectDeGrab packet</summary>
    public class ObjectDeGrabPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectDeGrab</summary>
        public override PacketType Type { get { return PacketType.ObjectDeGrab; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public ObjectDeGrabPacket()
        {
            Header = new LowHeader();
            Header.ID = 153;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock();
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectDeGrabPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectDeGrabPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectSpinStart packet</summary>
    public class ObjectSpinStartPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectSpinStart</summary>
        public override PacketType Type { get { return PacketType.ObjectSpinStart; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectSpinStartPacket()
        {
            Header = new LowHeader();
            Header.ID = 154;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectSpinStartPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectSpinStartPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectSpinUpdate packet</summary>
    public class ObjectSpinUpdatePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Rotation field</summary>
            public LLQuaternion Rotation;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    Rotation = new LLQuaternion(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Rotation.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectSpinUpdate</summary>
        public override PacketType Type { get { return PacketType.ObjectSpinUpdate; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectSpinUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 155;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectSpinUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectSpinUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectSpinStop packet</summary>
    public class ObjectSpinStopPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectSpinStop</summary>
        public override PacketType Type { get { return PacketType.ObjectSpinStop; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectSpinStopPacket()
        {
            Header = new LowHeader();
            Header.ID = 156;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectSpinStopPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectSpinStopPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectExportSelected packet</summary>
    public class ObjectExportSelectedPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>VolumeDetail field</summary>
            public short VolumeDetail;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 34;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RequestID = new LLUUID(bytes, i); i += 16;
                    VolumeDetail = (short)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(VolumeDetail % 256);
                bytes[i++] = (byte)((VolumeDetail >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectExportSelected</summary>
        public override PacketType Type { get { return PacketType.ObjectExportSelected; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectExportSelectedPacket()
        {
            Header = new LowHeader();
            Header.ID = 157;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectExportSelectedPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectExportSelectedPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectImport packet</summary>
    public class ObjectImportPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AssetData block</summary>
        public class AssetDataBlock
        {
            private byte[] _objectname;
            /// <summary>ObjectName field</summary>
            public byte[] ObjectName
            {
                get { return _objectname; }
                set
                {
                    if (value == null) { _objectname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectname = new byte[value.Length]; Array.Copy(value, _objectname, value.Length); }
                }
            }
            /// <summary>FileID field</summary>
            public LLUUID FileID;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (ObjectName != null) { length += 1 + ObjectName.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AssetDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AssetDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _objectname = new byte[length];
                    Array.Copy(bytes, i, _objectname, 0, length); i += length;
                    FileID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)ObjectName.Length;
                Array.Copy(ObjectName, 0, bytes, i, ObjectName.Length); i += ObjectName.Length;
                Array.Copy(FileID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectImport</summary>
        public override PacketType Type { get { return PacketType.ObjectImport; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>AssetData block</summary>
        public AssetDataBlock AssetData;

        /// <summary>Default constructor</summary>
        public ObjectImportPacket()
        {
            Header = new LowHeader();
            Header.ID = 158;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            AssetData = new AssetDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectImportPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            AssetData = new AssetDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectImportPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            AssetData = new AssetDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += AssetData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            AssetData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ModifyLand packet</summary>
    public class ModifyLandPacket : Packet
    {
        /// <summary>ModifyBlock block</summary>
        public class ModifyBlockBlock
        {
            /// <summary>BrushSize field</summary>
            public byte BrushSize;
            /// <summary>Seconds field</summary>
            public float Seconds;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Height field</summary>
            public float Height;
            /// <summary>Action field</summary>
            public byte Action;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ModifyBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ModifyBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    BrushSize = (byte)bytes[i++];
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Seconds = BitConverter.ToSingle(bytes, i); i += 4;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Height = BitConverter.ToSingle(bytes, i); i += 4;
                    Action = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = BrushSize;
                ba = BitConverter.GetBytes(Seconds);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Height);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = Action;
            }
        }

        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>East field</summary>
            public float East;
            /// <summary>West field</summary>
            public float West;
            /// <summary>North field</summary>
            public float North;
            /// <summary>South field</summary>
            public float South;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    East = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    West = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    North = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    South = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                ba = BitConverter.GetBytes(East);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(West);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(North);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(South);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ModifyLand</summary>
        public override PacketType Type { get { return PacketType.ModifyLand; } }
        /// <summary>ModifyBlock block</summary>
        public ModifyBlockBlock ModifyBlock;
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public ModifyLandPacket()
        {
            Header = new LowHeader();
            Header.ID = 159;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ModifyBlock = new ModifyBlockBlock();
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ModifyLandPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ModifyBlock = new ModifyBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ModifyLandPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ModifyBlock = new ModifyBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ModifyBlock.Length;;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ModifyBlock.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>VelocityInterpolateOn packet</summary>
    public class VelocityInterpolateOnPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.VelocityInterpolateOn</summary>
        public override PacketType Type { get { return PacketType.VelocityInterpolateOn; } }

        /// <summary>Default constructor</summary>
        public VelocityInterpolateOnPacket()
        {
            Header = new LowHeader();
            Header.ID = 160;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public VelocityInterpolateOnPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public VelocityInterpolateOnPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>VelocityInterpolateOff packet</summary>
    public class VelocityInterpolateOffPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.VelocityInterpolateOff</summary>
        public override PacketType Type { get { return PacketType.VelocityInterpolateOff; } }

        /// <summary>Default constructor</summary>
        public VelocityInterpolateOffPacket()
        {
            Header = new LowHeader();
            Header.ID = 161;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public VelocityInterpolateOffPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public VelocityInterpolateOffPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StateSave packet</summary>
    public class StateSavePacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StateSave</summary>
        public override PacketType Type { get { return PacketType.StateSave; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public StateSavePacket()
        {
            Header = new LowHeader();
            Header.ID = 162;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StateSavePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StateSavePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ReportAutosaveCrash packet</summary>
    public class ReportAutosaveCrashPacket : Packet
    {
        /// <summary>AutosaveData block</summary>
        public class AutosaveDataBlock
        {
            /// <summary>PID field</summary>
            public int PID;
            /// <summary>Status field</summary>
            public int Status;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AutosaveDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AutosaveDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Status = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(PID % 256);
                bytes[i++] = (byte)((PID >> 8) % 256);
                bytes[i++] = (byte)((PID >> 16) % 256);
                bytes[i++] = (byte)((PID >> 24) % 256);
                bytes[i++] = (byte)(Status % 256);
                bytes[i++] = (byte)((Status >> 8) % 256);
                bytes[i++] = (byte)((Status >> 16) % 256);
                bytes[i++] = (byte)((Status >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ReportAutosaveCrash</summary>
        public override PacketType Type { get { return PacketType.ReportAutosaveCrash; } }
        /// <summary>AutosaveData block</summary>
        public AutosaveDataBlock AutosaveData;

        /// <summary>Default constructor</summary>
        public ReportAutosaveCrashPacket()
        {
            Header = new LowHeader();
            Header.ID = 163;
            Header.Reliable = true;
            AutosaveData = new AutosaveDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ReportAutosaveCrashPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AutosaveData = new AutosaveDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ReportAutosaveCrashPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AutosaveData = new AutosaveDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AutosaveData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AutosaveData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimWideDeletes packet</summary>
    public class SimWideDeletesPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimWideDeletes</summary>
        public override PacketType Type { get { return PacketType.SimWideDeletes; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public SimWideDeletesPacket()
        {
            Header = new LowHeader();
            Header.ID = 164;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimWideDeletesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimWideDeletesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StateLoad packet</summary>
    public class StateLoadPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StateLoad</summary>
        public override PacketType Type { get { return PacketType.StateLoad; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public StateLoadPacket()
        {
            Header = new LowHeader();
            Header.ID = 165;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StateLoadPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StateLoadPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TrackAgent packet</summary>
    public class TrackAgentPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>PreyID field</summary>
            public LLUUID PreyID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    PreyID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(PreyID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TrackAgent</summary>
        public override PacketType Type { get { return PacketType.TrackAgent; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public TrackAgentPacket()
        {
            Header = new LowHeader();
            Header.ID = 166;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TrackAgentPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TrackAgentPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GrantModification packet</summary>
    public class GrantModificationPacket : Packet
    {
        /// <summary>EmpoweredBlock block</summary>
        public class EmpoweredBlockBlock
        {
            /// <summary>EmpoweredID field</summary>
            public LLUUID EmpoweredID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EmpoweredBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EmpoweredBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EmpoweredID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(EmpoweredID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _grantername;
            /// <summary>GranterName field</summary>
            public byte[] GranterName
            {
                get { return _grantername; }
                set
                {
                    if (value == null) { _grantername = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _grantername = new byte[value.Length]; Array.Copy(value, _grantername, value.Length); }
                }
            }
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    if (GranterName != null) { length += 1 + GranterName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _grantername = new byte[length];
                    Array.Copy(bytes, i, _grantername, 0, length); i += length;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)GranterName.Length;
                Array.Copy(GranterName, 0, bytes, i, GranterName.Length); i += GranterName.Length;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GrantModification</summary>
        public override PacketType Type { get { return PacketType.GrantModification; } }
        /// <summary>EmpoweredBlock block</summary>
        public EmpoweredBlockBlock[] EmpoweredBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GrantModificationPacket()
        {
            Header = new LowHeader();
            Header.ID = 167;
            Header.Reliable = true;
            EmpoweredBlock = new EmpoweredBlockBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GrantModificationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            EmpoweredBlock = new EmpoweredBlockBlock[count];
            for (int j = 0; j < count; j++)
            { EmpoweredBlock[j] = new EmpoweredBlockBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GrantModificationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            EmpoweredBlock = new EmpoweredBlockBlock[count];
            for (int j = 0; j < count; j++)
            { EmpoweredBlock[j] = new EmpoweredBlockBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < EmpoweredBlock.Length; j++) { length += EmpoweredBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)EmpoweredBlock.Length;
            for (int j = 0; j < EmpoweredBlock.Length; j++) { EmpoweredBlock[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RevokeModification packet</summary>
    public class RevokeModificationPacket : Packet
    {
        /// <summary>RevokedBlock block</summary>
        public class RevokedBlockBlock
        {
            /// <summary>RevokedID field</summary>
            public LLUUID RevokedID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RevokedBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RevokedBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RevokedID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RevokedID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _grantername;
            /// <summary>GranterName field</summary>
            public byte[] GranterName
            {
                get { return _grantername; }
                set
                {
                    if (value == null) { _grantername = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _grantername = new byte[value.Length]; Array.Copy(value, _grantername, value.Length); }
                }
            }
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    if (GranterName != null) { length += 1 + GranterName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _grantername = new byte[length];
                    Array.Copy(bytes, i, _grantername, 0, length); i += length;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)GranterName.Length;
                Array.Copy(GranterName, 0, bytes, i, GranterName.Length); i += GranterName.Length;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RevokeModification</summary>
        public override PacketType Type { get { return PacketType.RevokeModification; } }
        /// <summary>RevokedBlock block</summary>
        public RevokedBlockBlock[] RevokedBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RevokeModificationPacket()
        {
            Header = new LowHeader();
            Header.ID = 168;
            Header.Reliable = true;
            RevokedBlock = new RevokedBlockBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RevokeModificationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RevokedBlock = new RevokedBlockBlock[count];
            for (int j = 0; j < count; j++)
            { RevokedBlock[j] = new RevokedBlockBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RevokeModificationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RevokedBlock = new RevokedBlockBlock[count];
            for (int j = 0; j < count; j++)
            { RevokedBlock[j] = new RevokedBlockBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < RevokedBlock.Length; j++) { length += RevokedBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RevokedBlock.Length;
            for (int j = 0; j < RevokedBlock.Length; j++) { RevokedBlock[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestGrantedProxies packet</summary>
    public class RequestGrantedProxiesPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestGrantedProxies</summary>
        public override PacketType Type { get { return PacketType.RequestGrantedProxies; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RequestGrantedProxiesPacket()
        {
            Header = new LowHeader();
            Header.ID = 169;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestGrantedProxiesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestGrantedProxiesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GrantedProxies packet</summary>
    public class GrantedProxiesPacket : Packet
    {
        /// <summary>EmpoweredBlock block</summary>
        public class EmpoweredBlockBlock
        {
            /// <summary>EmpoweredID field</summary>
            public LLUUID EmpoweredID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EmpoweredBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EmpoweredBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EmpoweredID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(EmpoweredID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GranterBlock block</summary>
        public class GranterBlockBlock
        {
            /// <summary>GranterID field</summary>
            public LLUUID GranterID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GranterBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GranterBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GranterID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GranterID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GrantedProxies</summary>
        public override PacketType Type { get { return PacketType.GrantedProxies; } }
        /// <summary>EmpoweredBlock block</summary>
        public EmpoweredBlockBlock[] EmpoweredBlock;
        /// <summary>GranterBlock block</summary>
        public GranterBlockBlock[] GranterBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GrantedProxiesPacket()
        {
            Header = new LowHeader();
            Header.ID = 170;
            Header.Reliable = true;
            EmpoweredBlock = new EmpoweredBlockBlock[0];
            GranterBlock = new GranterBlockBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GrantedProxiesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            EmpoweredBlock = new EmpoweredBlockBlock[count];
            for (int j = 0; j < count; j++)
            { EmpoweredBlock[j] = new EmpoweredBlockBlock(bytes, ref i); }
            count = (int)bytes[i++];
            GranterBlock = new GranterBlockBlock[count];
            for (int j = 0; j < count; j++)
            { GranterBlock[j] = new GranterBlockBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GrantedProxiesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            EmpoweredBlock = new EmpoweredBlockBlock[count];
            for (int j = 0; j < count; j++)
            { EmpoweredBlock[j] = new EmpoweredBlockBlock(bytes, ref i); }
            count = (int)bytes[i++];
            GranterBlock = new GranterBlockBlock[count];
            for (int j = 0; j < count; j++)
            { GranterBlock[j] = new GranterBlockBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < EmpoweredBlock.Length; j++) { length += EmpoweredBlock[j].Length; }
            for (int j = 0; j < GranterBlock.Length; j++) { length += GranterBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)EmpoweredBlock.Length;
            for (int j = 0; j < EmpoweredBlock.Length; j++) { EmpoweredBlock[j].ToBytes(bytes, ref i); }
            bytes[i++] = (byte)GranterBlock.Length;
            for (int j = 0; j < GranterBlock.Length; j++) { GranterBlock[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AddModifyAbility packet</summary>
    public class AddModifyAbilityPacket : Packet
    {
        /// <summary>TargetBlock block</summary>
        public class TargetBlockBlock
        {
            /// <summary>TargetIP field</summary>
            public uint TargetIP;
            /// <summary>TargetPort field</summary>
            public ushort TargetPort;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TargetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TargetBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TargetPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TargetIP % 256);
                bytes[i++] = (byte)((TargetIP >> 8) % 256);
                bytes[i++] = (byte)((TargetIP >> 16) % 256);
                bytes[i++] = (byte)((TargetIP >> 24) % 256);
                bytes[i++] = (byte)(TargetPort % 256);
                bytes[i++] = (byte)((TargetPort >> 8) % 256);
            }
        }

        /// <summary>GranterBlock block</summary>
        public class GranterBlockBlock
        {
            /// <summary>GranterID field</summary>
            public LLUUID GranterID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GranterBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GranterBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GranterID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GranterID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AddModifyAbility</summary>
        public override PacketType Type { get { return PacketType.AddModifyAbility; } }
        /// <summary>TargetBlock block</summary>
        public TargetBlockBlock TargetBlock;
        /// <summary>GranterBlock block</summary>
        public GranterBlockBlock[] GranterBlock;
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public AddModifyAbilityPacket()
        {
            Header = new LowHeader();
            Header.ID = 171;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TargetBlock = new TargetBlockBlock();
            GranterBlock = new GranterBlockBlock[0];
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AddModifyAbilityPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GranterBlock = new GranterBlockBlock[count];
            for (int j = 0; j < count; j++)
            { GranterBlock[j] = new GranterBlockBlock(bytes, ref i); }
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AddModifyAbilityPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GranterBlock = new GranterBlockBlock[count];
            for (int j = 0; j < count; j++)
            { GranterBlock[j] = new GranterBlockBlock(bytes, ref i); }
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TargetBlock.Length;            length += AgentBlock.Length;;
            for (int j = 0; j < GranterBlock.Length; j++) { length += GranterBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TargetBlock.ToBytes(bytes, ref i);
            bytes[i++] = (byte)GranterBlock.Length;
            for (int j = 0; j < GranterBlock.Length; j++) { GranterBlock[j].ToBytes(bytes, ref i); }
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveModifyAbility packet</summary>
    public class RemoveModifyAbilityPacket : Packet
    {
        /// <summary>TargetBlock block</summary>
        public class TargetBlockBlock
        {
            /// <summary>TargetIP field</summary>
            public uint TargetIP;
            /// <summary>TargetPort field</summary>
            public ushort TargetPort;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TargetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TargetBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TargetPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TargetIP % 256);
                bytes[i++] = (byte)((TargetIP >> 8) % 256);
                bytes[i++] = (byte)((TargetIP >> 16) % 256);
                bytes[i++] = (byte)((TargetIP >> 24) % 256);
                bytes[i++] = (byte)(TargetPort % 256);
                bytes[i++] = (byte)((TargetPort >> 8) % 256);
            }
        }

        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RevokerID field</summary>
            public LLUUID RevokerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RevokerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RevokerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveModifyAbility</summary>
        public override PacketType Type { get { return PacketType.RemoveModifyAbility; } }
        /// <summary>TargetBlock block</summary>
        public TargetBlockBlock TargetBlock;
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public RemoveModifyAbilityPacket()
        {
            Header = new LowHeader();
            Header.ID = 172;
            Header.Reliable = true;
            TargetBlock = new TargetBlockBlock();
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveModifyAbilityPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveModifyAbilityPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TargetBlock.Length;            length += AgentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TargetBlock.ToBytes(bytes, ref i);
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ViewerStats packet</summary>
    public class ViewerStatsPacket : Packet
    {
        /// <summary>DownloadTotals block</summary>
        public class DownloadTotalsBlock
        {
            /// <summary>Objects field</summary>
            public uint Objects;
            /// <summary>Textures field</summary>
            public uint Textures;
            /// <summary>World field</summary>
            public uint World;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DownloadTotalsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DownloadTotalsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Objects = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Textures = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    World = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Objects % 256);
                bytes[i++] = (byte)((Objects >> 8) % 256);
                bytes[i++] = (byte)((Objects >> 16) % 256);
                bytes[i++] = (byte)((Objects >> 24) % 256);
                bytes[i++] = (byte)(Textures % 256);
                bytes[i++] = (byte)((Textures >> 8) % 256);
                bytes[i++] = (byte)((Textures >> 16) % 256);
                bytes[i++] = (byte)((Textures >> 24) % 256);
                bytes[i++] = (byte)(World % 256);
                bytes[i++] = (byte)((World >> 8) % 256);
                bytes[i++] = (byte)((World >> 16) % 256);
                bytes[i++] = (byte)((World >> 24) % 256);
            }
        }

        /// <summary>MiscStats block</summary>
        public class MiscStatsBlock
        {
            /// <summary>Type field</summary>
            public uint Type;
            /// <summary>Value field</summary>
            public double Value;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 13;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MiscStatsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MiscStatsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Type = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    Value = BitConverter.ToDouble(bytes, i); i += 8;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
                ba = BitConverter.GetBytes(Value);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
            }
        }

        /// <summary>NetStats block</summary>
        public class NetStatsBlock
        {
            /// <summary>Packets field</summary>
            public uint Packets;
            /// <summary>Savings field</summary>
            public uint Savings;
            /// <summary>Compressed field</summary>
            public uint Compressed;
            /// <summary>Bytes field</summary>
            public uint Bytes;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NetStatsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NetStatsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Packets = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Savings = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Compressed = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Bytes = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Packets % 256);
                bytes[i++] = (byte)((Packets >> 8) % 256);
                bytes[i++] = (byte)((Packets >> 16) % 256);
                bytes[i++] = (byte)((Packets >> 24) % 256);
                bytes[i++] = (byte)(Savings % 256);
                bytes[i++] = (byte)((Savings >> 8) % 256);
                bytes[i++] = (byte)((Savings >> 16) % 256);
                bytes[i++] = (byte)((Savings >> 24) % 256);
                bytes[i++] = (byte)(Compressed % 256);
                bytes[i++] = (byte)((Compressed >> 8) % 256);
                bytes[i++] = (byte)((Compressed >> 16) % 256);
                bytes[i++] = (byte)((Compressed >> 24) % 256);
                bytes[i++] = (byte)(Bytes % 256);
                bytes[i++] = (byte)((Bytes >> 8) % 256);
                bytes[i++] = (byte)((Bytes >> 16) % 256);
                bytes[i++] = (byte)((Bytes >> 24) % 256);
            }
        }

        /// <summary>FailStats block</summary>
        public class FailStatsBlock
        {
            /// <summary>FailedResends field</summary>
            public uint FailedResends;
            /// <summary>Invalid field</summary>
            public uint Invalid;
            /// <summary>SendPacket field</summary>
            public uint SendPacket;
            /// <summary>Dropped field</summary>
            public uint Dropped;
            /// <summary>OffCircuit field</summary>
            public uint OffCircuit;
            /// <summary>Resent field</summary>
            public uint Resent;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FailStatsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FailStatsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FailedResends = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Invalid = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SendPacket = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Dropped = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OffCircuit = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Resent = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(FailedResends % 256);
                bytes[i++] = (byte)((FailedResends >> 8) % 256);
                bytes[i++] = (byte)((FailedResends >> 16) % 256);
                bytes[i++] = (byte)((FailedResends >> 24) % 256);
                bytes[i++] = (byte)(Invalid % 256);
                bytes[i++] = (byte)((Invalid >> 8) % 256);
                bytes[i++] = (byte)((Invalid >> 16) % 256);
                bytes[i++] = (byte)((Invalid >> 24) % 256);
                bytes[i++] = (byte)(SendPacket % 256);
                bytes[i++] = (byte)((SendPacket >> 8) % 256);
                bytes[i++] = (byte)((SendPacket >> 16) % 256);
                bytes[i++] = (byte)((SendPacket >> 24) % 256);
                bytes[i++] = (byte)(Dropped % 256);
                bytes[i++] = (byte)((Dropped >> 8) % 256);
                bytes[i++] = (byte)((Dropped >> 16) % 256);
                bytes[i++] = (byte)((Dropped >> 24) % 256);
                bytes[i++] = (byte)(OffCircuit % 256);
                bytes[i++] = (byte)((OffCircuit >> 8) % 256);
                bytes[i++] = (byte)((OffCircuit >> 16) % 256);
                bytes[i++] = (byte)((OffCircuit >> 24) % 256);
                bytes[i++] = (byte)(Resent % 256);
                bytes[i++] = (byte)((Resent >> 8) % 256);
                bytes[i++] = (byte)((Resent >> 16) % 256);
                bytes[i++] = (byte)((Resent >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>FPS field</summary>
            public float FPS;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RegionsVisited field</summary>
            public int RegionsVisited;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Ping field</summary>
            public float Ping;
            /// <summary>RunTime field</summary>
            public float RunTime;
            /// <summary>MetersTraveled field</summary>
            public double MetersTraveled;
            private byte[] _syscpu;
            /// <summary>SysCPU field</summary>
            public byte[] SysCPU
            {
                get { return _syscpu; }
                set
                {
                    if (value == null) { _syscpu = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _syscpu = new byte[value.Length]; Array.Copy(value, _syscpu, value.Length); }
                }
            }
            private byte[] _sysgpu;
            /// <summary>SysGPU field</summary>
            public byte[] SysGPU
            {
                get { return _sysgpu; }
                set
                {
                    if (value == null) { _sysgpu = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _sysgpu = new byte[value.Length]; Array.Copy(value, _sysgpu, value.Length); }
                }
            }
            /// <summary>SysRAM field</summary>
            public uint SysRAM;
            /// <summary>StartTime field</summary>
            public uint StartTime;
            private byte[] _sysos;
            /// <summary>SysOS field</summary>
            public byte[] SysOS
            {
                get { return _sysos; }
                set
                {
                    if (value == null) { _sysos = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _sysos = new byte[value.Length]; Array.Copy(value, _sysos, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 68;
                    if (SysCPU != null) { length += 1 + SysCPU.Length; }
                    if (SysGPU != null) { length += 1 + SysGPU.Length; }
                    if (SysOS != null) { length += 1 + SysOS.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    FPS = BitConverter.ToSingle(bytes, i); i += 4;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RegionsVisited = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SessionID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Ping = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    RunTime = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    MetersTraveled = BitConverter.ToDouble(bytes, i); i += 8;
                    length = (ushort)bytes[i++];
                    _syscpu = new byte[length];
                    Array.Copy(bytes, i, _syscpu, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _sysgpu = new byte[length];
                    Array.Copy(bytes, i, _sysgpu, 0, length); i += length;
                    SysRAM = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    StartTime = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _sysos = new byte[length];
                    Array.Copy(bytes, i, _sysos, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                ba = BitConverter.GetBytes(FPS);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionsVisited % 256);
                bytes[i++] = (byte)((RegionsVisited >> 8) % 256);
                bytes[i++] = (byte)((RegionsVisited >> 16) % 256);
                bytes[i++] = (byte)((RegionsVisited >> 24) % 256);
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Ping);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(RunTime);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(MetersTraveled);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                bytes[i++] = (byte)SysCPU.Length;
                Array.Copy(SysCPU, 0, bytes, i, SysCPU.Length); i += SysCPU.Length;
                bytes[i++] = (byte)SysGPU.Length;
                Array.Copy(SysGPU, 0, bytes, i, SysGPU.Length); i += SysGPU.Length;
                bytes[i++] = (byte)(SysRAM % 256);
                bytes[i++] = (byte)((SysRAM >> 8) % 256);
                bytes[i++] = (byte)((SysRAM >> 16) % 256);
                bytes[i++] = (byte)((SysRAM >> 24) % 256);
                bytes[i++] = (byte)(StartTime % 256);
                bytes[i++] = (byte)((StartTime >> 8) % 256);
                bytes[i++] = (byte)((StartTime >> 16) % 256);
                bytes[i++] = (byte)((StartTime >> 24) % 256);
                bytes[i++] = (byte)SysOS.Length;
                Array.Copy(SysOS, 0, bytes, i, SysOS.Length); i += SysOS.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ViewerStats</summary>
        public override PacketType Type { get { return PacketType.ViewerStats; } }
        /// <summary>DownloadTotals block</summary>
        public DownloadTotalsBlock DownloadTotals;
        /// <summary>MiscStats block</summary>
        public MiscStatsBlock[] MiscStats;
        /// <summary>NetStats block</summary>
        public NetStatsBlock[] NetStats;
        /// <summary>FailStats block</summary>
        public FailStatsBlock FailStats;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ViewerStatsPacket()
        {
            Header = new LowHeader();
            Header.ID = 173;
            Header.Reliable = true;
            Header.Zerocoded = true;
            DownloadTotals = new DownloadTotalsBlock();
            MiscStats = new MiscStatsBlock[0];
            NetStats = new NetStatsBlock[2];
            FailStats = new FailStatsBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ViewerStatsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DownloadTotals = new DownloadTotalsBlock(bytes, ref i);
            int count = (int)bytes[i++];
            MiscStats = new MiscStatsBlock[count];
            for (int j = 0; j < count; j++)
            { MiscStats[j] = new MiscStatsBlock(bytes, ref i); }
            NetStats = new NetStatsBlock[2];
            for (int j = 0; j < 2; j++)
            { NetStats[j] = new NetStatsBlock(bytes, ref i); }
            FailStats = new FailStatsBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ViewerStatsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DownloadTotals = new DownloadTotalsBlock(bytes, ref i);
            int count = (int)bytes[i++];
            MiscStats = new MiscStatsBlock[count];
            for (int j = 0; j < count; j++)
            { MiscStats[j] = new MiscStatsBlock(bytes, ref i); }
            NetStats = new NetStatsBlock[2];
            for (int j = 0; j < 2; j++)
            { NetStats[j] = new NetStatsBlock(bytes, ref i); }
            FailStats = new FailStatsBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DownloadTotals.Length;            length += FailStats.Length;            length += AgentData.Length;;
            for (int j = 0; j < MiscStats.Length; j++) { length += MiscStats[j].Length; }
            for (int j = 0; j < 2; j++) { length += NetStats[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DownloadTotals.ToBytes(bytes, ref i);
            bytes[i++] = (byte)MiscStats.Length;
            for (int j = 0; j < MiscStats.Length; j++) { MiscStats[j].ToBytes(bytes, ref i); }
            for (int j = 0; j < 2; j++) { NetStats[j].ToBytes(bytes, ref i); }
            FailStats.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptAnswerYes packet</summary>
    public class ScriptAnswerYesPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>Questions field</summary>
            public int Questions;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 52;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    TaskID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    Questions = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Questions % 256);
                bytes[i++] = (byte)((Questions >> 8) % 256);
                bytes[i++] = (byte)((Questions >> 16) % 256);
                bytes[i++] = (byte)((Questions >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptAnswerYes</summary>
        public override PacketType Type { get { return PacketType.ScriptAnswerYes; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public ScriptAnswerYesPacket()
        {
            Header = new LowHeader();
            Header.ID = 174;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptAnswerYesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptAnswerYesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserReport packet</summary>
    public class UserReportPacket : Packet
    {
        /// <summary>MeanCollision block</summary>
        public class MeanCollisionBlock
        {
            /// <summary>Mag field</summary>
            public float Mag;
            /// <summary>Time field</summary>
            public uint Time;
            /// <summary>Perp field</summary>
            public LLUUID Perp;
            /// <summary>Type field</summary>
            public byte Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MeanCollisionBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MeanCollisionBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Mag = BitConverter.ToSingle(bytes, i); i += 4;
                    Time = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Perp = new LLUUID(bytes, i); i += 16;
                    Type = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Mag);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(Time % 256);
                bytes[i++] = (byte)((Time >> 8) % 256);
                bytes[i++] = (byte)((Time >> 16) % 256);
                bytes[i++] = (byte)((Time >> 24) % 256);
                Array.Copy(Perp.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Type;
            }
        }

        /// <summary>ReportData block</summary>
        public class ReportDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _details;
            /// <summary>Details field</summary>
            public byte[] Details
            {
                get { return _details; }
                set
                {
                    if (value == null) { _details = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _details = new byte[value.Length]; Array.Copy(value, _details, value.Length); }
                }
            }
            private byte[] _versionstring;
            /// <summary>VersionString field</summary>
            public byte[] VersionString
            {
                get { return _versionstring; }
                set
                {
                    if (value == null) { _versionstring = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _versionstring = new byte[value.Length]; Array.Copy(value, _versionstring, value.Length); }
                }
            }
            /// <summary>CheckFlags field</summary>
            public byte CheckFlags;
            /// <summary>ReportType field</summary>
            public byte ReportType;
            /// <summary>Category field</summary>
            public byte Category;
            private byte[] _summary;
            /// <summary>Summary field</summary>
            public byte[] Summary
            {
                get { return _summary; }
                set
                {
                    if (value == null) { _summary = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _summary = new byte[value.Length]; Array.Copy(value, _summary, value.Length); }
                }
            }
            /// <summary>ReporterID field</summary>
            public LLUUID ReporterID;
            /// <summary>ScreenshotID field</summary>
            public LLUUID ScreenshotID;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 63;
                    if (Details != null) { length += 2 + Details.Length; }
                    if (VersionString != null) { length += 1 + VersionString.Length; }
                    if (Summary != null) { length += 1 + Summary.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReportDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReportDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _details = new byte[length];
                    Array.Copy(bytes, i, _details, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _versionstring = new byte[length];
                    Array.Copy(bytes, i, _versionstring, 0, length); i += length;
                    CheckFlags = (byte)bytes[i++];
                    ReportType = (byte)bytes[i++];
                    Category = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _summary = new byte[length];
                    Array.Copy(bytes, i, _summary, 0, length); i += length;
                    ReporterID = new LLUUID(bytes, i); i += 16;
                    ScreenshotID = new LLUUID(bytes, i); i += 16;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Details.Length % 256);
                bytes[i++] = (byte)((Details.Length >> 8) % 256);
                Array.Copy(Details, 0, bytes, i, Details.Length); i += Details.Length;
                bytes[i++] = (byte)VersionString.Length;
                Array.Copy(VersionString, 0, bytes, i, VersionString.Length); i += VersionString.Length;
                bytes[i++] = CheckFlags;
                bytes[i++] = ReportType;
                bytes[i++] = Category;
                bytes[i++] = (byte)Summary.Length;
                Array.Copy(Summary, 0, bytes, i, Summary.Length); i += Summary.Length;
                Array.Copy(ReporterID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ScreenshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserReport</summary>
        public override PacketType Type { get { return PacketType.UserReport; } }
        /// <summary>MeanCollision block</summary>
        public MeanCollisionBlock[] MeanCollision;
        /// <summary>ReportData block</summary>
        public ReportDataBlock ReportData;

        /// <summary>Default constructor</summary>
        public UserReportPacket()
        {
            Header = new LowHeader();
            Header.ID = 175;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MeanCollision = new MeanCollisionBlock[0];
            ReportData = new ReportDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserReportPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            MeanCollision = new MeanCollisionBlock[count];
            for (int j = 0; j < count; j++)
            { MeanCollision[j] = new MeanCollisionBlock(bytes, ref i); }
            ReportData = new ReportDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserReportPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            MeanCollision = new MeanCollisionBlock[count];
            for (int j = 0; j < count; j++)
            { MeanCollision[j] = new MeanCollisionBlock(bytes, ref i); }
            ReportData = new ReportDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ReportData.Length;;
            for (int j = 0; j < MeanCollision.Length; j++) { length += MeanCollision[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)MeanCollision.Length;
            for (int j = 0; j < MeanCollision.Length; j++) { MeanCollision[j].ToBytes(bytes, ref i); }
            ReportData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AlertMessage packet</summary>
    public class AlertMessagePacket : Packet
    {
        /// <summary>AlertData block</summary>
        public class AlertDataBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AlertDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AlertDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AlertMessage</summary>
        public override PacketType Type { get { return PacketType.AlertMessage; } }
        /// <summary>AlertData block</summary>
        public AlertDataBlock AlertData;

        /// <summary>Default constructor</summary>
        public AlertMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 176;
            Header.Reliable = true;
            AlertData = new AlertDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AlertMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AlertData = new AlertDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AlertMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AlertData = new AlertDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AlertData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AlertData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentAlertMessage packet</summary>
    public class AgentAlertMessagePacket : Packet
    {
        /// <summary>AlertData block</summary>
        public class AlertDataBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>Modal field</summary>
            public bool Modal;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AlertDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AlertDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    Modal = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = (byte)((Modal) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentAlertMessage</summary>
        public override PacketType Type { get { return PacketType.AgentAlertMessage; } }
        /// <summary>AlertData block</summary>
        public AlertDataBlock AlertData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentAlertMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 177;
            Header.Reliable = true;
            AlertData = new AlertDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentAlertMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AlertData = new AlertDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentAlertMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AlertData = new AlertDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AlertData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AlertData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MeanCollisionAlert packet</summary>
    public class MeanCollisionAlertPacket : Packet
    {
        /// <summary>MeanCollision block</summary>
        public class MeanCollisionBlock
        {
            /// <summary>Mag field</summary>
            public float Mag;
            /// <summary>Time field</summary>
            public uint Time;
            /// <summary>Perp field</summary>
            public LLUUID Perp;
            /// <summary>Type field</summary>
            public byte Type;
            /// <summary>Victim field</summary>
            public LLUUID Victim;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 42;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MeanCollisionBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MeanCollisionBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Mag = BitConverter.ToSingle(bytes, i); i += 4;
                    Time = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Perp = new LLUUID(bytes, i); i += 16;
                    Type = (byte)bytes[i++];
                    Victim = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Mag);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(Time % 256);
                bytes[i++] = (byte)((Time >> 8) % 256);
                bytes[i++] = (byte)((Time >> 16) % 256);
                bytes[i++] = (byte)((Time >> 24) % 256);
                Array.Copy(Perp.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Type;
                Array.Copy(Victim.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MeanCollisionAlert</summary>
        public override PacketType Type { get { return PacketType.MeanCollisionAlert; } }
        /// <summary>MeanCollision block</summary>
        public MeanCollisionBlock[] MeanCollision;

        /// <summary>Default constructor</summary>
        public MeanCollisionAlertPacket()
        {
            Header = new LowHeader();
            Header.ID = 178;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MeanCollision = new MeanCollisionBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MeanCollisionAlertPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            MeanCollision = new MeanCollisionBlock[count];
            for (int j = 0; j < count; j++)
            { MeanCollision[j] = new MeanCollisionBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MeanCollisionAlertPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            MeanCollision = new MeanCollisionBlock[count];
            for (int j = 0; j < count; j++)
            { MeanCollision[j] = new MeanCollisionBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < MeanCollision.Length; j++) { length += MeanCollision[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)MeanCollision.Length;
            for (int j = 0; j < MeanCollision.Length; j++) { MeanCollision[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ViewerFrozenMessage packet</summary>
    public class ViewerFrozenMessagePacket : Packet
    {
        /// <summary>FrozenData block</summary>
        public class FrozenDataBlock
        {
            /// <summary>Data field</summary>
            public bool Data;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FrozenDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FrozenDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Data = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Data) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ViewerFrozenMessage</summary>
        public override PacketType Type { get { return PacketType.ViewerFrozenMessage; } }
        /// <summary>FrozenData block</summary>
        public FrozenDataBlock FrozenData;

        /// <summary>Default constructor</summary>
        public ViewerFrozenMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 179;
            Header.Reliable = true;
            FrozenData = new FrozenDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ViewerFrozenMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            FrozenData = new FrozenDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ViewerFrozenMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            FrozenData = new FrozenDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += FrozenData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            FrozenData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>HealthMessage packet</summary>
    public class HealthMessagePacket : Packet
    {
        /// <summary>HealthData block</summary>
        public class HealthDataBlock
        {
            /// <summary>Health field</summary>
            public float Health;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HealthDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HealthDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Health = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Health);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.HealthMessage</summary>
        public override PacketType Type { get { return PacketType.HealthMessage; } }
        /// <summary>HealthData block</summary>
        public HealthDataBlock HealthData;

        /// <summary>Default constructor</summary>
        public HealthMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 180;
            Header.Reliable = true;
            Header.Zerocoded = true;
            HealthData = new HealthDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public HealthMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            HealthData = new HealthDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public HealthMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            HealthData = new HealthDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += HealthData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            HealthData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChatFromSimulator packet</summary>
    public class ChatFromSimulatorPacket : Packet
    {
        /// <summary>ChatData block</summary>
        public class ChatDataBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>Audible field</summary>
            public byte Audible;
            /// <summary>ChatType field</summary>
            public byte ChatType;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            private byte[] _fromname;
            /// <summary>FromName field</summary>
            public byte[] FromName
            {
                get { return _fromname; }
                set
                {
                    if (value == null) { _fromname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _fromname = new byte[value.Length]; Array.Copy(value, _fromname, value.Length); }
                }
            }
            /// <summary>SourceType field</summary>
            public byte SourceType;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 47;
                    if (Message != null) { length += 2 + Message.Length; }
                    if (FromName != null) { length += 1 + FromName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ChatDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ChatDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    Audible = (byte)bytes[i++];
                    ChatType = (byte)bytes[i++];
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _fromname = new byte[length];
                    Array.Copy(bytes, i, _fromname, 0, length); i += length;
                    SourceType = (byte)bytes[i++];
                    SourceID = new LLUUID(bytes, i); i += 16;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = Audible;
                bytes[i++] = ChatType;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)FromName.Length;
                Array.Copy(FromName, 0, bytes, i, FromName.Length); i += FromName.Length;
                bytes[i++] = SourceType;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChatFromSimulator</summary>
        public override PacketType Type { get { return PacketType.ChatFromSimulator; } }
        /// <summary>ChatData block</summary>
        public ChatDataBlock ChatData;

        /// <summary>Default constructor</summary>
        public ChatFromSimulatorPacket()
        {
            Header = new LowHeader();
            Header.ID = 181;
            Header.Reliable = true;
            ChatData = new ChatDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChatFromSimulatorPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ChatData = new ChatDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChatFromSimulatorPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ChatData = new ChatDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ChatData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ChatData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimStats packet</summary>
    public class SimStatsPacket : Packet
    {
        /// <summary>Stat block</summary>
        public class StatBlock
        {
            /// <summary>StatValue field</summary>
            public float StatValue;
            /// <summary>StatID field</summary>
            public uint StatID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public StatBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public StatBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    StatValue = BitConverter.ToSingle(bytes, i); i += 4;
                    StatID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(StatValue);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(StatID % 256);
                bytes[i++] = (byte)((StatID >> 8) % 256);
                bytes[i++] = (byte)((StatID >> 16) % 256);
                bytes[i++] = (byte)((StatID >> 24) % 256);
            }
        }

        /// <summary>Region block</summary>
        public class RegionBlock
        {
            /// <summary>RegionX field</summary>
            public uint RegionX;
            /// <summary>RegionY field</summary>
            public uint RegionY;
            /// <summary>RegionFlags field</summary>
            public uint RegionFlags;
            /// <summary>ObjectCapacity field</summary>
            public uint ObjectCapacity;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ObjectCapacity = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionX % 256);
                bytes[i++] = (byte)((RegionX >> 8) % 256);
                bytes[i++] = (byte)((RegionX >> 16) % 256);
                bytes[i++] = (byte)((RegionX >> 24) % 256);
                bytes[i++] = (byte)(RegionY % 256);
                bytes[i++] = (byte)((RegionY >> 8) % 256);
                bytes[i++] = (byte)((RegionY >> 16) % 256);
                bytes[i++] = (byte)((RegionY >> 24) % 256);
                bytes[i++] = (byte)(RegionFlags % 256);
                bytes[i++] = (byte)((RegionFlags >> 8) % 256);
                bytes[i++] = (byte)((RegionFlags >> 16) % 256);
                bytes[i++] = (byte)((RegionFlags >> 24) % 256);
                bytes[i++] = (byte)(ObjectCapacity % 256);
                bytes[i++] = (byte)((ObjectCapacity >> 8) % 256);
                bytes[i++] = (byte)((ObjectCapacity >> 16) % 256);
                bytes[i++] = (byte)((ObjectCapacity >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimStats</summary>
        public override PacketType Type { get { return PacketType.SimStats; } }
        /// <summary>Stat block</summary>
        public StatBlock[] Stat;
        /// <summary>Region block</summary>
        public RegionBlock Region;

        /// <summary>Default constructor</summary>
        public SimStatsPacket()
        {
            Header = new LowHeader();
            Header.ID = 182;
            Header.Reliable = true;
            Stat = new StatBlock[0];
            Region = new RegionBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimStatsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Stat = new StatBlock[count];
            for (int j = 0; j < count; j++)
            { Stat[j] = new StatBlock(bytes, ref i); }
            Region = new RegionBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimStatsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Stat = new StatBlock[count];
            for (int j = 0; j < count; j++)
            { Stat[j] = new StatBlock(bytes, ref i); }
            Region = new RegionBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Region.Length;;
            for (int j = 0; j < Stat.Length; j++) { length += Stat[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Stat.Length;
            for (int j = 0; j < Stat.Length; j++) { Stat[j].ToBytes(bytes, ref i); }
            Region.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestRegionInfo packet</summary>
    public class RequestRegionInfoPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestRegionInfo</summary>
        public override PacketType Type { get { return PacketType.RequestRegionInfo; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RequestRegionInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 183;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestRegionInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestRegionInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionInfo packet</summary>
    public class RegionInfoPacket : Packet
    {
        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>BillableFactor field</summary>
            public float BillableFactor;
            /// <summary>ObjectBonusFactor field</summary>
            public float ObjectBonusFactor;
            /// <summary>RedirectGridX field</summary>
            public int RedirectGridX;
            /// <summary>RedirectGridY field</summary>
            public int RedirectGridY;
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>PricePerMeter field</summary>
            public int PricePerMeter;
            /// <summary>RegionFlags field</summary>
            public uint RegionFlags;
            /// <summary>WaterHeight field</summary>
            public float WaterHeight;
            /// <summary>UseEstateSun field</summary>
            public bool UseEstateSun;
            /// <summary>SunHour field</summary>
            public float SunHour;
            /// <summary>MaxAgents field</summary>
            public byte MaxAgents;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>TerrainLowerLimit field</summary>
            public float TerrainLowerLimit;
            /// <summary>ParentEstateID field</summary>
            public uint ParentEstateID;
            /// <summary>TerrainRaiseLimit field</summary>
            public float TerrainRaiseLimit;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 51;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    BillableFactor = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    ObjectBonusFactor = BitConverter.ToSingle(bytes, i); i += 4;
                    RedirectGridX = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RedirectGridY = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    PricePerMeter = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    WaterHeight = BitConverter.ToSingle(bytes, i); i += 4;
                    UseEstateSun = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    SunHour = BitConverter.ToSingle(bytes, i); i += 4;
                    MaxAgents = (byte)bytes[i++];
                    SimAccess = (byte)bytes[i++];
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainLowerLimit = BitConverter.ToSingle(bytes, i); i += 4;
                    ParentEstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainRaiseLimit = BitConverter.ToSingle(bytes, i); i += 4;
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(BillableFactor);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(ObjectBonusFactor);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(RedirectGridX % 256);
                bytes[i++] = (byte)((RedirectGridX >> 8) % 256);
                bytes[i++] = (byte)((RedirectGridX >> 16) % 256);
                bytes[i++] = (byte)((RedirectGridX >> 24) % 256);
                bytes[i++] = (byte)(RedirectGridY % 256);
                bytes[i++] = (byte)((RedirectGridY >> 8) % 256);
                bytes[i++] = (byte)((RedirectGridY >> 16) % 256);
                bytes[i++] = (byte)((RedirectGridY >> 24) % 256);
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)(PricePerMeter % 256);
                bytes[i++] = (byte)((PricePerMeter >> 8) % 256);
                bytes[i++] = (byte)((PricePerMeter >> 16) % 256);
                bytes[i++] = (byte)((PricePerMeter >> 24) % 256);
                bytes[i++] = (byte)(RegionFlags % 256);
                bytes[i++] = (byte)((RegionFlags >> 8) % 256);
                bytes[i++] = (byte)((RegionFlags >> 16) % 256);
                bytes[i++] = (byte)((RegionFlags >> 24) % 256);
                ba = BitConverter.GetBytes(WaterHeight);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)((UseEstateSun) ? 1 : 0);
                ba = BitConverter.GetBytes(SunHour);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = MaxAgents;
                bytes[i++] = SimAccess;
                ba = BitConverter.GetBytes(TerrainLowerLimit);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(ParentEstateID % 256);
                bytes[i++] = (byte)((ParentEstateID >> 8) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 16) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 24) % 256);
                ba = BitConverter.GetBytes(TerrainRaiseLimit);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionInfo</summary>
        public override PacketType Type { get { return PacketType.RegionInfo; } }
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RegionInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 184;
            Header.Reliable = true;
            Header.Zerocoded = true;
            RegionInfo = new RegionInfoBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionInfo.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GodUpdateRegionInfo packet</summary>
    public class GodUpdateRegionInfoPacket : Packet
    {
        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>BillableFactor field</summary>
            public float BillableFactor;
            /// <summary>RedirectGridX field</summary>
            public int RedirectGridX;
            /// <summary>RedirectGridY field</summary>
            public int RedirectGridY;
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>PricePerMeter field</summary>
            public int PricePerMeter;
            /// <summary>RegionFlags field</summary>
            public uint RegionFlags;
            /// <summary>ParentEstateID field</summary>
            public uint ParentEstateID;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    BillableFactor = BitConverter.ToSingle(bytes, i); i += 4;
                    RedirectGridX = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RedirectGridY = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    PricePerMeter = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParentEstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(BillableFactor);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(RedirectGridX % 256);
                bytes[i++] = (byte)((RedirectGridX >> 8) % 256);
                bytes[i++] = (byte)((RedirectGridX >> 16) % 256);
                bytes[i++] = (byte)((RedirectGridX >> 24) % 256);
                bytes[i++] = (byte)(RedirectGridY % 256);
                bytes[i++] = (byte)((RedirectGridY >> 8) % 256);
                bytes[i++] = (byte)((RedirectGridY >> 16) % 256);
                bytes[i++] = (byte)((RedirectGridY >> 24) % 256);
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)(PricePerMeter % 256);
                bytes[i++] = (byte)((PricePerMeter >> 8) % 256);
                bytes[i++] = (byte)((PricePerMeter >> 16) % 256);
                bytes[i++] = (byte)((PricePerMeter >> 24) % 256);
                bytes[i++] = (byte)(RegionFlags % 256);
                bytes[i++] = (byte)((RegionFlags >> 8) % 256);
                bytes[i++] = (byte)((RegionFlags >> 16) % 256);
                bytes[i++] = (byte)((RegionFlags >> 24) % 256);
                bytes[i++] = (byte)(ParentEstateID % 256);
                bytes[i++] = (byte)((ParentEstateID >> 8) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 16) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GodUpdateRegionInfo</summary>
        public override PacketType Type { get { return PacketType.GodUpdateRegionInfo; } }
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GodUpdateRegionInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 185;
            Header.Reliable = true;
            Header.Zerocoded = true;
            RegionInfo = new RegionInfoBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GodUpdateRegionInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GodUpdateRegionInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionInfo.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>NearestLandingRegionRequest packet</summary>
    public class NearestLandingRegionRequestPacket : Packet
    {
        /// <summary>RequestingRegionData block</summary>
        public class RequestingRegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestingRegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestingRegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.NearestLandingRegionRequest</summary>
        public override PacketType Type { get { return PacketType.NearestLandingRegionRequest; } }
        /// <summary>RequestingRegionData block</summary>
        public RequestingRegionDataBlock RequestingRegionData;

        /// <summary>Default constructor</summary>
        public NearestLandingRegionRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 186;
            Header.Reliable = true;
            RequestingRegionData = new RequestingRegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public NearestLandingRegionRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestingRegionData = new RequestingRegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public NearestLandingRegionRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestingRegionData = new RequestingRegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestingRegionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestingRegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>NearestLandingRegionReply packet</summary>
    public class NearestLandingRegionReplyPacket : Packet
    {
        /// <summary>LandingRegionData block</summary>
        public class LandingRegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public LandingRegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public LandingRegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.NearestLandingRegionReply</summary>
        public override PacketType Type { get { return PacketType.NearestLandingRegionReply; } }
        /// <summary>LandingRegionData block</summary>
        public LandingRegionDataBlock LandingRegionData;

        /// <summary>Default constructor</summary>
        public NearestLandingRegionReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 187;
            Header.Reliable = true;
            LandingRegionData = new LandingRegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public NearestLandingRegionReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            LandingRegionData = new LandingRegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public NearestLandingRegionReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            LandingRegionData = new LandingRegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += LandingRegionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            LandingRegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>NearestLandingRegionUpdated packet</summary>
    public class NearestLandingRegionUpdatedPacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.NearestLandingRegionUpdated</summary>
        public override PacketType Type { get { return PacketType.NearestLandingRegionUpdated; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public NearestLandingRegionUpdatedPacket()
        {
            Header = new LowHeader();
            Header.ID = 188;
            Header.Reliable = true;
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public NearestLandingRegionUpdatedPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public NearestLandingRegionUpdatedPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TeleportLandingStatusChanged packet</summary>
    public class TeleportLandingStatusChangedPacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TeleportLandingStatusChanged</summary>
        public override PacketType Type { get { return PacketType.TeleportLandingStatusChanged; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public TeleportLandingStatusChangedPacket()
        {
            Header = new LowHeader();
            Header.ID = 189;
            Header.Reliable = true;
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TeleportLandingStatusChangedPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TeleportLandingStatusChangedPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionHandshake packet</summary>
    public class RegionHandshakePacket : Packet
    {
        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>BillableFactor field</summary>
            public float BillableFactor;
            /// <summary>TerrainHeightRange00 field</summary>
            public float TerrainHeightRange00;
            /// <summary>TerrainHeightRange01 field</summary>
            public float TerrainHeightRange01;
            /// <summary>TerrainHeightRange10 field</summary>
            public float TerrainHeightRange10;
            /// <summary>TerrainHeightRange11 field</summary>
            public float TerrainHeightRange11;
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>RegionFlags field</summary>
            public uint RegionFlags;
            /// <summary>TerrainStartHeight00 field</summary>
            public float TerrainStartHeight00;
            /// <summary>TerrainStartHeight01 field</summary>
            public float TerrainStartHeight01;
            /// <summary>TerrainStartHeight10 field</summary>
            public float TerrainStartHeight10;
            /// <summary>TerrainStartHeight11 field</summary>
            public float TerrainStartHeight11;
            /// <summary>WaterHeight field</summary>
            public float WaterHeight;
            /// <summary>SimOwner field</summary>
            public LLUUID SimOwner;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>TerrainBase0 field</summary>
            public LLUUID TerrainBase0;
            /// <summary>TerrainBase1 field</summary>
            public LLUUID TerrainBase1;
            /// <summary>TerrainBase2 field</summary>
            public LLUUID TerrainBase2;
            /// <summary>TerrainBase3 field</summary>
            public LLUUID TerrainBase3;
            /// <summary>TerrainDetail0 field</summary>
            public LLUUID TerrainDetail0;
            /// <summary>TerrainDetail1 field</summary>
            public LLUUID TerrainDetail1;
            /// <summary>TerrainDetail2 field</summary>
            public LLUUID TerrainDetail2;
            /// <summary>TerrainDetail3 field</summary>
            public LLUUID TerrainDetail3;
            /// <summary>IsEstateManager field</summary>
            public bool IsEstateManager;
            /// <summary>CacheID field</summary>
            public LLUUID CacheID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 206;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    BillableFactor = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainHeightRange00 = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainHeightRange01 = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainHeightRange10 = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainHeightRange11 = BitConverter.ToSingle(bytes, i); i += 4;
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    RegionFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainStartHeight00 = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainStartHeight01 = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainStartHeight10 = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    TerrainStartHeight11 = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    WaterHeight = BitConverter.ToSingle(bytes, i); i += 4;
                    SimOwner = new LLUUID(bytes, i); i += 16;
                    SimAccess = (byte)bytes[i++];
                    TerrainBase0 = new LLUUID(bytes, i); i += 16;
                    TerrainBase1 = new LLUUID(bytes, i); i += 16;
                    TerrainBase2 = new LLUUID(bytes, i); i += 16;
                    TerrainBase3 = new LLUUID(bytes, i); i += 16;
                    TerrainDetail0 = new LLUUID(bytes, i); i += 16;
                    TerrainDetail1 = new LLUUID(bytes, i); i += 16;
                    TerrainDetail2 = new LLUUID(bytes, i); i += 16;
                    TerrainDetail3 = new LLUUID(bytes, i); i += 16;
                    IsEstateManager = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CacheID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(BillableFactor);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(TerrainHeightRange00);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(TerrainHeightRange01);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(TerrainHeightRange10);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(TerrainHeightRange11);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)(RegionFlags % 256);
                bytes[i++] = (byte)((RegionFlags >> 8) % 256);
                bytes[i++] = (byte)((RegionFlags >> 16) % 256);
                bytes[i++] = (byte)((RegionFlags >> 24) % 256);
                ba = BitConverter.GetBytes(TerrainStartHeight00);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(TerrainStartHeight01);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(TerrainStartHeight10);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(TerrainStartHeight11);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(WaterHeight);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(SimOwner.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SimAccess;
                Array.Copy(TerrainBase0.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TerrainBase1.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TerrainBase2.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TerrainBase3.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TerrainDetail0.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TerrainDetail1.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TerrainDetail2.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TerrainDetail3.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((IsEstateManager) ? 1 : 0);
                Array.Copy(CacheID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionHandshake</summary>
        public override PacketType Type { get { return PacketType.RegionHandshake; } }
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;

        /// <summary>Default constructor</summary>
        public RegionHandshakePacket()
        {
            Header = new LowHeader();
            Header.ID = 190;
            Header.Reliable = true;
            Header.Zerocoded = true;
            RegionInfo = new RegionInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionHandshakePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionHandshakePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionHandshakeReply packet</summary>
    public class RegionHandshakeReplyPacket : Packet
    {
        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionHandshakeReply</summary>
        public override PacketType Type { get { return PacketType.RegionHandshakeReply; } }
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;

        /// <summary>Default constructor</summary>
        public RegionHandshakeReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 191;
            Header.Reliable = true;
            Header.Zerocoded = true;
            RegionInfo = new RegionInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionHandshakeReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionHandshakeReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorViewerTimeMessage packet</summary>
    public class SimulatorViewerTimeMessagePacket : Packet
    {
        /// <summary>TimeInfo block</summary>
        public class TimeInfoBlock
        {
            /// <summary>SecPerDay field</summary>
            public uint SecPerDay;
            /// <summary>UsecSinceStart field</summary>
            public ulong UsecSinceStart;
            /// <summary>SecPerYear field</summary>
            public uint SecPerYear;
            /// <summary>SunAngVelocity field</summary>
            public LLVector3 SunAngVelocity;
            /// <summary>SunPhase field</summary>
            public float SunPhase;
            /// <summary>SunDirection field</summary>
            public LLVector3 SunDirection;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TimeInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TimeInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SecPerDay = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    UsecSinceStart = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SecPerYear = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SunAngVelocity = new LLVector3(bytes, i); i += 12;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    SunPhase = BitConverter.ToSingle(bytes, i); i += 4;
                    SunDirection = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(SecPerDay % 256);
                bytes[i++] = (byte)((SecPerDay >> 8) % 256);
                bytes[i++] = (byte)((SecPerDay >> 16) % 256);
                bytes[i++] = (byte)((SecPerDay >> 24) % 256);
                bytes[i++] = (byte)(UsecSinceStart % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 8) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 16) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 24) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 32) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 40) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 48) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 56) % 256);
                bytes[i++] = (byte)(SecPerYear % 256);
                bytes[i++] = (byte)((SecPerYear >> 8) % 256);
                bytes[i++] = (byte)((SecPerYear >> 16) % 256);
                bytes[i++] = (byte)((SecPerYear >> 24) % 256);
                Array.Copy(SunAngVelocity.GetBytes(), 0, bytes, i, 12); i += 12;
                ba = BitConverter.GetBytes(SunPhase);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(SunDirection.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorViewerTimeMessage</summary>
        public override PacketType Type { get { return PacketType.SimulatorViewerTimeMessage; } }
        /// <summary>TimeInfo block</summary>
        public TimeInfoBlock TimeInfo;

        /// <summary>Default constructor</summary>
        public SimulatorViewerTimeMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 192;
            Header.Reliable = true;
            TimeInfo = new TimeInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorViewerTimeMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TimeInfo = new TimeInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorViewerTimeMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TimeInfo = new TimeInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TimeInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TimeInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EnableSimulator packet</summary>
    public class EnableSimulatorPacket : Packet
    {
        /// <summary>SimulatorInfo block</summary>
        public class SimulatorInfoBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>Handle field</summary>
            public ulong Handle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 14;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Handle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = (byte)(Handle % 256);
                bytes[i++] = (byte)((Handle >> 8) % 256);
                bytes[i++] = (byte)((Handle >> 16) % 256);
                bytes[i++] = (byte)((Handle >> 24) % 256);
                bytes[i++] = (byte)((Handle >> 32) % 256);
                bytes[i++] = (byte)((Handle >> 40) % 256);
                bytes[i++] = (byte)((Handle >> 48) % 256);
                bytes[i++] = (byte)((Handle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EnableSimulator</summary>
        public override PacketType Type { get { return PacketType.EnableSimulator; } }
        /// <summary>SimulatorInfo block</summary>
        public SimulatorInfoBlock SimulatorInfo;

        /// <summary>Default constructor</summary>
        public EnableSimulatorPacket()
        {
            Header = new LowHeader();
            Header.ID = 193;
            Header.Reliable = true;
            SimulatorInfo = new SimulatorInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EnableSimulatorPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            SimulatorInfo = new SimulatorInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EnableSimulatorPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimulatorInfo = new SimulatorInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SimulatorInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimulatorInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DisableSimulator packet</summary>
    public class DisableSimulatorPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DisableSimulator</summary>
        public override PacketType Type { get { return PacketType.DisableSimulator; } }

        /// <summary>Default constructor</summary>
        public DisableSimulatorPacket()
        {
            Header = new LowHeader();
            Header.ID = 194;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DisableSimulatorPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DisableSimulatorPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TransferRequest packet</summary>
    public class TransferRequestPacket : Packet
    {
        /// <summary>TransferInfo block</summary>
        public class TransferInfoBlock
        {
            /// <summary>TransferID field</summary>
            public LLUUID TransferID;
            private byte[] _params;
            /// <summary>Params field</summary>
            public byte[] Params
            {
                get { return _params; }
                set
                {
                    if (value == null) { _params = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _params = new byte[value.Length]; Array.Copy(value, _params, value.Length); }
                }
            }
            /// <summary>ChannelType field</summary>
            public int ChannelType;
            /// <summary>SourceType field</summary>
            public int SourceType;
            /// <summary>Priority field</summary>
            public float Priority;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    if (Params != null) { length += 2 + Params.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransferInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransferInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    TransferID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _params = new byte[length];
                    Array.Copy(bytes, i, _params, 0, length); i += length;
                    ChannelType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SourceType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Priority = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(TransferID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Params.Length % 256);
                bytes[i++] = (byte)((Params.Length >> 8) % 256);
                Array.Copy(Params, 0, bytes, i, Params.Length); i += Params.Length;
                bytes[i++] = (byte)(ChannelType % 256);
                bytes[i++] = (byte)((ChannelType >> 8) % 256);
                bytes[i++] = (byte)((ChannelType >> 16) % 256);
                bytes[i++] = (byte)((ChannelType >> 24) % 256);
                bytes[i++] = (byte)(SourceType % 256);
                bytes[i++] = (byte)((SourceType >> 8) % 256);
                bytes[i++] = (byte)((SourceType >> 16) % 256);
                bytes[i++] = (byte)((SourceType >> 24) % 256);
                ba = BitConverter.GetBytes(Priority);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TransferRequest</summary>
        public override PacketType Type { get { return PacketType.TransferRequest; } }
        /// <summary>TransferInfo block</summary>
        public TransferInfoBlock TransferInfo;

        /// <summary>Default constructor</summary>
        public TransferRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 195;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TransferInfo = new TransferInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TransferRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TransferRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransferInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransferInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TransferInfo packet</summary>
    public class TransferInfoPacket : Packet
    {
        /// <summary>TransferInfo block</summary>
        public class TransferInfoBlock
        {
            /// <summary>TransferID field</summary>
            public LLUUID TransferID;
            /// <summary>Size field</summary>
            public int Size;
            /// <summary>ChannelType field</summary>
            public int ChannelType;
            /// <summary>TargetType field</summary>
            public int TargetType;
            /// <summary>Status field</summary>
            public int Status;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransferInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransferInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransferID = new LLUUID(bytes, i); i += 16;
                    Size = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ChannelType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TargetType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Status = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransferID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Size % 256);
                bytes[i++] = (byte)((Size >> 8) % 256);
                bytes[i++] = (byte)((Size >> 16) % 256);
                bytes[i++] = (byte)((Size >> 24) % 256);
                bytes[i++] = (byte)(ChannelType % 256);
                bytes[i++] = (byte)((ChannelType >> 8) % 256);
                bytes[i++] = (byte)((ChannelType >> 16) % 256);
                bytes[i++] = (byte)((ChannelType >> 24) % 256);
                bytes[i++] = (byte)(TargetType % 256);
                bytes[i++] = (byte)((TargetType >> 8) % 256);
                bytes[i++] = (byte)((TargetType >> 16) % 256);
                bytes[i++] = (byte)((TargetType >> 24) % 256);
                bytes[i++] = (byte)(Status % 256);
                bytes[i++] = (byte)((Status >> 8) % 256);
                bytes[i++] = (byte)((Status >> 16) % 256);
                bytes[i++] = (byte)((Status >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TransferInfo</summary>
        public override PacketType Type { get { return PacketType.TransferInfo; } }
        /// <summary>TransferInfo block</summary>
        public TransferInfoBlock TransferInfo;

        /// <summary>Default constructor</summary>
        public TransferInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 196;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TransferInfo = new TransferInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TransferInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TransferInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransferInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransferInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TransferAbort packet</summary>
    public class TransferAbortPacket : Packet
    {
        /// <summary>TransferInfo block</summary>
        public class TransferInfoBlock
        {
            /// <summary>TransferID field</summary>
            public LLUUID TransferID;
            /// <summary>ChannelType field</summary>
            public int ChannelType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransferInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransferInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransferID = new LLUUID(bytes, i); i += 16;
                    ChannelType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransferID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ChannelType % 256);
                bytes[i++] = (byte)((ChannelType >> 8) % 256);
                bytes[i++] = (byte)((ChannelType >> 16) % 256);
                bytes[i++] = (byte)((ChannelType >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TransferAbort</summary>
        public override PacketType Type { get { return PacketType.TransferAbort; } }
        /// <summary>TransferInfo block</summary>
        public TransferInfoBlock TransferInfo;

        /// <summary>Default constructor</summary>
        public TransferAbortPacket()
        {
            Header = new LowHeader();
            Header.ID = 197;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TransferInfo = new TransferInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TransferAbortPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TransferAbortPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransferInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransferInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TransferPriority packet</summary>
    public class TransferPriorityPacket : Packet
    {
        /// <summary>TransferInfo block</summary>
        public class TransferInfoBlock
        {
            /// <summary>TransferID field</summary>
            public LLUUID TransferID;
            /// <summary>ChannelType field</summary>
            public int ChannelType;
            /// <summary>Priority field</summary>
            public float Priority;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransferInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransferInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransferID = new LLUUID(bytes, i); i += 16;
                    ChannelType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Priority = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(TransferID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ChannelType % 256);
                bytes[i++] = (byte)((ChannelType >> 8) % 256);
                bytes[i++] = (byte)((ChannelType >> 16) % 256);
                bytes[i++] = (byte)((ChannelType >> 24) % 256);
                ba = BitConverter.GetBytes(Priority);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TransferPriority</summary>
        public override PacketType Type { get { return PacketType.TransferPriority; } }
        /// <summary>TransferInfo block</summary>
        public TransferInfoBlock TransferInfo;

        /// <summary>Default constructor</summary>
        public TransferPriorityPacket()
        {
            Header = new LowHeader();
            Header.ID = 198;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TransferInfo = new TransferInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TransferPriorityPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TransferPriorityPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransferInfo = new TransferInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransferInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransferInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestXfer packet</summary>
    public class RequestXferPacket : Packet
    {
        /// <summary>XferID block</summary>
        public class XferIDBlock
        {
            /// <summary>ID field</summary>
            public ulong ID;
            /// <summary>UseBigPackets field</summary>
            public bool UseBigPackets;
            /// <summary>DeleteOnCompletion field</summary>
            public bool DeleteOnCompletion;
            /// <summary>FilePath field</summary>
            public byte FilePath;
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }
            /// <summary>VFileID field</summary>
            public LLUUID VFileID;
            /// <summary>VFileType field</summary>
            public short VFileType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public XferIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public XferIDBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    UseBigPackets = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    DeleteOnCompletion = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    FilePath = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                    VFileID = new LLUUID(bytes, i); i += 16;
                    VFileType = (short)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
                bytes[i++] = (byte)((ID >> 32) % 256);
                bytes[i++] = (byte)((ID >> 40) % 256);
                bytes[i++] = (byte)((ID >> 48) % 256);
                bytes[i++] = (byte)((ID >> 56) % 256);
                bytes[i++] = (byte)((UseBigPackets) ? 1 : 0);
                bytes[i++] = (byte)((DeleteOnCompletion) ? 1 : 0);
                bytes[i++] = FilePath;
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
                Array.Copy(VFileID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(VFileType % 256);
                bytes[i++] = (byte)((VFileType >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestXfer</summary>
        public override PacketType Type { get { return PacketType.RequestXfer; } }
        /// <summary>XferID block</summary>
        public XferIDBlock XferID;

        /// <summary>Default constructor</summary>
        public RequestXferPacket()
        {
            Header = new LowHeader();
            Header.ID = 199;
            Header.Reliable = true;
            Header.Zerocoded = true;
            XferID = new XferIDBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestXferPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestXferPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += XferID.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            XferID.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AbortXfer packet</summary>
    public class AbortXferPacket : Packet
    {
        /// <summary>XferID block</summary>
        public class XferIDBlock
        {
            /// <summary>ID field</summary>
            public ulong ID;
            /// <summary>Result field</summary>
            public int Result;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public XferIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public XferIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Result = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
                bytes[i++] = (byte)((ID >> 32) % 256);
                bytes[i++] = (byte)((ID >> 40) % 256);
                bytes[i++] = (byte)((ID >> 48) % 256);
                bytes[i++] = (byte)((ID >> 56) % 256);
                bytes[i++] = (byte)(Result % 256);
                bytes[i++] = (byte)((Result >> 8) % 256);
                bytes[i++] = (byte)((Result >> 16) % 256);
                bytes[i++] = (byte)((Result >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AbortXfer</summary>
        public override PacketType Type { get { return PacketType.AbortXfer; } }
        /// <summary>XferID block</summary>
        public XferIDBlock XferID;

        /// <summary>Default constructor</summary>
        public AbortXferPacket()
        {
            Header = new LowHeader();
            Header.ID = 200;
            Header.Reliable = true;
            XferID = new XferIDBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AbortXferPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AbortXferPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += XferID.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            XferID.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestAvatarInfo packet</summary>
    public class RequestAvatarInfoPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>FullID field</summary>
            public LLUUID FullID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FullID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(FullID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestAvatarInfo</summary>
        public override PacketType Type { get { return PacketType.RequestAvatarInfo; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public RequestAvatarInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 201;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestAvatarInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestAvatarInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarAppearance packet</summary>
    public class AvatarAppearancePacket : Packet
    {
        /// <summary>VisualParam block</summary>
        public class VisualParamBlock
        {
            /// <summary>ParamValue field</summary>
            public byte ParamValue;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public VisualParamBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public VisualParamBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParamValue = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ParamValue;
            }
        }

        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            private byte[] _textureentry;
            /// <summary>TextureEntry field</summary>
            public byte[] TextureEntry
            {
                get { return _textureentry; }
                set
                {
                    if (value == null) { _textureentry = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _textureentry = new byte[value.Length]; Array.Copy(value, _textureentry, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (TextureEntry != null) { length += 2 + TextureEntry.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _textureentry = new byte[length];
                    Array.Copy(bytes, i, _textureentry, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TextureEntry.Length % 256);
                bytes[i++] = (byte)((TextureEntry.Length >> 8) % 256);
                Array.Copy(TextureEntry, 0, bytes, i, TextureEntry.Length); i += TextureEntry.Length;
            }
        }

        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>IsTrial field</summary>
            public bool IsTrial;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    IsTrial = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((IsTrial) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarAppearance</summary>
        public override PacketType Type { get { return PacketType.AvatarAppearance; } }
        /// <summary>VisualParam block</summary>
        public VisualParamBlock[] VisualParam;
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public AvatarAppearancePacket()
        {
            Header = new LowHeader();
            Header.ID = 202;
            Header.Reliable = true;
            Header.Zerocoded = true;
            VisualParam = new VisualParamBlock[0];
            ObjectData = new ObjectDataBlock();
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarAppearancePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            VisualParam = new VisualParamBlock[count];
            for (int j = 0; j < count; j++)
            { VisualParam[j] = new VisualParamBlock(bytes, ref i); }
            ObjectData = new ObjectDataBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarAppearancePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            VisualParam = new VisualParamBlock[count];
            for (int j = 0; j < count; j++)
            { VisualParam[j] = new VisualParamBlock(bytes, ref i); }
            ObjectData = new ObjectDataBlock(bytes, ref i);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;            length += Sender.Length;;
            for (int j = 0; j < VisualParam.Length; j++) { length += VisualParam[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)VisualParam.Length;
            for (int j = 0; j < VisualParam.Length; j++) { VisualParam[j].ToBytes(bytes, ref i); }
            ObjectData.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetFollowCamProperties packet</summary>
    public class SetFollowCamPropertiesPacket : Packet
    {
        /// <summary>CameraProperty block</summary>
        public class CameraPropertyBlock
        {
            /// <summary>Type field</summary>
            public int Type;
            /// <summary>Value field</summary>
            public float Value;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public CameraPropertyBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public CameraPropertyBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Value = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
                ba = BitConverter.GetBytes(Value);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetFollowCamProperties</summary>
        public override PacketType Type { get { return PacketType.SetFollowCamProperties; } }
        /// <summary>CameraProperty block</summary>
        public CameraPropertyBlock[] CameraProperty;
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;

        /// <summary>Default constructor</summary>
        public SetFollowCamPropertiesPacket()
        {
            Header = new LowHeader();
            Header.ID = 203;
            Header.Reliable = true;
            CameraProperty = new CameraPropertyBlock[0];
            ObjectData = new ObjectDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetFollowCamPropertiesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            CameraProperty = new CameraPropertyBlock[count];
            for (int j = 0; j < count; j++)
            { CameraProperty[j] = new CameraPropertyBlock(bytes, ref i); }
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetFollowCamPropertiesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            CameraProperty = new CameraPropertyBlock[count];
            for (int j = 0; j < count; j++)
            { CameraProperty[j] = new CameraPropertyBlock(bytes, ref i); }
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;;
            for (int j = 0; j < CameraProperty.Length; j++) { length += CameraProperty[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)CameraProperty.Length;
            for (int j = 0; j < CameraProperty.Length; j++) { CameraProperty[j].ToBytes(bytes, ref i); }
            ObjectData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClearFollowCamProperties packet</summary>
    public class ClearFollowCamPropertiesPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClearFollowCamProperties</summary>
        public override PacketType Type { get { return PacketType.ClearFollowCamProperties; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;

        /// <summary>Default constructor</summary>
        public ClearFollowCamPropertiesPacket()
        {
            Header = new LowHeader();
            Header.ID = 204;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClearFollowCamPropertiesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClearFollowCamPropertiesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestPayPrice packet</summary>
    public class RequestPayPricePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestPayPrice</summary>
        public override PacketType Type { get { return PacketType.RequestPayPrice; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;

        /// <summary>Default constructor</summary>
        public RequestPayPricePacket()
        {
            Header = new LowHeader();
            Header.ID = 205;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestPayPricePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestPayPricePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PayPriceReply packet</summary>
    public class PayPriceReplyPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>DefaultPayPrice field</summary>
            public int DefaultPayPrice;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    DefaultPayPrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(DefaultPayPrice % 256);
                bytes[i++] = (byte)((DefaultPayPrice >> 8) % 256);
                bytes[i++] = (byte)((DefaultPayPrice >> 16) % 256);
                bytes[i++] = (byte)((DefaultPayPrice >> 24) % 256);
            }
        }

        /// <summary>ButtonData block</summary>
        public class ButtonDataBlock
        {
            /// <summary>PayButton field</summary>
            public int PayButton;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ButtonDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ButtonDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PayButton = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(PayButton % 256);
                bytes[i++] = (byte)((PayButton >> 8) % 256);
                bytes[i++] = (byte)((PayButton >> 16) % 256);
                bytes[i++] = (byte)((PayButton >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PayPriceReply</summary>
        public override PacketType Type { get { return PacketType.PayPriceReply; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>ButtonData block</summary>
        public ButtonDataBlock[] ButtonData;

        /// <summary>Default constructor</summary>
        public PayPriceReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 206;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock();
            ButtonData = new ButtonDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PayPriceReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ButtonData = new ButtonDataBlock[count];
            for (int j = 0; j < count; j++)
            { ButtonData[j] = new ButtonDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PayPriceReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ButtonData = new ButtonDataBlock[count];
            for (int j = 0; j < count; j++)
            { ButtonData[j] = new ButtonDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;;
            for (int j = 0; j < ButtonData.Length; j++) { length += ButtonData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ButtonData.Length;
            for (int j = 0; j < ButtonData.Length; j++) { ButtonData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>KickUser packet</summary>
    public class KickUserPacket : Packet
    {
        /// <summary>TargetBlock block</summary>
        public class TargetBlockBlock
        {
            /// <summary>TargetIP field</summary>
            public uint TargetIP;
            /// <summary>TargetPort field</summary>
            public ushort TargetPort;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TargetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TargetBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TargetPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TargetIP % 256);
                bytes[i++] = (byte)((TargetIP >> 8) % 256);
                bytes[i++] = (byte)((TargetIP >> 16) % 256);
                bytes[i++] = (byte)((TargetIP >> 24) % 256);
                bytes[i++] = (byte)(TargetPort % 256);
                bytes[i++] = (byte)((TargetPort >> 8) % 256);
            }
        }

        /// <summary>UserInfo block</summary>
        public class UserInfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            private byte[] _reason;
            /// <summary>Reason field</summary>
            public byte[] Reason
            {
                get { return _reason; }
                set
                {
                    if (value == null) { _reason = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _reason = new byte[value.Length]; Array.Copy(value, _reason, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    if (Reason != null) { length += 2 + Reason.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _reason = new byte[length];
                    Array.Copy(bytes, i, _reason, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Reason.Length % 256);
                bytes[i++] = (byte)((Reason.Length >> 8) % 256);
                Array.Copy(Reason, 0, bytes, i, Reason.Length); i += Reason.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.KickUser</summary>
        public override PacketType Type { get { return PacketType.KickUser; } }
        /// <summary>TargetBlock block</summary>
        public TargetBlockBlock TargetBlock;
        /// <summary>UserInfo block</summary>
        public UserInfoBlock UserInfo;

        /// <summary>Default constructor</summary>
        public KickUserPacket()
        {
            Header = new LowHeader();
            Header.ID = 207;
            Header.Reliable = true;
            TargetBlock = new TargetBlockBlock();
            UserInfo = new UserInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public KickUserPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            UserInfo = new UserInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public KickUserPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            UserInfo = new UserInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TargetBlock.Length;            length += UserInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TargetBlock.ToBytes(bytes, ref i);
            UserInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>KickUserAck packet</summary>
    public class KickUserAckPacket : Packet
    {
        /// <summary>UserInfo block</summary>
        public class UserInfoBlock
        {
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SessionID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.KickUserAck</summary>
        public override PacketType Type { get { return PacketType.KickUserAck; } }
        /// <summary>UserInfo block</summary>
        public UserInfoBlock UserInfo;

        /// <summary>Default constructor</summary>
        public KickUserAckPacket()
        {
            Header = new LowHeader();
            Header.ID = 208;
            Header.Reliable = true;
            UserInfo = new UserInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public KickUserAckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            UserInfo = new UserInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public KickUserAckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            UserInfo = new UserInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += UserInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            UserInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GodKickUser packet</summary>
    public class GodKickUserPacket : Packet
    {
        /// <summary>UserInfo block</summary>
        public class UserInfoBlock
        {
            /// <summary>GodSessionID field</summary>
            public LLUUID GodSessionID;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _reason;
            /// <summary>Reason field</summary>
            public byte[] Reason
            {
                get { return _reason; }
                set
                {
                    if (value == null) { _reason = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _reason = new byte[value.Length]; Array.Copy(value, _reason, value.Length); }
                }
            }
            /// <summary>KickFlags field</summary>
            public uint KickFlags;
            /// <summary>GodID field</summary>
            public LLUUID GodID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 52;
                    if (Reason != null) { length += 2 + Reason.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserInfoBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GodSessionID = new LLUUID(bytes, i); i += 16;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _reason = new byte[length];
                    Array.Copy(bytes, i, _reason, 0, length); i += length;
                    KickFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GodID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GodSessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Reason.Length % 256);
                bytes[i++] = (byte)((Reason.Length >> 8) % 256);
                Array.Copy(Reason, 0, bytes, i, Reason.Length); i += Reason.Length;
                bytes[i++] = (byte)(KickFlags % 256);
                bytes[i++] = (byte)((KickFlags >> 8) % 256);
                bytes[i++] = (byte)((KickFlags >> 16) % 256);
                bytes[i++] = (byte)((KickFlags >> 24) % 256);
                Array.Copy(GodID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GodKickUser</summary>
        public override PacketType Type { get { return PacketType.GodKickUser; } }
        /// <summary>UserInfo block</summary>
        public UserInfoBlock UserInfo;

        /// <summary>Default constructor</summary>
        public GodKickUserPacket()
        {
            Header = new LowHeader();
            Header.ID = 209;
            Header.Reliable = true;
            UserInfo = new UserInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GodKickUserPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            UserInfo = new UserInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GodKickUserPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            UserInfo = new UserInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += UserInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            UserInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SystemKickUser packet</summary>
    public class SystemKickUserPacket : Packet
    {
        /// <summary>AgentInfo block</summary>
        public class AgentInfoBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SystemKickUser</summary>
        public override PacketType Type { get { return PacketType.SystemKickUser; } }
        /// <summary>AgentInfo block</summary>
        public AgentInfoBlock[] AgentInfo;

        /// <summary>Default constructor</summary>
        public SystemKickUserPacket()
        {
            Header = new LowHeader();
            Header.ID = 210;
            Header.Reliable = true;
            AgentInfo = new AgentInfoBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SystemKickUserPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentInfo = new AgentInfoBlock[count];
            for (int j = 0; j < count; j++)
            { AgentInfo[j] = new AgentInfoBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SystemKickUserPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentInfo = new AgentInfoBlock[count];
            for (int j = 0; j < count; j++)
            { AgentInfo[j] = new AgentInfoBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentInfo.Length; j++) { length += AgentInfo[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentInfo.Length;
            for (int j = 0; j < AgentInfo.Length; j++) { AgentInfo[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EjectUser packet</summary>
    public class EjectUserPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EjectUser</summary>
        public override PacketType Type { get { return PacketType.EjectUser; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EjectUserPacket()
        {
            Header = new LowHeader();
            Header.ID = 211;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EjectUserPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EjectUserPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>FreezeUser packet</summary>
    public class FreezeUserPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.FreezeUser</summary>
        public override PacketType Type { get { return PacketType.FreezeUser; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public FreezeUserPacket()
        {
            Header = new LowHeader();
            Header.ID = 212;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public FreezeUserPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public FreezeUserPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPropertiesRequest packet</summary>
    public class AvatarPropertiesRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>AvatarID field</summary>
            public LLUUID AvatarID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    AvatarID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(AvatarID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPropertiesRequest</summary>
        public override PacketType Type { get { return PacketType.AvatarPropertiesRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPropertiesRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 213;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPropertiesRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPropertiesRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPropertiesRequestBackend packet</summary>
    public class AvatarPropertiesRequestBackendPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GodLevel field</summary>
            public byte GodLevel;
            /// <summary>AvatarID field</summary>
            public LLUUID AvatarID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GodLevel = (byte)bytes[i++];
                    AvatarID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = GodLevel;
                Array.Copy(AvatarID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPropertiesRequestBackend</summary>
        public override PacketType Type { get { return PacketType.AvatarPropertiesRequestBackend; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPropertiesRequestBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 214;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPropertiesRequestBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPropertiesRequestBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPropertiesReply packet</summary>
    public class AvatarPropertiesReplyPacket : Packet
    {
        /// <summary>PropertiesData block</summary>
        public class PropertiesDataBlock
        {
            /// <summary>PartnerID field</summary>
            public LLUUID PartnerID;
            private byte[] _abouttext;
            /// <summary>AboutText field</summary>
            public byte[] AboutText
            {
                get { return _abouttext; }
                set
                {
                    if (value == null) { _abouttext = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _abouttext = new byte[value.Length]; Array.Copy(value, _abouttext, value.Length); }
                }
            }
            /// <summary>Transacted field</summary>
            public bool Transacted;
            private byte[] _chartermember;
            /// <summary>CharterMember field</summary>
            public byte[] CharterMember
            {
                get { return _chartermember; }
                set
                {
                    if (value == null) { _chartermember = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _chartermember = new byte[value.Length]; Array.Copy(value, _chartermember, value.Length); }
                }
            }
            private byte[] _flabouttext;
            /// <summary>FLAboutText field</summary>
            public byte[] FLAboutText
            {
                get { return _flabouttext; }
                set
                {
                    if (value == null) { _flabouttext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _flabouttext = new byte[value.Length]; Array.Copy(value, _flabouttext, value.Length); }
                }
            }
            /// <summary>ImageID field</summary>
            public LLUUID ImageID;
            /// <summary>FLImageID field</summary>
            public LLUUID FLImageID;
            /// <summary>AllowPublish field</summary>
            public bool AllowPublish;
            /// <summary>WantToMask field</summary>
            public uint WantToMask;
            private byte[] _wanttotext;
            /// <summary>WantToText field</summary>
            public byte[] WantToText
            {
                get { return _wanttotext; }
                set
                {
                    if (value == null) { _wanttotext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _wanttotext = new byte[value.Length]; Array.Copy(value, _wanttotext, value.Length); }
                }
            }
            /// <summary>SkillsMask field</summary>
            public uint SkillsMask;
            private byte[] _skillstext;
            /// <summary>SkillsText field</summary>
            public byte[] SkillsText
            {
                get { return _skillstext; }
                set
                {
                    if (value == null) { _skillstext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _skillstext = new byte[value.Length]; Array.Copy(value, _skillstext, value.Length); }
                }
            }
            /// <summary>Identified field</summary>
            public bool Identified;
            private byte[] _bornon;
            /// <summary>BornOn field</summary>
            public byte[] BornOn
            {
                get { return _bornon; }
                set
                {
                    if (value == null) { _bornon = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _bornon = new byte[value.Length]; Array.Copy(value, _bornon, value.Length); }
                }
            }
            /// <summary>MaturePublish field</summary>
            public bool MaturePublish;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 60;
                    if (AboutText != null) { length += 2 + AboutText.Length; }
                    if (CharterMember != null) { length += 1 + CharterMember.Length; }
                    if (FLAboutText != null) { length += 1 + FLAboutText.Length; }
                    if (WantToText != null) { length += 1 + WantToText.Length; }
                    if (SkillsText != null) { length += 1 + SkillsText.Length; }
                    if (BornOn != null) { length += 1 + BornOn.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PropertiesDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PropertiesDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    PartnerID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _abouttext = new byte[length];
                    Array.Copy(bytes, i, _abouttext, 0, length); i += length;
                    Transacted = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _chartermember = new byte[length];
                    Array.Copy(bytes, i, _chartermember, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _flabouttext = new byte[length];
                    Array.Copy(bytes, i, _flabouttext, 0, length); i += length;
                    ImageID = new LLUUID(bytes, i); i += 16;
                    FLImageID = new LLUUID(bytes, i); i += 16;
                    AllowPublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    WantToMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _wanttotext = new byte[length];
                    Array.Copy(bytes, i, _wanttotext, 0, length); i += length;
                    SkillsMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _skillstext = new byte[length];
                    Array.Copy(bytes, i, _skillstext, 0, length); i += length;
                    Identified = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _bornon = new byte[length];
                    Array.Copy(bytes, i, _bornon, 0, length); i += length;
                    MaturePublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(PartnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(AboutText.Length % 256);
                bytes[i++] = (byte)((AboutText.Length >> 8) % 256);
                Array.Copy(AboutText, 0, bytes, i, AboutText.Length); i += AboutText.Length;
                bytes[i++] = (byte)((Transacted) ? 1 : 0);
                bytes[i++] = (byte)CharterMember.Length;
                Array.Copy(CharterMember, 0, bytes, i, CharterMember.Length); i += CharterMember.Length;
                bytes[i++] = (byte)FLAboutText.Length;
                Array.Copy(FLAboutText, 0, bytes, i, FLAboutText.Length); i += FLAboutText.Length;
                Array.Copy(ImageID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FLImageID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AllowPublish) ? 1 : 0);
                bytes[i++] = (byte)(WantToMask % 256);
                bytes[i++] = (byte)((WantToMask >> 8) % 256);
                bytes[i++] = (byte)((WantToMask >> 16) % 256);
                bytes[i++] = (byte)((WantToMask >> 24) % 256);
                bytes[i++] = (byte)WantToText.Length;
                Array.Copy(WantToText, 0, bytes, i, WantToText.Length); i += WantToText.Length;
                bytes[i++] = (byte)(SkillsMask % 256);
                bytes[i++] = (byte)((SkillsMask >> 8) % 256);
                bytes[i++] = (byte)((SkillsMask >> 16) % 256);
                bytes[i++] = (byte)((SkillsMask >> 24) % 256);
                bytes[i++] = (byte)SkillsText.Length;
                Array.Copy(SkillsText, 0, bytes, i, SkillsText.Length); i += SkillsText.Length;
                bytes[i++] = (byte)((Identified) ? 1 : 0);
                bytes[i++] = (byte)BornOn.Length;
                Array.Copy(BornOn, 0, bytes, i, BornOn.Length); i += BornOn.Length;
                bytes[i++] = (byte)((MaturePublish) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>AvatarID field</summary>
            public LLUUID AvatarID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    AvatarID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(AvatarID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPropertiesReply</summary>
        public override PacketType Type { get { return PacketType.AvatarPropertiesReply; } }
        /// <summary>PropertiesData block</summary>
        public PropertiesDataBlock PropertiesData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPropertiesReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 215;
            Header.Reliable = true;
            Header.Zerocoded = true;
            PropertiesData = new PropertiesDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPropertiesReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PropertiesData = new PropertiesDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPropertiesReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PropertiesData = new PropertiesDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PropertiesData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PropertiesData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarGroupsReply packet</summary>
    public class AvatarGroupsReplyPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>AvatarID field</summary>
            public LLUUID AvatarID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    AvatarID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(AvatarID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            private byte[] _grouptitle;
            /// <summary>GroupTitle field</summary>
            public byte[] GroupTitle
            {
                get { return _grouptitle; }
                set
                {
                    if (value == null) { _grouptitle = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _grouptitle = new byte[value.Length]; Array.Copy(value, _grouptitle, value.Length); }
                }
            }
            /// <summary>GroupPowers field</summary>
            public ulong GroupPowers;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>GroupInsigniaID field</summary>
            public LLUUID GroupInsigniaID;
            /// <summary>AcceptNotices field</summary>
            public bool AcceptNotices;
            private byte[] _groupname;
            /// <summary>GroupName field</summary>
            public byte[] GroupName
            {
                get { return _groupname; }
                set
                {
                    if (value == null) { _groupname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _groupname = new byte[value.Length]; Array.Copy(value, _groupname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 42;
                    if (GroupTitle != null) { length += 1 + GroupTitle.Length; }
                    if (GroupName != null) { length += 1 + GroupName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _grouptitle = new byte[length];
                    Array.Copy(bytes, i, _grouptitle, 0, length); i += length;
                    GroupPowers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    GroupInsigniaID = new LLUUID(bytes, i); i += 16;
                    AcceptNotices = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _groupname = new byte[length];
                    Array.Copy(bytes, i, _groupname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)GroupTitle.Length;
                Array.Copy(GroupTitle, 0, bytes, i, GroupTitle.Length); i += GroupTitle.Length;
                bytes[i++] = (byte)(GroupPowers % 256);
                bytes[i++] = (byte)((GroupPowers >> 8) % 256);
                bytes[i++] = (byte)((GroupPowers >> 16) % 256);
                bytes[i++] = (byte)((GroupPowers >> 24) % 256);
                bytes[i++] = (byte)((GroupPowers >> 32) % 256);
                bytes[i++] = (byte)((GroupPowers >> 40) % 256);
                bytes[i++] = (byte)((GroupPowers >> 48) % 256);
                bytes[i++] = (byte)((GroupPowers >> 56) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupInsigniaID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AcceptNotices) ? 1 : 0);
                bytes[i++] = (byte)GroupName.Length;
                Array.Copy(GroupName, 0, bytes, i, GroupName.Length); i += GroupName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarGroupsReply</summary>
        public override PacketType Type { get { return PacketType.AvatarGroupsReply; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock[] GroupData;

        /// <summary>Default constructor</summary>
        public AvatarGroupsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 216;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarGroupsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarGroupsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < GroupData.Length; j++) { length += GroupData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)GroupData.Length;
            for (int j = 0; j < GroupData.Length; j++) { GroupData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPropertiesUpdate packet</summary>
    public class AvatarPropertiesUpdatePacket : Packet
    {
        /// <summary>PropertiesData block</summary>
        public class PropertiesDataBlock
        {
            private byte[] _abouttext;
            /// <summary>AboutText field</summary>
            public byte[] AboutText
            {
                get { return _abouttext; }
                set
                {
                    if (value == null) { _abouttext = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _abouttext = new byte[value.Length]; Array.Copy(value, _abouttext, value.Length); }
                }
            }
            private byte[] _flabouttext;
            /// <summary>FLAboutText field</summary>
            public byte[] FLAboutText
            {
                get { return _flabouttext; }
                set
                {
                    if (value == null) { _flabouttext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _flabouttext = new byte[value.Length]; Array.Copy(value, _flabouttext, value.Length); }
                }
            }
            /// <summary>ImageID field</summary>
            public LLUUID ImageID;
            /// <summary>FLImageID field</summary>
            public LLUUID FLImageID;
            /// <summary>AllowPublish field</summary>
            public bool AllowPublish;
            /// <summary>WantToMask field</summary>
            public uint WantToMask;
            private byte[] _wanttotext;
            /// <summary>WantToText field</summary>
            public byte[] WantToText
            {
                get { return _wanttotext; }
                set
                {
                    if (value == null) { _wanttotext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _wanttotext = new byte[value.Length]; Array.Copy(value, _wanttotext, value.Length); }
                }
            }
            /// <summary>SkillsMask field</summary>
            public uint SkillsMask;
            private byte[] _skillstext;
            /// <summary>SkillsText field</summary>
            public byte[] SkillsText
            {
                get { return _skillstext; }
                set
                {
                    if (value == null) { _skillstext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _skillstext = new byte[value.Length]; Array.Copy(value, _skillstext, value.Length); }
                }
            }
            /// <summary>MaturePublish field</summary>
            public bool MaturePublish;
            /// <summary>AvatarID field</summary>
            public LLUUID AvatarID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 58;
                    if (AboutText != null) { length += 2 + AboutText.Length; }
                    if (FLAboutText != null) { length += 1 + FLAboutText.Length; }
                    if (WantToText != null) { length += 1 + WantToText.Length; }
                    if (SkillsText != null) { length += 1 + SkillsText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PropertiesDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PropertiesDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _abouttext = new byte[length];
                    Array.Copy(bytes, i, _abouttext, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _flabouttext = new byte[length];
                    Array.Copy(bytes, i, _flabouttext, 0, length); i += length;
                    ImageID = new LLUUID(bytes, i); i += 16;
                    FLImageID = new LLUUID(bytes, i); i += 16;
                    AllowPublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    WantToMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _wanttotext = new byte[length];
                    Array.Copy(bytes, i, _wanttotext, 0, length); i += length;
                    SkillsMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _skillstext = new byte[length];
                    Array.Copy(bytes, i, _skillstext, 0, length); i += length;
                    MaturePublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    AvatarID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(AboutText.Length % 256);
                bytes[i++] = (byte)((AboutText.Length >> 8) % 256);
                Array.Copy(AboutText, 0, bytes, i, AboutText.Length); i += AboutText.Length;
                bytes[i++] = (byte)FLAboutText.Length;
                Array.Copy(FLAboutText, 0, bytes, i, FLAboutText.Length); i += FLAboutText.Length;
                Array.Copy(ImageID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FLImageID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AllowPublish) ? 1 : 0);
                bytes[i++] = (byte)(WantToMask % 256);
                bytes[i++] = (byte)((WantToMask >> 8) % 256);
                bytes[i++] = (byte)((WantToMask >> 16) % 256);
                bytes[i++] = (byte)((WantToMask >> 24) % 256);
                bytes[i++] = (byte)WantToText.Length;
                Array.Copy(WantToText, 0, bytes, i, WantToText.Length); i += WantToText.Length;
                bytes[i++] = (byte)(SkillsMask % 256);
                bytes[i++] = (byte)((SkillsMask >> 8) % 256);
                bytes[i++] = (byte)((SkillsMask >> 16) % 256);
                bytes[i++] = (byte)((SkillsMask >> 24) % 256);
                bytes[i++] = (byte)SkillsText.Length;
                Array.Copy(SkillsText, 0, bytes, i, SkillsText.Length); i += SkillsText.Length;
                bytes[i++] = (byte)((MaturePublish) ? 1 : 0);
                Array.Copy(AvatarID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPropertiesUpdate</summary>
        public override PacketType Type { get { return PacketType.AvatarPropertiesUpdate; } }
        /// <summary>PropertiesData block</summary>
        public PropertiesDataBlock PropertiesData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPropertiesUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 217;
            Header.Reliable = true;
            Header.Zerocoded = true;
            PropertiesData = new PropertiesDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPropertiesUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PropertiesData = new PropertiesDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPropertiesUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PropertiesData = new PropertiesDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PropertiesData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PropertiesData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarStatisticsReply packet</summary>
    public class AvatarStatisticsReplyPacket : Packet
    {
        /// <summary>StatisticsData block</summary>
        public class StatisticsDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Negative field</summary>
            public int Negative;
            /// <summary>Positive field</summary>
            public int Positive;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public StatisticsDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public StatisticsDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Negative = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Positive = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Negative % 256);
                bytes[i++] = (byte)((Negative >> 8) % 256);
                bytes[i++] = (byte)((Negative >> 16) % 256);
                bytes[i++] = (byte)((Negative >> 24) % 256);
                bytes[i++] = (byte)(Positive % 256);
                bytes[i++] = (byte)((Positive >> 8) % 256);
                bytes[i++] = (byte)((Positive >> 16) % 256);
                bytes[i++] = (byte)((Positive >> 24) % 256);
            }
        }

        /// <summary>AvatarData block</summary>
        public class AvatarDataBlock
        {
            /// <summary>AvatarID field</summary>
            public LLUUID AvatarID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AvatarDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AvatarDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AvatarID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AvatarID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarStatisticsReply</summary>
        public override PacketType Type { get { return PacketType.AvatarStatisticsReply; } }
        /// <summary>StatisticsData block</summary>
        public StatisticsDataBlock[] StatisticsData;
        /// <summary>AvatarData block</summary>
        public AvatarDataBlock AvatarData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarStatisticsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 218;
            Header.Reliable = true;
            Header.Zerocoded = true;
            StatisticsData = new StatisticsDataBlock[0];
            AvatarData = new AvatarDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarStatisticsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            StatisticsData = new StatisticsDataBlock[count];
            for (int j = 0; j < count; j++)
            { StatisticsData[j] = new StatisticsDataBlock(bytes, ref i); }
            AvatarData = new AvatarDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarStatisticsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            StatisticsData = new StatisticsDataBlock[count];
            for (int j = 0; j < count; j++)
            { StatisticsData[j] = new StatisticsDataBlock(bytes, ref i); }
            AvatarData = new AvatarDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AvatarData.Length;            length += AgentData.Length;;
            for (int j = 0; j < StatisticsData.Length; j++) { length += StatisticsData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)StatisticsData.Length;
            for (int j = 0; j < StatisticsData.Length; j++) { StatisticsData[j].ToBytes(bytes, ref i); }
            AvatarData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarNotesReply packet</summary>
    public class AvatarNotesReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;
            private byte[] _notes;
            /// <summary>Notes field</summary>
            public byte[] Notes
            {
                get { return _notes; }
                set
                {
                    if (value == null) { _notes = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _notes = new byte[value.Length]; Array.Copy(value, _notes, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Notes != null) { length += 2 + Notes.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    TargetID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _notes = new byte[length];
                    Array.Copy(bytes, i, _notes, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Notes.Length % 256);
                bytes[i++] = (byte)((Notes.Length >> 8) % 256);
                Array.Copy(Notes, 0, bytes, i, Notes.Length); i += Notes.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarNotesReply</summary>
        public override PacketType Type { get { return PacketType.AvatarNotesReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarNotesReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 219;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarNotesReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarNotesReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarNotesUpdate packet</summary>
    public class AvatarNotesUpdatePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;
            private byte[] _notes;
            /// <summary>Notes field</summary>
            public byte[] Notes
            {
                get { return _notes; }
                set
                {
                    if (value == null) { _notes = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _notes = new byte[value.Length]; Array.Copy(value, _notes, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Notes != null) { length += 2 + Notes.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    TargetID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _notes = new byte[length];
                    Array.Copy(bytes, i, _notes, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Notes.Length % 256);
                bytes[i++] = (byte)((Notes.Length >> 8) % 256);
                Array.Copy(Notes, 0, bytes, i, Notes.Length); i += Notes.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarNotesUpdate</summary>
        public override PacketType Type { get { return PacketType.AvatarNotesUpdate; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarNotesUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 220;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarNotesUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarNotesUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarPicksReply packet</summary>
    public class AvatarPicksReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _pickname;
            /// <summary>PickName field</summary>
            public byte[] PickName
            {
                get { return _pickname; }
                set
                {
                    if (value == null) { _pickname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _pickname = new byte[value.Length]; Array.Copy(value, _pickname, value.Length); }
                }
            }
            /// <summary>PickID field</summary>
            public LLUUID PickID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (PickName != null) { length += 1 + PickName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _pickname = new byte[length];
                    Array.Copy(bytes, i, _pickname, 0, length); i += length;
                    PickID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)PickName.Length;
                Array.Copy(PickName, 0, bytes, i, PickName.Length); i += PickName.Length;
                Array.Copy(PickID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    TargetID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarPicksReply</summary>
        public override PacketType Type { get { return PacketType.AvatarPicksReply; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AvatarPicksReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 221;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarPicksReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarPicksReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EventInfoRequest packet</summary>
    public class EventInfoRequestPacket : Packet
    {
        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>EventID field</summary>
            public uint EventID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EventInfoRequest</summary>
        public override PacketType Type { get { return PacketType.EventInfoRequest; } }
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EventInfoRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 222;
            Header.Reliable = true;
            EventData = new EventDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EventInfoRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EventInfoRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += EventData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EventInfoReply packet</summary>
    public class EventInfoReplyPacket : Packet
    {
        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>Duration field</summary>
            public uint Duration;
            /// <summary>DateUTC field</summary>
            public uint DateUTC;
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>GlobalPos field</summary>
            public LLVector3d GlobalPos;
            private byte[] _creator;
            /// <summary>Creator field</summary>
            public byte[] Creator
            {
                get { return _creator; }
                set
                {
                    if (value == null) { _creator = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _creator = new byte[value.Length]; Array.Copy(value, _creator, value.Length); }
                }
            }
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _date;
            /// <summary>Date field</summary>
            public byte[] Date
            {
                get { return _date; }
                set
                {
                    if (value == null) { _date = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _date = new byte[value.Length]; Array.Copy(value, _date, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            /// <summary>EventID field</summary>
            public uint EventID;
            private byte[] _category;
            /// <summary>Category field</summary>
            public byte[] Category
            {
                get { return _category; }
                set
                {
                    if (value == null) { _category = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _category = new byte[value.Length]; Array.Copy(value, _category, value.Length); }
                }
            }
            /// <summary>EventFlags field</summary>
            public uint EventFlags;
            /// <summary>Amount field</summary>
            public uint Amount;
            /// <summary>Cover field</summary>
            public uint Cover;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (Creator != null) { length += 1 + Creator.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Date != null) { length += 1 + Date.Length; }
                    if (Desc != null) { length += 2 + Desc.Length; }
                    if (Category != null) { length += 1 + Category.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Duration = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    DateUTC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    GlobalPos = new LLVector3d(bytes, i); i += 24;
                    length = (ushort)bytes[i++];
                    _creator = new byte[length];
                    Array.Copy(bytes, i, _creator, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _date = new byte[length];
                    Array.Copy(bytes, i, _date, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _category = new byte[length];
                    Array.Copy(bytes, i, _category, 0, length); i += length;
                    EventFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Amount = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Cover = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Duration % 256);
                bytes[i++] = (byte)((Duration >> 8) % 256);
                bytes[i++] = (byte)((Duration >> 16) % 256);
                bytes[i++] = (byte)((Duration >> 24) % 256);
                bytes[i++] = (byte)(DateUTC % 256);
                bytes[i++] = (byte)((DateUTC >> 8) % 256);
                bytes[i++] = (byte)((DateUTC >> 16) % 256);
                bytes[i++] = (byte)((DateUTC >> 24) % 256);
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(GlobalPos.GetBytes(), 0, bytes, i, 24); i += 24;
                bytes[i++] = (byte)Creator.Length;
                Array.Copy(Creator, 0, bytes, i, Creator.Length); i += Creator.Length;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)Date.Length;
                Array.Copy(Date, 0, bytes, i, Date.Length); i += Date.Length;
                bytes[i++] = (byte)(Desc.Length % 256);
                bytes[i++] = (byte)((Desc.Length >> 8) % 256);
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
                bytes[i++] = (byte)Category.Length;
                Array.Copy(Category, 0, bytes, i, Category.Length); i += Category.Length;
                bytes[i++] = (byte)(EventFlags % 256);
                bytes[i++] = (byte)((EventFlags >> 8) % 256);
                bytes[i++] = (byte)((EventFlags >> 16) % 256);
                bytes[i++] = (byte)((EventFlags >> 24) % 256);
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)(Cover % 256);
                bytes[i++] = (byte)((Cover >> 8) % 256);
                bytes[i++] = (byte)((Cover >> 16) % 256);
                bytes[i++] = (byte)((Cover >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EventInfoReply</summary>
        public override PacketType Type { get { return PacketType.EventInfoReply; } }
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EventInfoReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 223;
            Header.Reliable = true;
            EventData = new EventDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EventInfoReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EventInfoReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += EventData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EventNotificationAddRequest packet</summary>
    public class EventNotificationAddRequestPacket : Packet
    {
        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>EventID field</summary>
            public uint EventID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EventNotificationAddRequest</summary>
        public override PacketType Type { get { return PacketType.EventNotificationAddRequest; } }
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EventNotificationAddRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 224;
            Header.Reliable = true;
            EventData = new EventDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EventNotificationAddRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EventNotificationAddRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += EventData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EventNotificationRemoveRequest packet</summary>
    public class EventNotificationRemoveRequestPacket : Packet
    {
        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>EventID field</summary>
            public uint EventID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EventNotificationRemoveRequest</summary>
        public override PacketType Type { get { return PacketType.EventNotificationRemoveRequest; } }
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EventNotificationRemoveRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 225;
            Header.Reliable = true;
            EventData = new EventDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EventNotificationRemoveRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EventNotificationRemoveRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += EventData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EventGodDelete packet</summary>
    public class EventGodDeletePacket : Packet
    {
        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>EventID field</summary>
            public uint EventID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>QueryFlags field</summary>
            public uint QueryFlags;
            /// <summary>QueryStart field</summary>
            public int QueryStart;
            private byte[] _querytext;
            /// <summary>QueryText field</summary>
            public byte[] QueryText
            {
                get { return _querytext; }
                set
                {
                    if (value == null) { _querytext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _querytext = new byte[value.Length]; Array.Copy(value, _querytext, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (QueryText != null) { length += 1 + QueryText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    QueryFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    QueryStart = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _querytext = new byte[length];
                    Array.Copy(bytes, i, _querytext, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(QueryFlags % 256);
                bytes[i++] = (byte)((QueryFlags >> 8) % 256);
                bytes[i++] = (byte)((QueryFlags >> 16) % 256);
                bytes[i++] = (byte)((QueryFlags >> 24) % 256);
                bytes[i++] = (byte)(QueryStart % 256);
                bytes[i++] = (byte)((QueryStart >> 8) % 256);
                bytes[i++] = (byte)((QueryStart >> 16) % 256);
                bytes[i++] = (byte)((QueryStart >> 24) % 256);
                bytes[i++] = (byte)QueryText.Length;
                Array.Copy(QueryText, 0, bytes, i, QueryText.Length); i += QueryText.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EventGodDelete</summary>
        public override PacketType Type { get { return PacketType.EventGodDelete; } }
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EventGodDeletePacket()
        {
            Header = new LowHeader();
            Header.ID = 226;
            Header.Reliable = true;
            EventData = new EventDataBlock();
            QueryData = new QueryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EventGodDeletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            EventData = new EventDataBlock(bytes, ref i);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EventGodDeletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EventData = new EventDataBlock(bytes, ref i);
            QueryData = new QueryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += EventData.Length;            length += QueryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PickInfoRequest packet</summary>
    public class PickInfoRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>PickID field</summary>
            public LLUUID PickID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PickID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(PickID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PickInfoRequest</summary>
        public override PacketType Type { get { return PacketType.PickInfoRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public PickInfoRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 227;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PickInfoRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PickInfoRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PickInfoReply packet</summary>
    public class PickInfoReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _originalname;
            /// <summary>OriginalName field</summary>
            public byte[] OriginalName
            {
                get { return _originalname; }
                set
                {
                    if (value == null) { _originalname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _originalname = new byte[value.Length]; Array.Copy(value, _originalname, value.Length); }
                }
            }
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>Enabled field</summary>
            public bool Enabled;
            /// <summary>PosGlobal field</summary>
            public LLVector3d PosGlobal;
            /// <summary>TopPick field</summary>
            public bool TopPick;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            private byte[] _user;
            /// <summary>User field</summary>
            public byte[] User
            {
                get { return _user; }
                set
                {
                    if (value == null) { _user = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _user = new byte[value.Length]; Array.Copy(value, _user, value.Length); }
                }
            }
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>PickID field</summary>
            public LLUUID PickID;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>SortOrder field</summary>
            public int SortOrder;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 94;
                    if (OriginalName != null) { length += 1 + OriginalName.Length; }
                    if (SimName != null) { length += 1 + SimName.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 2 + Desc.Length; }
                    if (User != null) { length += 1 + User.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _originalname = new byte[length];
                    Array.Copy(bytes, i, _originalname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    Enabled = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    PosGlobal = new LLVector3d(bytes, i); i += 24;
                    TopPick = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _user = new byte[length];
                    Array.Copy(bytes, i, _user, 0, length); i += length;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    PickID = new LLUUID(bytes, i); i += 16;
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    SortOrder = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)OriginalName.Length;
                Array.Copy(OriginalName, 0, bytes, i, OriginalName.Length); i += OriginalName.Length;
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = (byte)((Enabled) ? 1 : 0);
                Array.Copy(PosGlobal.GetBytes(), 0, bytes, i, 24); i += 24;
                bytes[i++] = (byte)((TopPick) ? 1 : 0);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Desc.Length % 256);
                bytes[i++] = (byte)((Desc.Length >> 8) % 256);
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                bytes[i++] = (byte)User.Length;
                Array.Copy(User, 0, bytes, i, User.Length); i += User.Length;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(PickID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SortOrder % 256);
                bytes[i++] = (byte)((SortOrder >> 8) % 256);
                bytes[i++] = (byte)((SortOrder >> 16) % 256);
                bytes[i++] = (byte)((SortOrder >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PickInfoReply</summary>
        public override PacketType Type { get { return PacketType.PickInfoReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public PickInfoReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 228;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PickInfoReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PickInfoReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PickInfoUpdate packet</summary>
    public class PickInfoUpdatePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>Enabled field</summary>
            public bool Enabled;
            /// <summary>PosGlobal field</summary>
            public LLVector3d PosGlobal;
            /// <summary>TopPick field</summary>
            public bool TopPick;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>PickID field</summary>
            public LLUUID PickID;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>SortOrder field</summary>
            public int SortOrder;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 94;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 2 + Desc.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Enabled = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    PosGlobal = new LLVector3d(bytes, i); i += 24;
                    TopPick = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    PickID = new LLUUID(bytes, i); i += 16;
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    SortOrder = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Enabled) ? 1 : 0);
                Array.Copy(PosGlobal.GetBytes(), 0, bytes, i, 24); i += 24;
                bytes[i++] = (byte)((TopPick) ? 1 : 0);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Desc.Length % 256);
                bytes[i++] = (byte)((Desc.Length >> 8) % 256);
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(PickID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SortOrder % 256);
                bytes[i++] = (byte)((SortOrder >> 8) % 256);
                bytes[i++] = (byte)((SortOrder >> 16) % 256);
                bytes[i++] = (byte)((SortOrder >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PickInfoUpdate</summary>
        public override PacketType Type { get { return PacketType.PickInfoUpdate; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public PickInfoUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 229;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PickInfoUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PickInfoUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PickDelete packet</summary>
    public class PickDeletePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>PickID field</summary>
            public LLUUID PickID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PickID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(PickID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PickDelete</summary>
        public override PacketType Type { get { return PacketType.PickDelete; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public PickDeletePacket()
        {
            Header = new LowHeader();
            Header.ID = 230;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PickDeletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PickDeletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PickGodDelete packet</summary>
    public class PickGodDeletePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>PickID field</summary>
            public LLUUID PickID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    PickID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(PickID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PickGodDelete</summary>
        public override PacketType Type { get { return PacketType.PickGodDelete; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public PickGodDeletePacket()
        {
            Header = new LowHeader();
            Header.ID = 231;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PickGodDeletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PickGodDeletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptQuestion packet</summary>
    public class ScriptQuestionPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _objectname;
            /// <summary>ObjectName field</summary>
            public byte[] ObjectName
            {
                get { return _objectname; }
                set
                {
                    if (value == null) { _objectname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectname = new byte[value.Length]; Array.Copy(value, _objectname, value.Length); }
                }
            }
            private byte[] _objectowner;
            /// <summary>ObjectOwner field</summary>
            public byte[] ObjectOwner
            {
                get { return _objectowner; }
                set
                {
                    if (value == null) { _objectowner = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectowner = new byte[value.Length]; Array.Copy(value, _objectowner, value.Length); }
                }
            }
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>Questions field</summary>
            public int Questions;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    if (ObjectName != null) { length += 1 + ObjectName.Length; }
                    if (ObjectOwner != null) { length += 1 + ObjectOwner.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _objectname = new byte[length];
                    Array.Copy(bytes, i, _objectname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _objectowner = new byte[length];
                    Array.Copy(bytes, i, _objectowner, 0, length); i += length;
                    TaskID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    Questions = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)ObjectName.Length;
                Array.Copy(ObjectName, 0, bytes, i, ObjectName.Length); i += ObjectName.Length;
                bytes[i++] = (byte)ObjectOwner.Length;
                Array.Copy(ObjectOwner, 0, bytes, i, ObjectOwner.Length); i += ObjectOwner.Length;
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Questions % 256);
                bytes[i++] = (byte)((Questions >> 8) % 256);
                bytes[i++] = (byte)((Questions >> 16) % 256);
                bytes[i++] = (byte)((Questions >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptQuestion</summary>
        public override PacketType Type { get { return PacketType.ScriptQuestion; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public ScriptQuestionPacket()
        {
            Header = new LowHeader();
            Header.ID = 232;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptQuestionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptQuestionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptControlChange packet</summary>
    public class ScriptControlChangePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>PassToAgent field</summary>
            public bool PassToAgent;
            /// <summary>Controls field</summary>
            public uint Controls;
            /// <summary>TakeControls field</summary>
            public bool TakeControls;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 7;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PassToAgent = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Controls = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TakeControls = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((PassToAgent) ? 1 : 0);
                bytes[i++] = (byte)(Controls % 256);
                bytes[i++] = (byte)((Controls >> 8) % 256);
                bytes[i++] = (byte)((Controls >> 16) % 256);
                bytes[i++] = (byte)((Controls >> 24) % 256);
                bytes[i++] = (byte)((TakeControls) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptControlChange</summary>
        public override PacketType Type { get { return PacketType.ScriptControlChange; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;

        /// <summary>Default constructor</summary>
        public ScriptControlChangePacket()
        {
            Header = new LowHeader();
            Header.ID = 233;
            Header.Reliable = true;
            Data = new DataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptControlChangePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptControlChangePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptDialog packet</summary>
    public class ScriptDialogPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _objectname;
            /// <summary>ObjectName field</summary>
            public byte[] ObjectName
            {
                get { return _objectname; }
                set
                {
                    if (value == null) { _objectname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectname = new byte[value.Length]; Array.Copy(value, _objectname, value.Length); }
                }
            }
            /// <summary>ImageID field</summary>
            public LLUUID ImageID;
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            private byte[] _lastname;
            /// <summary>LastName field</summary>
            public byte[] LastName
            {
                get { return _lastname; }
                set
                {
                    if (value == null) { _lastname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lastname = new byte[value.Length]; Array.Copy(value, _lastname, value.Length); }
                }
            }
            private byte[] _firstname;
            /// <summary>FirstName field</summary>
            public byte[] FirstName
            {
                get { return _firstname; }
                set
                {
                    if (value == null) { _firstname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _firstname = new byte[value.Length]; Array.Copy(value, _firstname, value.Length); }
                }
            }
            /// <summary>ChatChannel field</summary>
            public int ChatChannel;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    if (ObjectName != null) { length += 1 + ObjectName.Length; }
                    if (Message != null) { length += 2 + Message.Length; }
                    if (LastName != null) { length += 1 + LastName.Length; }
                    if (FirstName != null) { length += 1 + FirstName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _objectname = new byte[length];
                    Array.Copy(bytes, i, _objectname, 0, length); i += length;
                    ImageID = new LLUUID(bytes, i); i += 16;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _lastname = new byte[length];
                    Array.Copy(bytes, i, _lastname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _firstname = new byte[length];
                    Array.Copy(bytes, i, _firstname, 0, length); i += length;
                    ChatChannel = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)ObjectName.Length;
                Array.Copy(ObjectName, 0, bytes, i, ObjectName.Length); i += ObjectName.Length;
                Array.Copy(ImageID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = (byte)LastName.Length;
                Array.Copy(LastName, 0, bytes, i, LastName.Length); i += LastName.Length;
                bytes[i++] = (byte)FirstName.Length;
                Array.Copy(FirstName, 0, bytes, i, FirstName.Length); i += FirstName.Length;
                bytes[i++] = (byte)(ChatChannel % 256);
                bytes[i++] = (byte)((ChatChannel >> 8) % 256);
                bytes[i++] = (byte)((ChatChannel >> 16) % 256);
                bytes[i++] = (byte)((ChatChannel >> 24) % 256);
            }
        }

        /// <summary>Buttons block</summary>
        public class ButtonsBlock
        {
            private byte[] _buttonlabel;
            /// <summary>ButtonLabel field</summary>
            public byte[] ButtonLabel
            {
                get { return _buttonlabel; }
                set
                {
                    if (value == null) { _buttonlabel = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _buttonlabel = new byte[value.Length]; Array.Copy(value, _buttonlabel, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (ButtonLabel != null) { length += 1 + ButtonLabel.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ButtonsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ButtonsBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _buttonlabel = new byte[length];
                    Array.Copy(bytes, i, _buttonlabel, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)ButtonLabel.Length;
                Array.Copy(ButtonLabel, 0, bytes, i, ButtonLabel.Length); i += ButtonLabel.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptDialog</summary>
        public override PacketType Type { get { return PacketType.ScriptDialog; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>Buttons block</summary>
        public ButtonsBlock[] Buttons;

        /// <summary>Default constructor</summary>
        public ScriptDialogPacket()
        {
            Header = new LowHeader();
            Header.ID = 234;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            Buttons = new ButtonsBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptDialogPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Buttons = new ButtonsBlock[count];
            for (int j = 0; j < count; j++)
            { Buttons[j] = new ButtonsBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptDialogPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Buttons = new ButtonsBlock[count];
            for (int j = 0; j < count; j++)
            { Buttons[j] = new ButtonsBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            for (int j = 0; j < Buttons.Length; j++) { length += Buttons[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Buttons.Length;
            for (int j = 0; j < Buttons.Length; j++) { Buttons[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptDialogReply packet</summary>
    public class ScriptDialogReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _buttonlabel;
            /// <summary>ButtonLabel field</summary>
            public byte[] ButtonLabel
            {
                get { return _buttonlabel; }
                set
                {
                    if (value == null) { _buttonlabel = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _buttonlabel = new byte[value.Length]; Array.Copy(value, _buttonlabel, value.Length); }
                }
            }
            /// <summary>ButtonIndex field</summary>
            public int ButtonIndex;
            /// <summary>ChatChannel field</summary>
            public int ChatChannel;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 40;
                    if (ButtonLabel != null) { length += 1 + ButtonLabel.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _buttonlabel = new byte[length];
                    Array.Copy(bytes, i, _buttonlabel, 0, length); i += length;
                    ButtonIndex = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ChatChannel = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)ButtonLabel.Length;
                Array.Copy(ButtonLabel, 0, bytes, i, ButtonLabel.Length); i += ButtonLabel.Length;
                bytes[i++] = (byte)(ButtonIndex % 256);
                bytes[i++] = (byte)((ButtonIndex >> 8) % 256);
                bytes[i++] = (byte)((ButtonIndex >> 16) % 256);
                bytes[i++] = (byte)((ButtonIndex >> 24) % 256);
                bytes[i++] = (byte)(ChatChannel % 256);
                bytes[i++] = (byte)((ChatChannel >> 8) % 256);
                bytes[i++] = (byte)((ChatChannel >> 16) % 256);
                bytes[i++] = (byte)((ChatChannel >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptDialogReply</summary>
        public override PacketType Type { get { return PacketType.ScriptDialogReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public ScriptDialogReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 235;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptDialogReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptDialogReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ForceScriptControlRelease packet</summary>
    public class ForceScriptControlReleasePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ForceScriptControlRelease</summary>
        public override PacketType Type { get { return PacketType.ForceScriptControlRelease; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public ForceScriptControlReleasePacket()
        {
            Header = new LowHeader();
            Header.ID = 236;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ForceScriptControlReleasePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ForceScriptControlReleasePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RevokePermissions packet</summary>
    public class RevokePermissionsPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ObjectPermissions field</summary>
            public uint ObjectPermissions;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectPermissions = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectPermissions % 256);
                bytes[i++] = (byte)((ObjectPermissions >> 8) % 256);
                bytes[i++] = (byte)((ObjectPermissions >> 16) % 256);
                bytes[i++] = (byte)((ObjectPermissions >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RevokePermissions</summary>
        public override PacketType Type { get { return PacketType.RevokePermissions; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public RevokePermissionsPacket()
        {
            Header = new LowHeader();
            Header.ID = 237;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RevokePermissionsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RevokePermissionsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LoadURL packet</summary>
    public class LoadURLPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _url;
            /// <summary>URL field</summary>
            public byte[] URL
            {
                get { return _url; }
                set
                {
                    if (value == null) { _url = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _url = new byte[value.Length]; Array.Copy(value, _url, value.Length); }
                }
            }
            private byte[] _objectname;
            /// <summary>ObjectName field</summary>
            public byte[] ObjectName
            {
                get { return _objectname; }
                set
                {
                    if (value == null) { _objectname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectname = new byte[value.Length]; Array.Copy(value, _objectname, value.Length); }
                }
            }
            /// <summary>OwnerIsGroup field</summary>
            public bool OwnerIsGroup;
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    if (URL != null) { length += 1 + URL.Length; }
                    if (ObjectName != null) { length += 1 + ObjectName.Length; }
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _url = new byte[length];
                    Array.Copy(bytes, i, _url, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _objectname = new byte[length];
                    Array.Copy(bytes, i, _objectname, 0, length); i += length;
                    OwnerIsGroup = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)URL.Length;
                Array.Copy(URL, 0, bytes, i, URL.Length); i += URL.Length;
                bytes[i++] = (byte)ObjectName.Length;
                Array.Copy(ObjectName, 0, bytes, i, ObjectName.Length); i += ObjectName.Length;
                bytes[i++] = (byte)((OwnerIsGroup) ? 1 : 0);
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LoadURL</summary>
        public override PacketType Type { get { return PacketType.LoadURL; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public LoadURLPacket()
        {
            Header = new LowHeader();
            Header.ID = 238;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LoadURLPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LoadURLPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptTeleportRequest packet</summary>
    public class ScriptTeleportRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            private byte[] _objectname;
            /// <summary>ObjectName field</summary>
            public byte[] ObjectName
            {
                get { return _objectname; }
                set
                {
                    if (value == null) { _objectname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectname = new byte[value.Length]; Array.Copy(value, _objectname, value.Length); }
                }
            }
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>SimPosition field</summary>
            public LLVector3 SimPosition;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (ObjectName != null) { length += 1 + ObjectName.Length; }
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _objectname = new byte[length];
                    Array.Copy(bytes, i, _objectname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    LookAt = new LLVector3(bytes, i); i += 12;
                    SimPosition = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)ObjectName.Length;
                Array.Copy(ObjectName, 0, bytes, i, ObjectName.Length); i += ObjectName.Length;
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(SimPosition.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptTeleportRequest</summary>
        public override PacketType Type { get { return PacketType.ScriptTeleportRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public ScriptTeleportRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 239;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptTeleportRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptTeleportRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelOverlay packet</summary>
    public class ParcelOverlayPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }
            /// <summary>SequenceID field</summary>
            public int SequenceID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    if (Data != null) { length += 2 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                    SequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
                bytes[i++] = (byte)(SequenceID % 256);
                bytes[i++] = (byte)((SequenceID >> 8) % 256);
                bytes[i++] = (byte)((SequenceID >> 16) % 256);
                bytes[i++] = (byte)((SequenceID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelOverlay</summary>
        public override PacketType Type { get { return PacketType.ParcelOverlay; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;

        /// <summary>Default constructor</summary>
        public ParcelOverlayPacket()
        {
            Header = new LowHeader();
            Header.ID = 240;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelOverlayPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelOverlayPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelPropertiesRequestByID packet</summary>
    public class ParcelPropertiesRequestByIDPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>SequenceID field</summary>
            public int SequenceID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(SequenceID % 256);
                bytes[i++] = (byte)((SequenceID >> 8) % 256);
                bytes[i++] = (byte)((SequenceID >> 16) % 256);
                bytes[i++] = (byte)((SequenceID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelPropertiesRequestByID</summary>
        public override PacketType Type { get { return PacketType.ParcelPropertiesRequestByID; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelPropertiesRequestByIDPacket()
        {
            Header = new LowHeader();
            Header.ID = 241;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelPropertiesRequestByIDPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelPropertiesRequestByIDPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelPropertiesUpdate packet</summary>
    public class ParcelPropertiesUpdatePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>MediaID field</summary>
            public LLUUID MediaID;
            /// <summary>UserLookAt field</summary>
            public LLVector3 UserLookAt;
            private byte[] _mediaurl;
            /// <summary>MediaURL field</summary>
            public byte[] MediaURL
            {
                get { return _mediaurl; }
                set
                {
                    if (value == null) { _mediaurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mediaurl = new byte[value.Length]; Array.Copy(value, _mediaurl, value.Length); }
                }
            }
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>UserLocation field</summary>
            public LLVector3 UserLocation;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            /// <summary>Category field</summary>
            public byte Category;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>LandingType field</summary>
            public byte LandingType;
            /// <summary>AuthBuyerID field</summary>
            public LLUUID AuthBuyerID;
            /// <summary>PassHours field</summary>
            public float PassHours;
            /// <summary>ParcelFlags field</summary>
            public uint ParcelFlags;
            /// <summary>PassPrice field</summary>
            public int PassPrice;
            /// <summary>MediaAutoScale field</summary>
            public byte MediaAutoScale;
            private byte[] _musicurl;
            /// <summary>MusicURL field</summary>
            public byte[] MusicURL
            {
                get { return _musicurl; }
                set
                {
                    if (value == null) { _musicurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _musicurl = new byte[value.Length]; Array.Copy(value, _musicurl, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 115;
                    if (MediaURL != null) { length += 1 + MediaURL.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 1 + Desc.Length; }
                    if (MusicURL != null) { length += 1 + MusicURL.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    MediaID = new LLUUID(bytes, i); i += 16;
                    UserLookAt = new LLVector3(bytes, i); i += 12;
                    length = (ushort)bytes[i++];
                    _mediaurl = new byte[length];
                    Array.Copy(bytes, i, _mediaurl, 0, length); i += length;
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    UserLocation = new LLVector3(bytes, i); i += 12;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    Category = (byte)bytes[i++];
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LandingType = (byte)bytes[i++];
                    AuthBuyerID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    PassHours = BitConverter.ToSingle(bytes, i); i += 4;
                    ParcelFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PassPrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MediaAutoScale = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _musicurl = new byte[length];
                    Array.Copy(bytes, i, _musicurl, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(MediaID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(UserLookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)MediaURL.Length;
                Array.Copy(MediaURL, 0, bytes, i, MediaURL.Length); i += MediaURL.Length;
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(UserLocation.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)Desc.Length;
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                bytes[i++] = Category;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = LandingType;
                Array.Copy(AuthBuyerID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(PassHours);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(ParcelFlags % 256);
                bytes[i++] = (byte)((ParcelFlags >> 8) % 256);
                bytes[i++] = (byte)((ParcelFlags >> 16) % 256);
                bytes[i++] = (byte)((ParcelFlags >> 24) % 256);
                bytes[i++] = (byte)(PassPrice % 256);
                bytes[i++] = (byte)((PassPrice >> 8) % 256);
                bytes[i++] = (byte)((PassPrice >> 16) % 256);
                bytes[i++] = (byte)((PassPrice >> 24) % 256);
                bytes[i++] = MediaAutoScale;
                bytes[i++] = (byte)MusicURL.Length;
                Array.Copy(MusicURL, 0, bytes, i, MusicURL.Length); i += MusicURL.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelPropertiesUpdate</summary>
        public override PacketType Type { get { return PacketType.ParcelPropertiesUpdate; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelPropertiesUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 242;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelPropertiesUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelPropertiesUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelReturnObjects packet</summary>
    public class ParcelReturnObjectsPacket : Packet
    {
        /// <summary>TaskIDs block</summary>
        public class TaskIDsBlock
        {
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TaskIDsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TaskIDsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TaskID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>ReturnType field</summary>
            public uint ReturnType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ReturnType = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(ReturnType % 256);
                bytes[i++] = (byte)((ReturnType >> 8) % 256);
                bytes[i++] = (byte)((ReturnType >> 16) % 256);
                bytes[i++] = (byte)((ReturnType >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>OwnerIDs block</summary>
        public class OwnerIDsBlock
        {
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public OwnerIDsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public OwnerIDsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    OwnerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelReturnObjects</summary>
        public override PacketType Type { get { return PacketType.ParcelReturnObjects; } }
        /// <summary>TaskIDs block</summary>
        public TaskIDsBlock[] TaskIDs;
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>OwnerIDs block</summary>
        public OwnerIDsBlock[] OwnerIDs;

        /// <summary>Default constructor</summary>
        public ParcelReturnObjectsPacket()
        {
            Header = new LowHeader();
            Header.ID = 243;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TaskIDs = new TaskIDsBlock[0];
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
            OwnerIDs = new OwnerIDsBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelReturnObjectsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            TaskIDs = new TaskIDsBlock[count];
            for (int j = 0; j < count; j++)
            { TaskIDs[j] = new TaskIDsBlock(bytes, ref i); }
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            OwnerIDs = new OwnerIDsBlock[count];
            for (int j = 0; j < count; j++)
            { OwnerIDs[j] = new OwnerIDsBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelReturnObjectsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            TaskIDs = new TaskIDsBlock[count];
            for (int j = 0; j < count; j++)
            { TaskIDs[j] = new TaskIDsBlock(bytes, ref i); }
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            OwnerIDs = new OwnerIDsBlock[count];
            for (int j = 0; j < count; j++)
            { OwnerIDs[j] = new OwnerIDsBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            for (int j = 0; j < TaskIDs.Length; j++) { length += TaskIDs[j].Length; }
            for (int j = 0; j < OwnerIDs.Length; j++) { length += OwnerIDs[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)TaskIDs.Length;
            for (int j = 0; j < TaskIDs.Length; j++) { TaskIDs[j].ToBytes(bytes, ref i); }
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)OwnerIDs.Length;
            for (int j = 0; j < OwnerIDs.Length; j++) { OwnerIDs[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelSetOtherCleanTime packet</summary>
    public class ParcelSetOtherCleanTimePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>OtherCleanTime field</summary>
            public int OtherCleanTime;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OtherCleanTime = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(OtherCleanTime % 256);
                bytes[i++] = (byte)((OtherCleanTime >> 8) % 256);
                bytes[i++] = (byte)((OtherCleanTime >> 16) % 256);
                bytes[i++] = (byte)((OtherCleanTime >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelSetOtherCleanTime</summary>
        public override PacketType Type { get { return PacketType.ParcelSetOtherCleanTime; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelSetOtherCleanTimePacket()
        {
            Header = new LowHeader();
            Header.ID = 244;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelSetOtherCleanTimePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelSetOtherCleanTimePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelDisableObjects packet</summary>
    public class ParcelDisableObjectsPacket : Packet
    {
        /// <summary>TaskIDs block</summary>
        public class TaskIDsBlock
        {
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TaskIDsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TaskIDsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TaskID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>ReturnType field</summary>
            public uint ReturnType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ReturnType = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(ReturnType % 256);
                bytes[i++] = (byte)((ReturnType >> 8) % 256);
                bytes[i++] = (byte)((ReturnType >> 16) % 256);
                bytes[i++] = (byte)((ReturnType >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>OwnerIDs block</summary>
        public class OwnerIDsBlock
        {
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public OwnerIDsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public OwnerIDsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    OwnerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelDisableObjects</summary>
        public override PacketType Type { get { return PacketType.ParcelDisableObjects; } }
        /// <summary>TaskIDs block</summary>
        public TaskIDsBlock[] TaskIDs;
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>OwnerIDs block</summary>
        public OwnerIDsBlock[] OwnerIDs;

        /// <summary>Default constructor</summary>
        public ParcelDisableObjectsPacket()
        {
            Header = new LowHeader();
            Header.ID = 245;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TaskIDs = new TaskIDsBlock[0];
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
            OwnerIDs = new OwnerIDsBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelDisableObjectsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            TaskIDs = new TaskIDsBlock[count];
            for (int j = 0; j < count; j++)
            { TaskIDs[j] = new TaskIDsBlock(bytes, ref i); }
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            OwnerIDs = new OwnerIDsBlock[count];
            for (int j = 0; j < count; j++)
            { OwnerIDs[j] = new OwnerIDsBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelDisableObjectsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            TaskIDs = new TaskIDsBlock[count];
            for (int j = 0; j < count; j++)
            { TaskIDs[j] = new TaskIDsBlock(bytes, ref i); }
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            OwnerIDs = new OwnerIDsBlock[count];
            for (int j = 0; j < count; j++)
            { OwnerIDs[j] = new OwnerIDsBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            for (int j = 0; j < TaskIDs.Length; j++) { length += TaskIDs[j].Length; }
            for (int j = 0; j < OwnerIDs.Length; j++) { length += OwnerIDs[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)TaskIDs.Length;
            for (int j = 0; j < TaskIDs.Length; j++) { TaskIDs[j].ToBytes(bytes, ref i); }
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)OwnerIDs.Length;
            for (int j = 0; j < OwnerIDs.Length; j++) { OwnerIDs[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelSelectObjects packet</summary>
    public class ParcelSelectObjectsPacket : Packet
    {
        /// <summary>ReturnIDs block</summary>
        public class ReturnIDsBlock
        {
            /// <summary>ReturnID field</summary>
            public LLUUID ReturnID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReturnIDsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReturnIDsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ReturnID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ReturnID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>ReturnType field</summary>
            public uint ReturnType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ReturnType = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(ReturnType % 256);
                bytes[i++] = (byte)((ReturnType >> 8) % 256);
                bytes[i++] = (byte)((ReturnType >> 16) % 256);
                bytes[i++] = (byte)((ReturnType >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelSelectObjects</summary>
        public override PacketType Type { get { return PacketType.ParcelSelectObjects; } }
        /// <summary>ReturnIDs block</summary>
        public ReturnIDsBlock[] ReturnIDs;
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelSelectObjectsPacket()
        {
            Header = new LowHeader();
            Header.ID = 246;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ReturnIDs = new ReturnIDsBlock[0];
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelSelectObjectsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ReturnIDs = new ReturnIDsBlock[count];
            for (int j = 0; j < count; j++)
            { ReturnIDs[j] = new ReturnIDsBlock(bytes, ref i); }
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelSelectObjectsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ReturnIDs = new ReturnIDsBlock[count];
            for (int j = 0; j < count; j++)
            { ReturnIDs[j] = new ReturnIDsBlock(bytes, ref i); }
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            for (int j = 0; j < ReturnIDs.Length; j++) { length += ReturnIDs[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ReturnIDs.Length;
            for (int j = 0; j < ReturnIDs.Length; j++) { ReturnIDs[j].ToBytes(bytes, ref i); }
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EstateCovenantRequest packet</summary>
    public class EstateCovenantRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EstateCovenantRequest</summary>
        public override PacketType Type { get { return PacketType.EstateCovenantRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EstateCovenantRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 247;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EstateCovenantRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EstateCovenantRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EstateCovenantReply packet</summary>
    public class EstateCovenantReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>CovenantID field</summary>
            public LLUUID CovenantID;
            /// <summary>CovenantTimestamp field</summary>
            public uint CovenantTimestamp;
            private byte[] _estatename;
            /// <summary>EstateName field</summary>
            public byte[] EstateName
            {
                get { return _estatename; }
                set
                {
                    if (value == null) { _estatename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _estatename = new byte[value.Length]; Array.Copy(value, _estatename, value.Length); }
                }
            }
            /// <summary>EstateOwnerID field</summary>
            public LLUUID EstateOwnerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    if (EstateName != null) { length += 1 + EstateName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    CovenantID = new LLUUID(bytes, i); i += 16;
                    CovenantTimestamp = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _estatename = new byte[length];
                    Array.Copy(bytes, i, _estatename, 0, length); i += length;
                    EstateOwnerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(CovenantID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(CovenantTimestamp % 256);
                bytes[i++] = (byte)((CovenantTimestamp >> 8) % 256);
                bytes[i++] = (byte)((CovenantTimestamp >> 16) % 256);
                bytes[i++] = (byte)((CovenantTimestamp >> 24) % 256);
                bytes[i++] = (byte)EstateName.Length;
                Array.Copy(EstateName, 0, bytes, i, EstateName.Length); i += EstateName.Length;
                Array.Copy(EstateOwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EstateCovenantReply</summary>
        public override PacketType Type { get { return PacketType.EstateCovenantReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public EstateCovenantReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 248;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EstateCovenantReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EstateCovenantReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ForceObjectSelect packet</summary>
    public class ForceObjectSelectPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>Header block</summary>
        public class HeaderBlock
        {
            /// <summary>ResetList field</summary>
            public bool ResetList;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HeaderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HeaderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ResetList = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((ResetList) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ForceObjectSelect</summary>
        public override PacketType Type { get { return PacketType.ForceObjectSelect; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>Header block</summary>
        public HeaderBlock _Header;

        /// <summary>Default constructor</summary>
        public ForceObjectSelectPacket()
        {
            Header = new LowHeader();
            Header.ID = 249;
            Header.Reliable = true;
            Data = new DataBlock[0];
            _Header = new HeaderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ForceObjectSelectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            _Header = new HeaderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ForceObjectSelectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            _Header = new HeaderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += _Header.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            _Header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelBuyPass packet</summary>
    public class ParcelBuyPassPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelBuyPass</summary>
        public override PacketType Type { get { return PacketType.ParcelBuyPass; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelBuyPassPacket()
        {
            Header = new LowHeader();
            Header.ID = 250;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelBuyPassPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelBuyPassPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelDeedToGroup packet</summary>
    public class ParcelDeedToGroupPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelDeedToGroup</summary>
        public override PacketType Type { get { return PacketType.ParcelDeedToGroup; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelDeedToGroupPacket()
        {
            Header = new LowHeader();
            Header.ID = 251;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelDeedToGroupPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelDeedToGroupPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelReclaim packet</summary>
    public class ParcelReclaimPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelReclaim</summary>
        public override PacketType Type { get { return PacketType.ParcelReclaim; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelReclaimPacket()
        {
            Header = new LowHeader();
            Header.ID = 252;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelReclaimPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelReclaimPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelClaim packet</summary>
    public class ParcelClaimPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>IsGroupOwned field</summary>
            public bool IsGroupOwned;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>Final field</summary>
            public bool Final;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IsGroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    Final = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((IsGroupOwned) ? 1 : 0);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Final) ? 1 : 0);
            }
        }

        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>East field</summary>
            public float East;
            /// <summary>West field</summary>
            public float West;
            /// <summary>North field</summary>
            public float North;
            /// <summary>South field</summary>
            public float South;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    East = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    West = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    North = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    South = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(East);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(West);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(North);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(South);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelClaim</summary>
        public override PacketType Type { get { return PacketType.ParcelClaim; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelClaimPacket()
        {
            Header = new LowHeader();
            Header.ID = 253;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            ParcelData = new ParcelDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelClaimPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelClaimPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelJoin packet</summary>
    public class ParcelJoinPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>East field</summary>
            public float East;
            /// <summary>West field</summary>
            public float West;
            /// <summary>North field</summary>
            public float North;
            /// <summary>South field</summary>
            public float South;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    East = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    West = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    North = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    South = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(East);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(West);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(North);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(South);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelJoin</summary>
        public override PacketType Type { get { return PacketType.ParcelJoin; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelJoinPacket()
        {
            Header = new LowHeader();
            Header.ID = 254;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelJoinPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelJoinPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelDivide packet</summary>
    public class ParcelDividePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>East field</summary>
            public float East;
            /// <summary>West field</summary>
            public float West;
            /// <summary>North field</summary>
            public float North;
            /// <summary>South field</summary>
            public float South;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    East = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    West = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    North = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    South = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(East);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(West);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(North);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(South);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelDivide</summary>
        public override PacketType Type { get { return PacketType.ParcelDivide; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelDividePacket()
        {
            Header = new LowHeader();
            Header.ID = 255;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelDividePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelDividePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelRelease packet</summary>
    public class ParcelReleasePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelRelease</summary>
        public override PacketType Type { get { return PacketType.ParcelRelease; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelReleasePacket()
        {
            Header = new LowHeader();
            Header.ID = 256;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelReleasePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelReleasePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelBuy packet</summary>
    public class ParcelBuyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>RemoveContribution field</summary>
            public bool RemoveContribution;
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>IsGroupOwned field</summary>
            public bool IsGroupOwned;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>Final field</summary>
            public bool Final;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 23;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RemoveContribution = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    IsGroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    Final = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((RemoveContribution) ? 1 : 0);
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)((IsGroupOwned) ? 1 : 0);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Final) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelBuy</summary>
        public override PacketType Type { get { return PacketType.ParcelBuy; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelBuyPacket()
        {
            Header = new LowHeader();
            Header.ID = 257;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelBuyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelBuyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelGodForceOwner packet</summary>
    public class ParcelGodForceOwnerPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelGodForceOwner</summary>
        public override PacketType Type { get { return PacketType.ParcelGodForceOwner; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelGodForceOwnerPacket()
        {
            Header = new LowHeader();
            Header.ID = 258;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelGodForceOwnerPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelGodForceOwnerPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelAccessListRequest packet</summary>
    public class ParcelAccessListRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>SequenceID field</summary>
            public int SequenceID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(SequenceID % 256);
                bytes[i++] = (byte)((SequenceID >> 8) % 256);
                bytes[i++] = (byte)((SequenceID >> 16) % 256);
                bytes[i++] = (byte)((SequenceID >> 24) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelAccessListRequest</summary>
        public override PacketType Type { get { return PacketType.ParcelAccessListRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelAccessListRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 259;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelAccessListRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelAccessListRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelAccessListReply packet</summary>
    public class ParcelAccessListReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>SequenceID field</summary>
            public int SequenceID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(SequenceID % 256);
                bytes[i++] = (byte)((SequenceID >> 8) % 256);
                bytes[i++] = (byte)((SequenceID >> 16) % 256);
                bytes[i++] = (byte)((SequenceID >> 24) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>List block</summary>
        public class ListBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Time field</summary>
            public int Time;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ListBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    Time = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Time % 256);
                bytes[i++] = (byte)((Time >> 8) % 256);
                bytes[i++] = (byte)((Time >> 16) % 256);
                bytes[i++] = (byte)((Time >> 24) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelAccessListReply</summary>
        public override PacketType Type { get { return PacketType.ParcelAccessListReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>List block</summary>
        public ListBlock[] List;

        /// <summary>Default constructor</summary>
        public ParcelAccessListReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 260;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            List = new ListBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelAccessListReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            List = new ListBlock[count];
            for (int j = 0; j < count; j++)
            { List[j] = new ListBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelAccessListReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            List = new ListBlock[count];
            for (int j = 0; j < count; j++)
            { List[j] = new ListBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            for (int j = 0; j < List.Length; j++) { length += List[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            bytes[i++] = (byte)List.Length;
            for (int j = 0; j < List.Length; j++) { List[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelAccessListUpdate packet</summary>
    public class ParcelAccessListUpdatePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>Sections field</summary>
            public int Sections;
            /// <summary>SequenceID field</summary>
            public int SequenceID;
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Sections = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(Sections % 256);
                bytes[i++] = (byte)((Sections >> 8) % 256);
                bytes[i++] = (byte)((Sections >> 16) % 256);
                bytes[i++] = (byte)((Sections >> 24) % 256);
                bytes[i++] = (byte)(SequenceID % 256);
                bytes[i++] = (byte)((SequenceID >> 8) % 256);
                bytes[i++] = (byte)((SequenceID >> 16) % 256);
                bytes[i++] = (byte)((SequenceID >> 24) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>List block</summary>
        public class ListBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Time field</summary>
            public int Time;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ListBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    Time = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Time % 256);
                bytes[i++] = (byte)((Time >> 8) % 256);
                bytes[i++] = (byte)((Time >> 16) % 256);
                bytes[i++] = (byte)((Time >> 24) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelAccessListUpdate</summary>
        public override PacketType Type { get { return PacketType.ParcelAccessListUpdate; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>List block</summary>
        public ListBlock[] List;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelAccessListUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 261;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
            List = new ListBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelAccessListUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            List = new ListBlock[count];
            for (int j = 0; j < count; j++)
            { List[j] = new ListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelAccessListUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            List = new ListBlock[count];
            for (int j = 0; j < count; j++)
            { List[j] = new ListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            for (int j = 0; j < List.Length; j++) { length += List[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            bytes[i++] = (byte)List.Length;
            for (int j = 0; j < List.Length; j++) { List[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelDwellRequest packet</summary>
    public class ParcelDwellRequestPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelDwellRequest</summary>
        public override PacketType Type { get { return PacketType.ParcelDwellRequest; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelDwellRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 262;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelDwellRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelDwellRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelDwellReply packet</summary>
    public class ParcelDwellReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>Dwell field</summary>
            public float Dwell;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Dwell = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Dwell);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelDwellReply</summary>
        public override PacketType Type { get { return PacketType.ParcelDwellReply; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelDwellReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 263;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelDwellReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelDwellReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestParcelTransfer packet</summary>
    public class RequestParcelTransferPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ReservedNewbie field</summary>
            public bool ReservedNewbie;
            /// <summary>BillableArea field</summary>
            public int BillableArea;
            /// <summary>ActualArea field</summary>
            public int ActualArea;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>Amount field</summary>
            public int Amount;
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>Final field</summary>
            public bool Final;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;
            /// <summary>TransactionTime field</summary>
            public uint TransactionTime;
            /// <summary>TransactionType field</summary>
            public int TransactionType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 87;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ReservedNewbie = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    BillableArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ActualArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    DestID = new LLUUID(bytes, i); i += 16;
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (byte)bytes[i++];
                    Final = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    SourceID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                    TransactionTime = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((ReservedNewbie) ? 1 : 0);
                bytes[i++] = (byte)(BillableArea % 256);
                bytes[i++] = (byte)((BillableArea >> 8) % 256);
                bytes[i++] = (byte)((BillableArea >> 16) % 256);
                bytes[i++] = (byte)((BillableArea >> 24) % 256);
                bytes[i++] = (byte)(ActualArea % 256);
                bytes[i++] = (byte)((ActualArea >> 8) % 256);
                bytes[i++] = (byte)((ActualArea >> 16) % 256);
                bytes[i++] = (byte)((ActualArea >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = Flags;
                bytes[i++] = (byte)((Final) ? 1 : 0);
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TransactionTime % 256);
                bytes[i++] = (byte)((TransactionTime >> 8) % 256);
                bytes[i++] = (byte)((TransactionTime >> 16) % 256);
                bytes[i++] = (byte)((TransactionTime >> 24) % 256);
                bytes[i++] = (byte)(TransactionType % 256);
                bytes[i++] = (byte)((TransactionType >> 8) % 256);
                bytes[i++] = (byte)((TransactionType >> 16) % 256);
                bytes[i++] = (byte)((TransactionType >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestParcelTransfer</summary>
        public override PacketType Type { get { return PacketType.RequestParcelTransfer; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public RequestParcelTransferPacket()
        {
            Header = new LowHeader();
            Header.ID = 264;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestParcelTransferPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestParcelTransferPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateParcel packet</summary>
    public class UpdateParcelPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ReservedNewbie field</summary>
            public bool ReservedNewbie;
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>RegionX field</summary>
            public float RegionX;
            /// <summary>RegionY field</summary>
            public float RegionY;
            /// <summary>AllowPublish field</summary>
            public bool AllowPublish;
            /// <summary>BillableArea field</summary>
            public int BillableArea;
            /// <summary>ShowDir field</summary>
            public bool ShowDir;
            /// <summary>ActualArea field</summary>
            public int ActualArea;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>UserLocation field</summary>
            public LLVector3 UserLocation;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>Category field</summary>
            public byte Category;
            /// <summary>AuthorizedBuyerID field</summary>
            public LLUUID AuthorizedBuyerID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>IsForSale field</summary>
            public bool IsForSale;
            /// <summary>Status field</summary>
            public byte Status;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>MaturePublish field</summary>
            public bool MaturePublish;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            private byte[] _musicurl;
            /// <summary>MusicURL field</summary>
            public byte[] MusicURL
            {
                get { return _musicurl; }
                set
                {
                    if (value == null) { _musicurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _musicurl = new byte[value.Length]; Array.Copy(value, _musicurl, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 112;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    if (MusicURL != null) { length += 1 + MusicURL.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ReservedNewbie = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    RegionX = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    RegionY = BitConverter.ToSingle(bytes, i); i += 4;
                    AllowPublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    BillableArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ShowDir = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ActualArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    UserLocation = new LLVector3(bytes, i); i += 12;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Category = (byte)bytes[i++];
                    AuthorizedBuyerID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    IsForSale = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Status = (byte)bytes[i++];
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    MaturePublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _musicurl = new byte[length];
                    Array.Copy(bytes, i, _musicurl, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)((ReservedNewbie) ? 1 : 0);
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                ba = BitConverter.GetBytes(RegionX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(RegionY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)((AllowPublish) ? 1 : 0);
                bytes[i++] = (byte)(BillableArea % 256);
                bytes[i++] = (byte)((BillableArea >> 8) % 256);
                bytes[i++] = (byte)((BillableArea >> 16) % 256);
                bytes[i++] = (byte)((BillableArea >> 24) % 256);
                bytes[i++] = (byte)((ShowDir) ? 1 : 0);
                bytes[i++] = (byte)(ActualArea % 256);
                bytes[i++] = (byte)((ActualArea >> 8) % 256);
                bytes[i++] = (byte)((ActualArea >> 16) % 256);
                bytes[i++] = (byte)((ActualArea >> 24) % 256);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(UserLocation.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = Category;
                Array.Copy(AuthorizedBuyerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((IsForSale) ? 1 : 0);
                bytes[i++] = Status;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((MaturePublish) ? 1 : 0);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)MusicURL.Length;
                Array.Copy(MusicURL, 0, bytes, i, MusicURL.Length); i += MusicURL.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateParcel</summary>
        public override PacketType Type { get { return PacketType.UpdateParcel; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;

        /// <summary>Default constructor</summary>
        public UpdateParcelPacket()
        {
            Header = new LowHeader();
            Header.ID = 265;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateParcelPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateParcelPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveParcel packet</summary>
    public class RemoveParcelPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveParcel</summary>
        public override PacketType Type { get { return PacketType.RemoveParcel; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public RemoveParcelPacket()
        {
            Header = new LowHeader();
            Header.ID = 266;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveParcelPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveParcelPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MergeParcel packet</summary>
    public class MergeParcelPacket : Packet
    {
        /// <summary>MasterParcelData block</summary>
        public class MasterParcelDataBlock
        {
            /// <summary>MasterID field</summary>
            public LLUUID MasterID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MasterParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MasterParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    MasterID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(MasterID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>SlaveParcelData block</summary>
        public class SlaveParcelDataBlock
        {
            /// <summary>SlaveID field</summary>
            public LLUUID SlaveID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SlaveParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SlaveParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SlaveID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(SlaveID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MergeParcel</summary>
        public override PacketType Type { get { return PacketType.MergeParcel; } }
        /// <summary>MasterParcelData block</summary>
        public MasterParcelDataBlock MasterParcelData;
        /// <summary>SlaveParcelData block</summary>
        public SlaveParcelDataBlock[] SlaveParcelData;

        /// <summary>Default constructor</summary>
        public MergeParcelPacket()
        {
            Header = new LowHeader();
            Header.ID = 267;
            Header.Reliable = true;
            MasterParcelData = new MasterParcelDataBlock();
            SlaveParcelData = new SlaveParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MergeParcelPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MasterParcelData = new MasterParcelDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            SlaveParcelData = new SlaveParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { SlaveParcelData[j] = new SlaveParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MergeParcelPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MasterParcelData = new MasterParcelDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            SlaveParcelData = new SlaveParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { SlaveParcelData[j] = new SlaveParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MasterParcelData.Length;;
            for (int j = 0; j < SlaveParcelData.Length; j++) { length += SlaveParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MasterParcelData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)SlaveParcelData.Length;
            for (int j = 0; j < SlaveParcelData.Length; j++) { SlaveParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogParcelChanges packet</summary>
    public class LogParcelChangesPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ActualArea field</summary>
            public int ActualArea;
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>IsOwnerGroup field</summary>
            public bool IsOwnerGroup;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>Action field</summary>
            public sbyte Action;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 55;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ActualArea = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    IsOwnerGroup = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    Action = (sbyte)bytes[i++];
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ActualArea % 256);
                bytes[i++] = (byte)((ActualArea >> 8) % 256);
                bytes[i++] = (byte)((ActualArea >> 16) % 256);
                bytes[i++] = (byte)((ActualArea >> 24) % 256);
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((IsOwnerGroup) ? 1 : 0);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Action;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogParcelChanges</summary>
        public override PacketType Type { get { return PacketType.LogParcelChanges; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public LogParcelChangesPacket()
        {
            Header = new LowHeader();
            Header.ID = 268;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock[0];
            RegionData = new RegionDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogParcelChangesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogParcelChangesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RegionData.Length;            length += AgentData.Length;;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            RegionData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CheckParcelSales packet</summary>
    public class CheckParcelSalesPacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CheckParcelSales</summary>
        public override PacketType Type { get { return PacketType.CheckParcelSales; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock[] RegionData;

        /// <summary>Default constructor</summary>
        public CheckParcelSalesPacket()
        {
            Header = new LowHeader();
            Header.ID = 269;
            Header.Reliable = true;
            RegionData = new RegionDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CheckParcelSalesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CheckParcelSalesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < RegionData.Length; j++) { length += RegionData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RegionData.Length;
            for (int j = 0; j < RegionData.Length; j++) { RegionData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelSales packet</summary>
    public class ParcelSalesPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>BuyerID field</summary>
            public LLUUID BuyerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    BuyerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(BuyerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelSales</summary>
        public override PacketType Type { get { return PacketType.ParcelSales; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public ParcelSalesPacket()
        {
            Header = new LowHeader();
            Header.ID = 270;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelSalesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelSalesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelGodMarkAsContent packet</summary>
    public class ParcelGodMarkAsContentPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelGodMarkAsContent</summary>
        public override PacketType Type { get { return PacketType.ParcelGodMarkAsContent; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelGodMarkAsContentPacket()
        {
            Header = new LowHeader();
            Header.ID = 271;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelGodMarkAsContentPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelGodMarkAsContentPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelGodReserveForNewbie packet</summary>
    public class ParcelGodReserveForNewbiePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelGodReserveForNewbie</summary>
        public override PacketType Type { get { return PacketType.ParcelGodReserveForNewbie; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelGodReserveForNewbiePacket()
        {
            Header = new LowHeader();
            Header.ID = 272;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelGodReserveForNewbiePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelGodReserveForNewbiePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ViewerStartAuction packet</summary>
    public class ViewerStartAuctionPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ViewerStartAuction</summary>
        public override PacketType Type { get { return PacketType.ViewerStartAuction; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ViewerStartAuctionPacket()
        {
            Header = new LowHeader();
            Header.ID = 273;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ViewerStartAuctionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ViewerStartAuctionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartAuction packet</summary>
    public class StartAuctionPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartAuction</summary>
        public override PacketType Type { get { return PacketType.StartAuction; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public StartAuctionPacket()
        {
            Header = new LowHeader();
            Header.ID = 274;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartAuctionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartAuctionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ConfirmAuctionStart packet</summary>
    public class ConfirmAuctionStartPacket : Packet
    {
        /// <summary>AuctionData block</summary>
        public class AuctionDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>AuctionID field</summary>
            public uint AuctionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AuctionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AuctionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    AuctionID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(AuctionID % 256);
                bytes[i++] = (byte)((AuctionID >> 8) % 256);
                bytes[i++] = (byte)((AuctionID >> 16) % 256);
                bytes[i++] = (byte)((AuctionID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ConfirmAuctionStart</summary>
        public override PacketType Type { get { return PacketType.ConfirmAuctionStart; } }
        /// <summary>AuctionData block</summary>
        public AuctionDataBlock AuctionData;

        /// <summary>Default constructor</summary>
        public ConfirmAuctionStartPacket()
        {
            Header = new LowHeader();
            Header.ID = 275;
            Header.Reliable = true;
            AuctionData = new AuctionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ConfirmAuctionStartPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AuctionData = new AuctionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ConfirmAuctionStartPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AuctionData = new AuctionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AuctionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AuctionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CompleteAuction packet</summary>
    public class CompleteAuctionPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CompleteAuction</summary>
        public override PacketType Type { get { return PacketType.CompleteAuction; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public CompleteAuctionPacket()
        {
            Header = new LowHeader();
            Header.ID = 276;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CompleteAuctionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CompleteAuctionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CancelAuction packet</summary>
    public class CancelAuctionPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CancelAuction</summary>
        public override PacketType Type { get { return PacketType.CancelAuction; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public CancelAuctionPacket()
        {
            Header = new LowHeader();
            Header.ID = 277;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CancelAuctionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CancelAuctionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CheckParcelAuctions packet</summary>
    public class CheckParcelAuctionsPacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CheckParcelAuctions</summary>
        public override PacketType Type { get { return PacketType.CheckParcelAuctions; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock[] RegionData;

        /// <summary>Default constructor</summary>
        public CheckParcelAuctionsPacket()
        {
            Header = new LowHeader();
            Header.ID = 278;
            Header.Reliable = true;
            RegionData = new RegionDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CheckParcelAuctionsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CheckParcelAuctionsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RegionData = new RegionDataBlock[count];
            for (int j = 0; j < count; j++)
            { RegionData[j] = new RegionDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < RegionData.Length; j++) { length += RegionData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RegionData.Length;
            for (int j = 0; j < RegionData.Length; j++) { RegionData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelAuctions packet</summary>
    public class ParcelAuctionsPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>WinnerID field</summary>
            public LLUUID WinnerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    WinnerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(WinnerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelAuctions</summary>
        public override PacketType Type { get { return PacketType.ParcelAuctions; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public ParcelAuctionsPacket()
        {
            Header = new LowHeader();
            Header.ID = 279;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelAuctionsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelAuctionsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UUIDNameRequest packet</summary>
    public class UUIDNameRequestPacket : Packet
    {
        /// <summary>UUIDNameBlock block</summary>
        public class UUIDNameBlockBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UUIDNameBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UUIDNameBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UUIDNameRequest</summary>
        public override PacketType Type { get { return PacketType.UUIDNameRequest; } }
        /// <summary>UUIDNameBlock block</summary>
        public UUIDNameBlockBlock[] UUIDNameBlock;

        /// <summary>Default constructor</summary>
        public UUIDNameRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 280;
            Header.Reliable = true;
            UUIDNameBlock = new UUIDNameBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UUIDNameRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UUIDNameRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { length += UUIDNameBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)UUIDNameBlock.Length;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { UUIDNameBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UUIDNameReply packet</summary>
    public class UUIDNameReplyPacket : Packet
    {
        /// <summary>UUIDNameBlock block</summary>
        public class UUIDNameBlockBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            private byte[] _lastname;
            /// <summary>LastName field</summary>
            public byte[] LastName
            {
                get { return _lastname; }
                set
                {
                    if (value == null) { _lastname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lastname = new byte[value.Length]; Array.Copy(value, _lastname, value.Length); }
                }
            }
            private byte[] _firstname;
            /// <summary>FirstName field</summary>
            public byte[] FirstName
            {
                get { return _firstname; }
                set
                {
                    if (value == null) { _firstname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _firstname = new byte[value.Length]; Array.Copy(value, _firstname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (LastName != null) { length += 1 + LastName.Length; }
                    if (FirstName != null) { length += 1 + FirstName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UUIDNameBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UUIDNameBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _lastname = new byte[length];
                    Array.Copy(bytes, i, _lastname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _firstname = new byte[length];
                    Array.Copy(bytes, i, _firstname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)LastName.Length;
                Array.Copy(LastName, 0, bytes, i, LastName.Length); i += LastName.Length;
                bytes[i++] = (byte)FirstName.Length;
                Array.Copy(FirstName, 0, bytes, i, FirstName.Length); i += FirstName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UUIDNameReply</summary>
        public override PacketType Type { get { return PacketType.UUIDNameReply; } }
        /// <summary>UUIDNameBlock block</summary>
        public UUIDNameBlockBlock[] UUIDNameBlock;

        /// <summary>Default constructor</summary>
        public UUIDNameReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 281;
            Header.Reliable = true;
            UUIDNameBlock = new UUIDNameBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UUIDNameReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UUIDNameReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { length += UUIDNameBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)UUIDNameBlock.Length;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { UUIDNameBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UUIDGroupNameRequest packet</summary>
    public class UUIDGroupNameRequestPacket : Packet
    {
        /// <summary>UUIDNameBlock block</summary>
        public class UUIDNameBlockBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UUIDNameBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UUIDNameBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UUIDGroupNameRequest</summary>
        public override PacketType Type { get { return PacketType.UUIDGroupNameRequest; } }
        /// <summary>UUIDNameBlock block</summary>
        public UUIDNameBlockBlock[] UUIDNameBlock;

        /// <summary>Default constructor</summary>
        public UUIDGroupNameRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 282;
            Header.Reliable = true;
            UUIDNameBlock = new UUIDNameBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UUIDGroupNameRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UUIDGroupNameRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { length += UUIDNameBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)UUIDNameBlock.Length;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { UUIDNameBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UUIDGroupNameReply packet</summary>
    public class UUIDGroupNameReplyPacket : Packet
    {
        /// <summary>UUIDNameBlock block</summary>
        public class UUIDNameBlockBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            private byte[] _groupname;
            /// <summary>GroupName field</summary>
            public byte[] GroupName
            {
                get { return _groupname; }
                set
                {
                    if (value == null) { _groupname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _groupname = new byte[value.Length]; Array.Copy(value, _groupname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (GroupName != null) { length += 1 + GroupName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UUIDNameBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UUIDNameBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _groupname = new byte[length];
                    Array.Copy(bytes, i, _groupname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)GroupName.Length;
                Array.Copy(GroupName, 0, bytes, i, GroupName.Length); i += GroupName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UUIDGroupNameReply</summary>
        public override PacketType Type { get { return PacketType.UUIDGroupNameReply; } }
        /// <summary>UUIDNameBlock block</summary>
        public UUIDNameBlockBlock[] UUIDNameBlock;

        /// <summary>Default constructor</summary>
        public UUIDGroupNameReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 283;
            Header.Reliable = true;
            UUIDNameBlock = new UUIDNameBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UUIDGroupNameReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UUIDGroupNameReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            UUIDNameBlock = new UUIDNameBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UUIDNameBlock[j] = new UUIDNameBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { length += UUIDNameBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)UUIDNameBlock.Length;
            for (int j = 0; j < UUIDNameBlock.Length; j++) { UUIDNameBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChatPass packet</summary>
    public class ChatPassPacket : Packet
    {
        /// <summary>ChatData block</summary>
        public class ChatDataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Channel field</summary>
            public int Channel;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Type field</summary>
            public byte Type;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>Radius field</summary>
            public float Radius;
            /// <summary>SourceType field</summary>
            public byte SourceType;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 55;
                    if (Message != null) { length += 2 + Message.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ChatDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ChatDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    Channel = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Type = (byte)bytes[i++];
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    SimAccess = (byte)bytes[i++];
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Radius = BitConverter.ToSingle(bytes, i); i += 4;
                    SourceType = (byte)bytes[i++];
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Channel % 256);
                bytes[i++] = (byte)((Channel >> 8) % 256);
                bytes[i++] = (byte)((Channel >> 16) % 256);
                bytes[i++] = (byte)((Channel >> 24) % 256);
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = Type;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SimAccess;
                ba = BitConverter.GetBytes(Radius);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = SourceType;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChatPass</summary>
        public override PacketType Type { get { return PacketType.ChatPass; } }
        /// <summary>ChatData block</summary>
        public ChatDataBlock ChatData;

        /// <summary>Default constructor</summary>
        public ChatPassPacket()
        {
            Header = new LowHeader();
            Header.ID = 284;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ChatData = new ChatDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChatPassPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ChatData = new ChatDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChatPassPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ChatData = new ChatDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ChatData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ChatData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChildAgentDying packet</summary>
    public class ChildAgentDyingPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChildAgentDying</summary>
        public override PacketType Type { get { return PacketType.ChildAgentDying; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ChildAgentDyingPacket()
        {
            Header = new LowHeader();
            Header.ID = 285;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChildAgentDyingPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChildAgentDyingPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChildAgentUnknown packet</summary>
    public class ChildAgentUnknownPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChildAgentUnknown</summary>
        public override PacketType Type { get { return PacketType.ChildAgentUnknown; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ChildAgentUnknownPacket()
        {
            Header = new LowHeader();
            Header.ID = 286;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChildAgentUnknownPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChildAgentUnknownPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>KillChildAgents packet</summary>
    public class KillChildAgentsPacket : Packet
    {
        /// <summary>IDBlock block</summary>
        public class IDBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public IDBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public IDBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.KillChildAgents</summary>
        public override PacketType Type { get { return PacketType.KillChildAgents; } }
        /// <summary>IDBlock block</summary>
        public IDBlockBlock IDBlock;

        /// <summary>Default constructor</summary>
        public KillChildAgentsPacket()
        {
            Header = new LowHeader();
            Header.ID = 287;
            Header.Reliable = true;
            IDBlock = new IDBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public KillChildAgentsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            IDBlock = new IDBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public KillChildAgentsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            IDBlock = new IDBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += IDBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            IDBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GetScriptRunning packet</summary>
    public class GetScriptRunningPacket : Packet
    {
        /// <summary>Script block</summary>
        public class ScriptBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ScriptBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ScriptBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GetScriptRunning</summary>
        public override PacketType Type { get { return PacketType.GetScriptRunning; } }
        /// <summary>Script block</summary>
        public ScriptBlock Script;

        /// <summary>Default constructor</summary>
        public GetScriptRunningPacket()
        {
            Header = new LowHeader();
            Header.ID = 288;
            Header.Reliable = true;
            Script = new ScriptBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GetScriptRunningPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Script = new ScriptBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GetScriptRunningPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Script = new ScriptBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Script.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Script.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptRunningReply packet</summary>
    public class ScriptRunningReplyPacket : Packet
    {
        /// <summary>Script block</summary>
        public class ScriptBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Running field</summary>
            public bool Running;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ScriptBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ScriptBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    Running = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Running) ? 1 : 0);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptRunningReply</summary>
        public override PacketType Type { get { return PacketType.ScriptRunningReply; } }
        /// <summary>Script block</summary>
        public ScriptBlock Script;

        /// <summary>Default constructor</summary>
        public ScriptRunningReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 289;
            Header.Reliable = true;
            Script = new ScriptBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptRunningReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Script = new ScriptBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptRunningReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Script = new ScriptBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Script.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Script.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetScriptRunning packet</summary>
    public class SetScriptRunningPacket : Packet
    {
        /// <summary>Script block</summary>
        public class ScriptBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Running field</summary>
            public bool Running;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ScriptBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ScriptBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    Running = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Running) ? 1 : 0);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetScriptRunning</summary>
        public override PacketType Type { get { return PacketType.SetScriptRunning; } }
        /// <summary>Script block</summary>
        public ScriptBlock Script;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public SetScriptRunningPacket()
        {
            Header = new LowHeader();
            Header.ID = 290;
            Header.Reliable = true;
            Script = new ScriptBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetScriptRunningPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Script = new ScriptBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetScriptRunningPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Script = new ScriptBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Script.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Script.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptReset packet</summary>
    public class ScriptResetPacket : Packet
    {
        /// <summary>Script block</summary>
        public class ScriptBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ScriptBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ScriptBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptReset</summary>
        public override PacketType Type { get { return PacketType.ScriptReset; } }
        /// <summary>Script block</summary>
        public ScriptBlock Script;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ScriptResetPacket()
        {
            Header = new LowHeader();
            Header.ID = 291;
            Header.Reliable = true;
            Script = new ScriptBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptResetPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Script = new ScriptBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptResetPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Script = new ScriptBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Script.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Script.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptSensorRequest packet</summary>
    public class ScriptSensorRequestPacket : Packet
    {
        /// <summary>Requester block</summary>
        public class RequesterBlock
        {
            /// <summary>Arc field</summary>
            public float Arc;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>SearchID field</summary>
            public LLUUID SearchID;
            private byte[] _searchname;
            /// <summary>SearchName field</summary>
            public byte[] SearchName
            {
                get { return _searchname; }
                set
                {
                    if (value == null) { _searchname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _searchname = new byte[value.Length]; Array.Copy(value, _searchname, value.Length); }
                }
            }
            /// <summary>Type field</summary>
            public int Type;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>SearchDir field</summary>
            public LLQuaternion SearchDir;
            /// <summary>SearchRegions field</summary>
            public byte SearchRegions;
            /// <summary>SearchPos field</summary>
            public LLVector3 SearchPos;
            /// <summary>Range field</summary>
            public float Range;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 97;
                    if (SearchName != null) { length += 1 + SearchName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequesterBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequesterBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Arc = BitConverter.ToSingle(bytes, i); i += 4;
                    RequestID = new LLUUID(bytes, i); i += 16;
                    SearchID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _searchname = new byte[length];
                    Array.Copy(bytes, i, _searchname, 0, length); i += length;
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SearchDir = new LLQuaternion(bytes, i); i += 16;
                    SearchRegions = (byte)bytes[i++];
                    SearchPos = new LLVector3(bytes, i); i += 12;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Range = BitConverter.ToSingle(bytes, i); i += 4;
                    SourceID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Arc);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SearchID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)SearchName.Length;
                Array.Copy(SearchName, 0, bytes, i, SearchName.Length); i += SearchName.Length;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                Array.Copy(SearchDir.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SearchRegions;
                Array.Copy(SearchPos.GetBytes(), 0, bytes, i, 12); i += 12;
                ba = BitConverter.GetBytes(Range);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptSensorRequest</summary>
        public override PacketType Type { get { return PacketType.ScriptSensorRequest; } }
        /// <summary>Requester block</summary>
        public RequesterBlock Requester;

        /// <summary>Default constructor</summary>
        public ScriptSensorRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 292;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Requester = new RequesterBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptSensorRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Requester = new RequesterBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptSensorRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Requester = new RequesterBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Requester.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Requester.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptSensorReply packet</summary>
    public class ScriptSensorReplyPacket : Packet
    {
        /// <summary>SensedData block</summary>
        public class SensedDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Type field</summary>
            public int Type;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>Velocity field</summary>
            public LLVector3 Velocity;
            /// <summary>Range field</summary>
            public float Range;
            /// <summary>Rotation field</summary>
            public LLQuaternion Rotation;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 97;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SensedDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SensedDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    Velocity = new LLVector3(bytes, i); i += 12;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Range = BitConverter.ToSingle(bytes, i); i += 4;
                    Rotation = new LLQuaternion(bytes, i); i += 16;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Velocity.GetBytes(), 0, bytes, i, 12); i += 12;
                ba = BitConverter.GetBytes(Range);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(Rotation.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>Requester block</summary>
        public class RequesterBlock
        {
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequesterBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequesterBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SourceID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptSensorReply</summary>
        public override PacketType Type { get { return PacketType.ScriptSensorReply; } }
        /// <summary>SensedData block</summary>
        public SensedDataBlock[] SensedData;
        /// <summary>Requester block</summary>
        public RequesterBlock Requester;

        /// <summary>Default constructor</summary>
        public ScriptSensorReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 293;
            Header.Reliable = true;
            Header.Zerocoded = true;
            SensedData = new SensedDataBlock[0];
            Requester = new RequesterBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptSensorReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            SensedData = new SensedDataBlock[count];
            for (int j = 0; j < count; j++)
            { SensedData[j] = new SensedDataBlock(bytes, ref i); }
            Requester = new RequesterBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptSensorReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            SensedData = new SensedDataBlock[count];
            for (int j = 0; j < count; j++)
            { SensedData[j] = new SensedDataBlock(bytes, ref i); }
            Requester = new RequesterBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Requester.Length;;
            for (int j = 0; j < SensedData.Length; j++) { length += SensedData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)SensedData.Length;
            for (int j = 0; j < SensedData.Length; j++) { SensedData[j].ToBytes(bytes, ref i); }
            Requester.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CompleteAgentMovement packet</summary>
    public class CompleteAgentMovementPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CompleteAgentMovement</summary>
        public override PacketType Type { get { return PacketType.CompleteAgentMovement; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public CompleteAgentMovementPacket()
        {
            Header = new LowHeader();
            Header.ID = 294;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CompleteAgentMovementPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CompleteAgentMovementPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentMovementComplete packet</summary>
    public class AgentMovementCompletePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>Timestamp field</summary>
            public uint Timestamp;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Timestamp = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LookAt = new LLVector3(bytes, i); i += 12;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Timestamp % 256);
                bytes[i++] = (byte)((Timestamp >> 8) % 256);
                bytes[i++] = (byte)((Timestamp >> 16) % 256);
                bytes[i++] = (byte)((Timestamp >> 24) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentMovementComplete</summary>
        public override PacketType Type { get { return PacketType.AgentMovementComplete; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentMovementCompletePacket()
        {
            Header = new LowHeader();
            Header.ID = 295;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentMovementCompletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentMovementCompletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogLogin packet</summary>
    public class LogLoginPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>ViewerDigest field</summary>
            public LLUUID ViewerDigest;
            /// <summary>SpaceIP field</summary>
            public uint SpaceIP;
            /// <summary>LastExecFroze field</summary>
            public bool LastExecFroze;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ViewerDigest = new LLUUID(bytes, i); i += 16;
                    SpaceIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LastExecFroze = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ViewerDigest.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SpaceIP % 256);
                bytes[i++] = (byte)((SpaceIP >> 8) % 256);
                bytes[i++] = (byte)((SpaceIP >> 16) % 256);
                bytes[i++] = (byte)((SpaceIP >> 24) % 256);
                bytes[i++] = (byte)((LastExecFroze) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogLogin</summary>
        public override PacketType Type { get { return PacketType.LogLogin; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public LogLoginPacket()
        {
            Header = new LowHeader();
            Header.ID = 296;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogLoginPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogLoginPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ConnectAgentToUserserver packet</summary>
    public class ConnectAgentToUserserverPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ConnectAgentToUserserver</summary>
        public override PacketType Type { get { return PacketType.ConnectAgentToUserserver; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ConnectAgentToUserserverPacket()
        {
            Header = new LowHeader();
            Header.ID = 297;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ConnectAgentToUserserverPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ConnectAgentToUserserverPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ConnectToUserserver packet</summary>
    public class ConnectToUserserverPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ConnectToUserserver</summary>
        public override PacketType Type { get { return PacketType.ConnectToUserserver; } }

        /// <summary>Default constructor</summary>
        public ConnectToUserserverPacket()
        {
            Header = new LowHeader();
            Header.ID = 298;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ConnectToUserserverPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ConnectToUserserverPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DataServerLogout packet</summary>
    public class DataServerLogoutPacket : Packet
    {
        /// <summary>UserData block</summary>
        public class UserDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>ViewerIP field</summary>
            public uint ViewerIP;
            /// <summary>Disconnect field</summary>
            public bool Disconnect;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 37;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    ViewerIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Disconnect = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ViewerIP % 256);
                bytes[i++] = (byte)((ViewerIP >> 8) % 256);
                bytes[i++] = (byte)((ViewerIP >> 16) % 256);
                bytes[i++] = (byte)((ViewerIP >> 24) % 256);
                bytes[i++] = (byte)((Disconnect) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DataServerLogout</summary>
        public override PacketType Type { get { return PacketType.DataServerLogout; } }
        /// <summary>UserData block</summary>
        public UserDataBlock UserData;

        /// <summary>Default constructor</summary>
        public DataServerLogoutPacket()
        {
            Header = new LowHeader();
            Header.ID = 299;
            Header.Reliable = true;
            UserData = new UserDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DataServerLogoutPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            UserData = new UserDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DataServerLogoutPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            UserData = new UserDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += UserData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            UserData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogoutRequest packet</summary>
    public class LogoutRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogoutRequest</summary>
        public override PacketType Type { get { return PacketType.LogoutRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public LogoutRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 300;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogoutRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogoutRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>FinalizeLogout packet</summary>
    public class FinalizeLogoutPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.FinalizeLogout</summary>
        public override PacketType Type { get { return PacketType.FinalizeLogout; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public FinalizeLogoutPacket()
        {
            Header = new LowHeader();
            Header.ID = 301;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public FinalizeLogoutPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public FinalizeLogoutPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogoutReply packet</summary>
    public class LogoutReplyPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>NewAssetID field</summary>
            public LLUUID NewAssetID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    NewAssetID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(NewAssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogoutReply</summary>
        public override PacketType Type { get { return PacketType.LogoutReply; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public LogoutReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 302;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogoutReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogoutReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogoutDemand packet</summary>
    public class LogoutDemandPacket : Packet
    {
        /// <summary>LogoutBlock block</summary>
        public class LogoutBlockBlock
        {
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public LogoutBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public LogoutBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogoutDemand</summary>
        public override PacketType Type { get { return PacketType.LogoutDemand; } }
        /// <summary>LogoutBlock block</summary>
        public LogoutBlockBlock LogoutBlock;

        /// <summary>Default constructor</summary>
        public LogoutDemandPacket()
        {
            Header = new LowHeader();
            Header.ID = 303;
            Header.Reliable = true;
            LogoutBlock = new LogoutBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogoutDemandPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            LogoutBlock = new LogoutBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogoutDemandPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            LogoutBlock = new LogoutBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += LogoutBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            LogoutBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ViewerLoginLocationRequest packet</summary>
    public class ViewerLoginLocationRequestPacket : Packet
    {
        /// <summary>URLBlock block</summary>
        public class URLBlockBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>Pos field</summary>
            public LLVector3 Pos;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public URLBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public URLBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    Pos = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(Pos.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>PositionBlock block</summary>
        public class PositionBlockBlock
        {
            /// <summary>ViewerRegion field</summary>
            public ulong ViewerRegion;
            /// <summary>ViewerPosition field</summary>
            public LLVector3 ViewerPosition;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PositionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PositionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ViewerRegion = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    ViewerPosition = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ViewerRegion % 256);
                bytes[i++] = (byte)((ViewerRegion >> 8) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 16) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 24) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 32) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 40) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 48) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 56) % 256);
                Array.Copy(ViewerPosition.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ViewerLoginLocationRequest</summary>
        public override PacketType Type { get { return PacketType.ViewerLoginLocationRequest; } }
        /// <summary>URLBlock block</summary>
        public URLBlockBlock URLBlock;
        /// <summary>PositionBlock block</summary>
        public PositionBlockBlock PositionBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ViewerLoginLocationRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 304;
            Header.Reliable = true;
            URLBlock = new URLBlockBlock();
            PositionBlock = new PositionBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ViewerLoginLocationRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            URLBlock = new URLBlockBlock(bytes, ref i);
            PositionBlock = new PositionBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ViewerLoginLocationRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            URLBlock = new URLBlockBlock(bytes, ref i);
            PositionBlock = new PositionBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += URLBlock.Length;            length += PositionBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            URLBlock.ToBytes(bytes, ref i);
            PositionBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ViewerSimLocationRequest packet</summary>
    public class ViewerSimLocationRequestPacket : Packet
    {
        /// <summary>PositionBlock block</summary>
        public class PositionBlockBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PositionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PositionBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ViewerSimLocationRequest</summary>
        public override PacketType Type { get { return PacketType.ViewerSimLocationRequest; } }
        /// <summary>PositionBlock block</summary>
        public PositionBlockBlock PositionBlock;

        /// <summary>Default constructor</summary>
        public ViewerSimLocationRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 305;
            Header.Reliable = true;
            PositionBlock = new PositionBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ViewerSimLocationRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PositionBlock = new PositionBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ViewerSimLocationRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PositionBlock = new PositionBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PositionBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PositionBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestLocationGetAccess packet</summary>
    public class RequestLocationGetAccessPacket : Packet
    {
        /// <summary>PositionBlock block</summary>
        public class PositionBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>ViewerPort field</summary>
            public ushort ViewerPort;
            /// <summary>ViewerRegion field</summary>
            public ulong ViewerRegion;
            /// <summary>ViewerIP field</summary>
            public uint ViewerIP;
            /// <summary>ViewerPosition field</summary>
            public LLVector3 ViewerPosition;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 58;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PositionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PositionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    ViewerPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    ViewerRegion = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    ViewerIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ViewerPosition = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ViewerPort % 256);
                bytes[i++] = (byte)((ViewerPort >> 8) % 256);
                bytes[i++] = (byte)(ViewerRegion % 256);
                bytes[i++] = (byte)((ViewerRegion >> 8) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 16) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 24) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 32) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 40) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 48) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 56) % 256);
                bytes[i++] = (byte)(ViewerIP % 256);
                bytes[i++] = (byte)((ViewerIP >> 8) % 256);
                bytes[i++] = (byte)((ViewerIP >> 16) % 256);
                bytes[i++] = (byte)((ViewerIP >> 24) % 256);
                Array.Copy(ViewerPosition.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestLocationGetAccess</summary>
        public override PacketType Type { get { return PacketType.RequestLocationGetAccess; } }
        /// <summary>PositionBlock block</summary>
        public PositionBlockBlock PositionBlock;

        /// <summary>Default constructor</summary>
        public RequestLocationGetAccessPacket()
        {
            Header = new LowHeader();
            Header.ID = 306;
            Header.Reliable = true;
            PositionBlock = new PositionBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestLocationGetAccessPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PositionBlock = new PositionBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestLocationGetAccessPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PositionBlock = new PositionBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PositionBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PositionBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestLocationGetAccessReply packet</summary>
    public class RequestLocationGetAccessReplyPacket : Packet
    {
        /// <summary>PositionBlock block</summary>
        public class PositionBlockBlock
        {
            /// <summary>TravelAccess field</summary>
            public byte TravelAccess;
            /// <summary>ViewerPort field</summary>
            public ushort ViewerPort;
            /// <summary>ViewerRegion field</summary>
            public ulong ViewerRegion;
            /// <summary>ViewerIP field</summary>
            public uint ViewerIP;
            /// <summary>ViewerPosition field</summary>
            public LLVector3 ViewerPosition;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 27;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PositionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PositionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TravelAccess = (byte)bytes[i++];
                    ViewerPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    ViewerRegion = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    ViewerIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ViewerPosition = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = TravelAccess;
                bytes[i++] = (byte)(ViewerPort % 256);
                bytes[i++] = (byte)((ViewerPort >> 8) % 256);
                bytes[i++] = (byte)(ViewerRegion % 256);
                bytes[i++] = (byte)((ViewerRegion >> 8) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 16) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 24) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 32) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 40) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 48) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 56) % 256);
                bytes[i++] = (byte)(ViewerIP % 256);
                bytes[i++] = (byte)((ViewerIP >> 8) % 256);
                bytes[i++] = (byte)((ViewerIP >> 16) % 256);
                bytes[i++] = (byte)((ViewerIP >> 24) % 256);
                Array.Copy(ViewerPosition.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestLocationGetAccessReply</summary>
        public override PacketType Type { get { return PacketType.RequestLocationGetAccessReply; } }
        /// <summary>PositionBlock block</summary>
        public PositionBlockBlock PositionBlock;

        /// <summary>Default constructor</summary>
        public RequestLocationGetAccessReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 307;
            Header.Reliable = true;
            PositionBlock = new PositionBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestLocationGetAccessReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PositionBlock = new PositionBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestLocationGetAccessReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PositionBlock = new PositionBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PositionBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PositionBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserListRequest packet</summary>
    public class UserListRequestPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserListRequest</summary>
        public override PacketType Type { get { return PacketType.UserListRequest; } }

        /// <summary>Default constructor</summary>
        public UserListRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 308;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserListRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserListRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ImprovedInstantMessage packet</summary>
    public class ImprovedInstantMessagePacket : Packet
    {
        /// <summary>MessageBlock block</summary>
        public class MessageBlockBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>ToAgentID field</summary>
            public LLUUID ToAgentID;
            /// <summary>Offline field</summary>
            public byte Offline;
            /// <summary>Timestamp field</summary>
            public uint Timestamp;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>Dialog field</summary>
            public byte Dialog;
            /// <summary>FromGroup field</summary>
            public bool FromGroup;
            private byte[] _binarybucket;
            /// <summary>BinaryBucket field</summary>
            public byte[] BinaryBucket
            {
                get { return _binarybucket; }
                set
                {
                    if (value == null) { _binarybucket = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _binarybucket = new byte[value.Length]; Array.Copy(value, _binarybucket, value.Length); }
                }
            }
            /// <summary>ParentEstateID field</summary>
            public uint ParentEstateID;
            private byte[] _fromagentname;
            /// <summary>FromAgentName field</summary>
            public byte[] FromAgentName
            {
                get { return _fromagentname; }
                set
                {
                    if (value == null) { _fromagentname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _fromagentname = new byte[value.Length]; Array.Copy(value, _fromagentname, value.Length); }
                }
            }
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 71;
                    if (Message != null) { length += 2 + Message.Length; }
                    if (BinaryBucket != null) { length += 2 + BinaryBucket.Length; }
                    if (FromAgentName != null) { length += 1 + FromAgentName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MessageBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MessageBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    ToAgentID = new LLUUID(bytes, i); i += 16;
                    Offline = (byte)bytes[i++];
                    Timestamp = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    RegionID = new LLUUID(bytes, i); i += 16;
                    Dialog = (byte)bytes[i++];
                    FromGroup = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _binarybucket = new byte[length];
                    Array.Copy(bytes, i, _binarybucket, 0, length); i += length;
                    ParentEstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _fromagentname = new byte[length];
                    Array.Copy(bytes, i, _fromagentname, 0, length); i += length;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ToAgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Offline;
                bytes[i++] = (byte)(Timestamp % 256);
                bytes[i++] = (byte)((Timestamp >> 8) % 256);
                bytes[i++] = (byte)((Timestamp >> 16) % 256);
                bytes[i++] = (byte)((Timestamp >> 24) % 256);
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Dialog;
                bytes[i++] = (byte)((FromGroup) ? 1 : 0);
                bytes[i++] = (byte)(BinaryBucket.Length % 256);
                bytes[i++] = (byte)((BinaryBucket.Length >> 8) % 256);
                Array.Copy(BinaryBucket, 0, bytes, i, BinaryBucket.Length); i += BinaryBucket.Length;
                bytes[i++] = (byte)(ParentEstateID % 256);
                bytes[i++] = (byte)((ParentEstateID >> 8) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 16) % 256);
                bytes[i++] = (byte)((ParentEstateID >> 24) % 256);
                bytes[i++] = (byte)FromAgentName.Length;
                Array.Copy(FromAgentName, 0, bytes, i, FromAgentName.Length); i += FromAgentName.Length;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ImprovedInstantMessage</summary>
        public override PacketType Type { get { return PacketType.ImprovedInstantMessage; } }
        /// <summary>MessageBlock block</summary>
        public MessageBlockBlock MessageBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ImprovedInstantMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 309;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MessageBlock = new MessageBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ImprovedInstantMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MessageBlock = new MessageBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ImprovedInstantMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MessageBlock = new MessageBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MessageBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MessageBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartGroupIM packet</summary>
    public class StartGroupIMPacket : Packet
    {
        /// <summary>Participants block</summary>
        public class ParticipantsBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParticipantsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParticipantsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>SessionBlock block</summary>
        public class SessionBlockBlock
        {
            /// <summary>Everyone field</summary>
            public byte Everyone;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SessionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SessionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Everyone = (byte)bytes[i++];
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = Everyone;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartGroupIM</summary>
        public override PacketType Type { get { return PacketType.StartGroupIM; } }
        /// <summary>Participants block</summary>
        public ParticipantsBlock[] Participants;
        /// <summary>SessionBlock block</summary>
        public SessionBlockBlock SessionBlock;

        /// <summary>Default constructor</summary>
        public StartGroupIMPacket()
        {
            Header = new LowHeader();
            Header.ID = 310;
            Header.Reliable = true;
            Participants = new ParticipantsBlock[0];
            SessionBlock = new SessionBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartGroupIMPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Participants = new ParticipantsBlock[count];
            for (int j = 0; j < count; j++)
            { Participants[j] = new ParticipantsBlock(bytes, ref i); }
            SessionBlock = new SessionBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartGroupIMPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Participants = new ParticipantsBlock[count];
            for (int j = 0; j < count; j++)
            { Participants[j] = new ParticipantsBlock(bytes, ref i); }
            SessionBlock = new SessionBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SessionBlock.Length;;
            for (int j = 0; j < Participants.Length; j++) { length += Participants[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Participants.Length;
            for (int j = 0; j < Participants.Length; j++) { Participants[j].ToBytes(bytes, ref i); }
            SessionBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DropGroupIM packet</summary>
    public class DropGroupIMPacket : Packet
    {
        /// <summary>SessionBlock block</summary>
        public class SessionBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SessionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SessionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DropGroupIM</summary>
        public override PacketType Type { get { return PacketType.DropGroupIM; } }
        /// <summary>SessionBlock block</summary>
        public SessionBlockBlock SessionBlock;

        /// <summary>Default constructor</summary>
        public DropGroupIMPacket()
        {
            Header = new LowHeader();
            Header.ID = 311;
            Header.Reliable = true;
            SessionBlock = new SessionBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DropGroupIMPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            SessionBlock = new SessionBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DropGroupIMPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SessionBlock = new SessionBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SessionBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SessionBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupIM packet</summary>
    public class GroupIMPacket : Packet
    {
        /// <summary>MessageBlock block</summary>
        public class MessageBlockBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>FromID field</summary>
            public LLUUID FromID;
            private byte[] _fromagentname;
            /// <summary>FromAgentName field</summary>
            public byte[] FromAgentName
            {
                get { return _fromagentname; }
                set
                {
                    if (value == null) { _fromagentname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _fromagentname = new byte[value.Length]; Array.Copy(value, _fromagentname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    if (Message != null) { length += 2 + Message.Length; }
                    if (FromAgentName != null) { length += 1 + FromAgentName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MessageBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MessageBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    FromID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _fromagentname = new byte[length];
                    Array.Copy(bytes, i, _fromagentname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FromID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)FromAgentName.Length;
                Array.Copy(FromAgentName, 0, bytes, i, FromAgentName.Length); i += FromAgentName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupIM</summary>
        public override PacketType Type { get { return PacketType.GroupIM; } }
        /// <summary>MessageBlock block</summary>
        public MessageBlockBlock MessageBlock;

        /// <summary>Default constructor</summary>
        public GroupIMPacket()
        {
            Header = new LowHeader();
            Header.ID = 312;
            Header.Reliable = true;
            MessageBlock = new MessageBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupIMPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MessageBlock = new MessageBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupIMPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MessageBlock = new MessageBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MessageBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MessageBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RetrieveInstantMessages packet</summary>
    public class RetrieveInstantMessagesPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RetrieveInstantMessages</summary>
        public override PacketType Type { get { return PacketType.RetrieveInstantMessages; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RetrieveInstantMessagesPacket()
        {
            Header = new LowHeader();
            Header.ID = 313;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RetrieveInstantMessagesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RetrieveInstantMessagesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DequeueInstantMessages packet</summary>
    public class DequeueInstantMessagesPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DequeueInstantMessages</summary>
        public override PacketType Type { get { return PacketType.DequeueInstantMessages; } }

        /// <summary>Default constructor</summary>
        public DequeueInstantMessagesPacket()
        {
            Header = new LowHeader();
            Header.ID = 314;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DequeueInstantMessagesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DequeueInstantMessagesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>FindAgent packet</summary>
    public class FindAgentPacket : Packet
    {
        /// <summary>LocationBlock block</summary>
        public class LocationBlockBlock
        {
            /// <summary>GlobalX field</summary>
            public double GlobalX;
            /// <summary>GlobalY field</summary>
            public double GlobalY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public LocationBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public LocationBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    GlobalX = BitConverter.ToDouble(bytes, i); i += 8;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    GlobalY = BitConverter.ToDouble(bytes, i); i += 8;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(GlobalX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                ba = BitConverter.GetBytes(GlobalY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
            }
        }

        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>SpaceIP field</summary>
            public uint SpaceIP;
            /// <summary>Prey field</summary>
            public LLUUID Prey;
            /// <summary>Hunter field</summary>
            public LLUUID Hunter;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SpaceIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Prey = new LLUUID(bytes, i); i += 16;
                    Hunter = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SpaceIP % 256);
                bytes[i++] = (byte)((SpaceIP >> 8) % 256);
                bytes[i++] = (byte)((SpaceIP >> 16) % 256);
                bytes[i++] = (byte)((SpaceIP >> 24) % 256);
                Array.Copy(Prey.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Hunter.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.FindAgent</summary>
        public override PacketType Type { get { return PacketType.FindAgent; } }
        /// <summary>LocationBlock block</summary>
        public LocationBlockBlock[] LocationBlock;
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public FindAgentPacket()
        {
            Header = new LowHeader();
            Header.ID = 315;
            Header.Reliable = true;
            LocationBlock = new LocationBlockBlock[0];
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public FindAgentPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            LocationBlock = new LocationBlockBlock[count];
            for (int j = 0; j < count; j++)
            { LocationBlock[j] = new LocationBlockBlock(bytes, ref i); }
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public FindAgentPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            LocationBlock = new LocationBlockBlock[count];
            for (int j = 0; j < count; j++)
            { LocationBlock[j] = new LocationBlockBlock(bytes, ref i); }
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentBlock.Length;;
            for (int j = 0; j < LocationBlock.Length; j++) { length += LocationBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)LocationBlock.Length;
            for (int j = 0; j < LocationBlock.Length; j++) { LocationBlock[j].ToBytes(bytes, ref i); }
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TrackOnlineStatus packet</summary>
    public class TrackOnlineStatusPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TrackOnlineStatus</summary>
        public override PacketType Type { get { return PacketType.TrackOnlineStatus; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock[] AgentBlock;

        /// <summary>Default constructor</summary>
        public TrackOnlineStatusPacket()
        {
            Header = new LowHeader();
            Header.ID = 316;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentBlock = new AgentBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TrackOnlineStatusPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TrackOnlineStatusPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentBlock.Length; j++) { length += AgentBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentBlock.Length;
            for (int j = 0; j < AgentBlock.Length; j++) { AgentBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>IgnoreOnlineStatus packet</summary>
    public class IgnoreOnlineStatusPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.IgnoreOnlineStatus</summary>
        public override PacketType Type { get { return PacketType.IgnoreOnlineStatus; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock[] AgentBlock;

        /// <summary>Default constructor</summary>
        public IgnoreOnlineStatusPacket()
        {
            Header = new LowHeader();
            Header.ID = 317;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentBlock = new AgentBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public IgnoreOnlineStatusPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public IgnoreOnlineStatusPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentBlock.Length; j++) { length += AgentBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentBlock.Length;
            for (int j = 0; j < AgentBlock.Length; j++) { AgentBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestGodlikePowers packet</summary>
    public class RequestGodlikePowersPacket : Packet
    {
        /// <summary>RequestBlock block</summary>
        public class RequestBlockBlock
        {
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>Token field</summary>
            public LLUUID Token;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Token = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                Array.Copy(Token.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestGodlikePowers</summary>
        public override PacketType Type { get { return PacketType.RequestGodlikePowers; } }
        /// <summary>RequestBlock block</summary>
        public RequestBlockBlock RequestBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RequestGodlikePowersPacket()
        {
            Header = new LowHeader();
            Header.ID = 318;
            Header.Reliable = true;
            RequestBlock = new RequestBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestGodlikePowersPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestBlock = new RequestBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestGodlikePowersPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestBlock = new RequestBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GrantGodlikePowers packet</summary>
    public class GrantGodlikePowersPacket : Packet
    {
        /// <summary>GrantData block</summary>
        public class GrantDataBlock
        {
            /// <summary>GodLevel field</summary>
            public byte GodLevel;
            /// <summary>Token field</summary>
            public LLUUID Token;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GrantDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GrantDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GodLevel = (byte)bytes[i++];
                    Token = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = GodLevel;
                Array.Copy(Token.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GrantGodlikePowers</summary>
        public override PacketType Type { get { return PacketType.GrantGodlikePowers; } }
        /// <summary>GrantData block</summary>
        public GrantDataBlock GrantData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GrantGodlikePowersPacket()
        {
            Header = new LowHeader();
            Header.ID = 319;
            Header.Reliable = true;
            GrantData = new GrantDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GrantGodlikePowersPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            GrantData = new GrantDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GrantGodlikePowersPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            GrantData = new GrantDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += GrantData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            GrantData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GodlikeMessage packet</summary>
    public class GodlikeMessagePacket : Packet
    {
        /// <summary>MethodData block</summary>
        public class MethodDataBlock
        {
            /// <summary>Invoice field</summary>
            public LLUUID Invoice;
            private byte[] _method;
            /// <summary>Method field</summary>
            public byte[] Method
            {
                get { return _method; }
                set
                {
                    if (value == null) { _method = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _method = new byte[value.Length]; Array.Copy(value, _method, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Method != null) { length += 1 + Method.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MethodDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MethodDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Invoice = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _method = new byte[length];
                    Array.Copy(bytes, i, _method, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Invoice.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Method.Length;
                Array.Copy(Method, 0, bytes, i, Method.Length); i += Method.Length;
            }
        }

        /// <summary>ParamList block</summary>
        public class ParamListBlock
        {
            private byte[] _parameter;
            /// <summary>Parameter field</summary>
            public byte[] Parameter
            {
                get { return _parameter; }
                set
                {
                    if (value == null) { _parameter = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _parameter = new byte[value.Length]; Array.Copy(value, _parameter, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Parameter != null) { length += 1 + Parameter.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParamListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParamListBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _parameter = new byte[length];
                    Array.Copy(bytes, i, _parameter, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Parameter.Length;
                Array.Copy(Parameter, 0, bytes, i, Parameter.Length); i += Parameter.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GodlikeMessage</summary>
        public override PacketType Type { get { return PacketType.GodlikeMessage; } }
        /// <summary>MethodData block</summary>
        public MethodDataBlock MethodData;
        /// <summary>ParamList block</summary>
        public ParamListBlock[] ParamList;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GodlikeMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 320;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MethodData = new MethodDataBlock();
            ParamList = new ParamListBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GodlikeMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GodlikeMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MethodData.Length;            length += AgentData.Length;;
            for (int j = 0; j < ParamList.Length; j++) { length += ParamList[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MethodData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParamList.Length;
            for (int j = 0; j < ParamList.Length; j++) { ParamList[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EstateOwnerMessage packet</summary>
    public class EstateOwnerMessagePacket : Packet
    {
        /// <summary>MethodData block</summary>
        public class MethodDataBlock
        {
            /// <summary>Invoice field</summary>
            public LLUUID Invoice;
            private byte[] _method;
            /// <summary>Method field</summary>
            public byte[] Method
            {
                get { return _method; }
                set
                {
                    if (value == null) { _method = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _method = new byte[value.Length]; Array.Copy(value, _method, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Method != null) { length += 1 + Method.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MethodDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MethodDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Invoice = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _method = new byte[length];
                    Array.Copy(bytes, i, _method, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Invoice.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Method.Length;
                Array.Copy(Method, 0, bytes, i, Method.Length); i += Method.Length;
            }
        }

        /// <summary>ParamList block</summary>
        public class ParamListBlock
        {
            private byte[] _parameter;
            /// <summary>Parameter field</summary>
            public byte[] Parameter
            {
                get { return _parameter; }
                set
                {
                    if (value == null) { _parameter = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _parameter = new byte[value.Length]; Array.Copy(value, _parameter, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Parameter != null) { length += 1 + Parameter.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParamListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParamListBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _parameter = new byte[length];
                    Array.Copy(bytes, i, _parameter, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Parameter.Length;
                Array.Copy(Parameter, 0, bytes, i, Parameter.Length); i += Parameter.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EstateOwnerMessage</summary>
        public override PacketType Type { get { return PacketType.EstateOwnerMessage; } }
        /// <summary>MethodData block</summary>
        public MethodDataBlock MethodData;
        /// <summary>ParamList block</summary>
        public ParamListBlock[] ParamList;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public EstateOwnerMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 321;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MethodData = new MethodDataBlock();
            ParamList = new ParamListBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EstateOwnerMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EstateOwnerMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MethodData.Length;            length += AgentData.Length;;
            for (int j = 0; j < ParamList.Length; j++) { length += ParamList[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MethodData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParamList.Length;
            for (int j = 0; j < ParamList.Length; j++) { ParamList[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GenericMessage packet</summary>
    public class GenericMessagePacket : Packet
    {
        /// <summary>MethodData block</summary>
        public class MethodDataBlock
        {
            /// <summary>Invoice field</summary>
            public LLUUID Invoice;
            private byte[] _method;
            /// <summary>Method field</summary>
            public byte[] Method
            {
                get { return _method; }
                set
                {
                    if (value == null) { _method = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _method = new byte[value.Length]; Array.Copy(value, _method, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Method != null) { length += 1 + Method.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MethodDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MethodDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Invoice = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _method = new byte[length];
                    Array.Copy(bytes, i, _method, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Invoice.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Method.Length;
                Array.Copy(Method, 0, bytes, i, Method.Length); i += Method.Length;
            }
        }

        /// <summary>ParamList block</summary>
        public class ParamListBlock
        {
            private byte[] _parameter;
            /// <summary>Parameter field</summary>
            public byte[] Parameter
            {
                get { return _parameter; }
                set
                {
                    if (value == null) { _parameter = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _parameter = new byte[value.Length]; Array.Copy(value, _parameter, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Parameter != null) { length += 1 + Parameter.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParamListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParamListBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _parameter = new byte[length];
                    Array.Copy(bytes, i, _parameter, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Parameter.Length;
                Array.Copy(Parameter, 0, bytes, i, Parameter.Length); i += Parameter.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GenericMessage</summary>
        public override PacketType Type { get { return PacketType.GenericMessage; } }
        /// <summary>MethodData block</summary>
        public MethodDataBlock MethodData;
        /// <summary>ParamList block</summary>
        public ParamListBlock[] ParamList;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GenericMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 322;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MethodData = new MethodDataBlock();
            ParamList = new ParamListBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GenericMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GenericMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MethodData.Length;            length += AgentData.Length;;
            for (int j = 0; j < ParamList.Length; j++) { length += ParamList[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MethodData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParamList.Length;
            for (int j = 0; j < ParamList.Length; j++) { ParamList[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MuteListRequest packet</summary>
    public class MuteListRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>MuteData block</summary>
        public class MuteDataBlock
        {
            /// <summary>MuteCRC field</summary>
            public uint MuteCRC;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MuteDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MuteDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    MuteCRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(MuteCRC % 256);
                bytes[i++] = (byte)((MuteCRC >> 8) % 256);
                bytes[i++] = (byte)((MuteCRC >> 16) % 256);
                bytes[i++] = (byte)((MuteCRC >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MuteListRequest</summary>
        public override PacketType Type { get { return PacketType.MuteListRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>MuteData block</summary>
        public MuteDataBlock MuteData;

        /// <summary>Default constructor</summary>
        public MuteListRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 323;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            MuteData = new MuteDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MuteListRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MuteListRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += MuteData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            MuteData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateMuteListEntry packet</summary>
    public class UpdateMuteListEntryPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>MuteData block</summary>
        public class MuteDataBlock
        {
            /// <summary>MuteID field</summary>
            public LLUUID MuteID;
            /// <summary>MuteFlags field</summary>
            public uint MuteFlags;
            private byte[] _mutename;
            /// <summary>MuteName field</summary>
            public byte[] MuteName
            {
                get { return _mutename; }
                set
                {
                    if (value == null) { _mutename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mutename = new byte[value.Length]; Array.Copy(value, _mutename, value.Length); }
                }
            }
            /// <summary>MuteType field</summary>
            public int MuteType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (MuteName != null) { length += 1 + MuteName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MuteDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MuteDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    MuteID = new LLUUID(bytes, i); i += 16;
                    MuteFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _mutename = new byte[length];
                    Array.Copy(bytes, i, _mutename, 0, length); i += length;
                    MuteType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(MuteID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MuteFlags % 256);
                bytes[i++] = (byte)((MuteFlags >> 8) % 256);
                bytes[i++] = (byte)((MuteFlags >> 16) % 256);
                bytes[i++] = (byte)((MuteFlags >> 24) % 256);
                bytes[i++] = (byte)MuteName.Length;
                Array.Copy(MuteName, 0, bytes, i, MuteName.Length); i += MuteName.Length;
                bytes[i++] = (byte)(MuteType % 256);
                bytes[i++] = (byte)((MuteType >> 8) % 256);
                bytes[i++] = (byte)((MuteType >> 16) % 256);
                bytes[i++] = (byte)((MuteType >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateMuteListEntry</summary>
        public override PacketType Type { get { return PacketType.UpdateMuteListEntry; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>MuteData block</summary>
        public MuteDataBlock MuteData;

        /// <summary>Default constructor</summary>
        public UpdateMuteListEntryPacket()
        {
            Header = new LowHeader();
            Header.ID = 324;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            MuteData = new MuteDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateMuteListEntryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateMuteListEntryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += MuteData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            MuteData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveMuteListEntry packet</summary>
    public class RemoveMuteListEntryPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>MuteData block</summary>
        public class MuteDataBlock
        {
            /// <summary>MuteID field</summary>
            public LLUUID MuteID;
            private byte[] _mutename;
            /// <summary>MuteName field</summary>
            public byte[] MuteName
            {
                get { return _mutename; }
                set
                {
                    if (value == null) { _mutename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mutename = new byte[value.Length]; Array.Copy(value, _mutename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (MuteName != null) { length += 1 + MuteName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MuteDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MuteDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    MuteID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _mutename = new byte[length];
                    Array.Copy(bytes, i, _mutename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(MuteID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)MuteName.Length;
                Array.Copy(MuteName, 0, bytes, i, MuteName.Length); i += MuteName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveMuteListEntry</summary>
        public override PacketType Type { get { return PacketType.RemoveMuteListEntry; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>MuteData block</summary>
        public MuteDataBlock MuteData;

        /// <summary>Default constructor</summary>
        public RemoveMuteListEntryPacket()
        {
            Header = new LowHeader();
            Header.ID = 325;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            MuteData = new MuteDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveMuteListEntryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveMuteListEntryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += MuteData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            MuteData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateInventoryItem packet</summary>
    public class UpdateInventoryItemPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 137;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateInventoryItem</summary>
        public override PacketType Type { get { return PacketType.UpdateInventoryItem; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UpdateInventoryItemPacket()
        {
            Header = new LowHeader();
            Header.ID = 326;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateInventoryItemPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateInventoryItemPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateInventoryItemAsset packet</summary>
    public class UpdateInventoryItemAssetPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AssetID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateInventoryItemAsset</summary>
        public override PacketType Type { get { return PacketType.UpdateInventoryItemAsset; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UpdateInventoryItemAssetPacket()
        {
            Header = new LowHeader();
            Header.ID = 327;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateInventoryItemAssetPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateInventoryItemAssetPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoveInventoryItem packet</summary>
    public class MoveInventoryItemPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Stamp field</summary>
            public bool Stamp;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Stamp = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Stamp) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoveInventoryItem</summary>
        public override PacketType Type { get { return PacketType.MoveInventoryItem; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoveInventoryItemPacket()
        {
            Header = new LowHeader();
            Header.ID = 328;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoveInventoryItemPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoveInventoryItemPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CopyInventoryItem packet</summary>
    public class CopyInventoryItemPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>NewFolderID field</summary>
            public LLUUID NewFolderID;
            /// <summary>OldItemID field</summary>
            public LLUUID OldItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    NewFolderID = new LLUUID(bytes, i); i += 16;
                    OldItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(NewFolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OldItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CopyInventoryItem</summary>
        public override PacketType Type { get { return PacketType.CopyInventoryItem; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public CopyInventoryItemPacket()
        {
            Header = new LowHeader();
            Header.ID = 329;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CopyInventoryItemPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CopyInventoryItemPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveInventoryItem packet</summary>
    public class RemoveInventoryItemPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveInventoryItem</summary>
        public override PacketType Type { get { return PacketType.RemoveInventoryItem; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RemoveInventoryItemPacket()
        {
            Header = new LowHeader();
            Header.ID = 330;
            Header.Reliable = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveInventoryItemPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveInventoryItemPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChangeInventoryItemFlags packet</summary>
    public class ChangeInventoryItemFlagsPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ItemID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChangeInventoryItemFlags</summary>
        public override PacketType Type { get { return PacketType.ChangeInventoryItemFlags; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ChangeInventoryItemFlagsPacket()
        {
            Header = new LowHeader();
            Header.ID = 331;
            Header.Reliable = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChangeInventoryItemFlagsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChangeInventoryItemFlagsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SaveAssetIntoInventory packet</summary>
    public class SaveAssetIntoInventoryPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>NewAssetID field</summary>
            public LLUUID NewAssetID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    NewAssetID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(NewAssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SaveAssetIntoInventory</summary>
        public override PacketType Type { get { return PacketType.SaveAssetIntoInventory; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public SaveAssetIntoInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 332;
            Header.Reliable = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SaveAssetIntoInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SaveAssetIntoInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CreateInventoryFolder packet</summary>
    public class CreateInventoryFolderPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>ParentID field</summary>
            public LLUUID ParentID;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    ParentID = new LLUUID(bytes, i); i += 16;
                    Type = (sbyte)bytes[i++];
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(ParentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Type;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CreateInventoryFolder</summary>
        public override PacketType Type { get { return PacketType.CreateInventoryFolder; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>FolderData block</summary>
        public FolderDataBlock FolderData;

        /// <summary>Default constructor</summary>
        public CreateInventoryFolderPacket()
        {
            Header = new LowHeader();
            Header.ID = 333;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            FolderData = new FolderDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CreateInventoryFolderPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            FolderData = new FolderDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CreateInventoryFolderPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            FolderData = new FolderDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += FolderData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            FolderData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateInventoryFolder packet</summary>
    public class UpdateInventoryFolderPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>ParentID field</summary>
            public LLUUID ParentID;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 34;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    ParentID = new LLUUID(bytes, i); i += 16;
                    Type = (sbyte)bytes[i++];
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(ParentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Type;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateInventoryFolder</summary>
        public override PacketType Type { get { return PacketType.UpdateInventoryFolder; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>FolderData block</summary>
        public FolderDataBlock[] FolderData;

        /// <summary>Default constructor</summary>
        public UpdateInventoryFolderPacket()
        {
            Header = new LowHeader();
            Header.ID = 334;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            FolderData = new FolderDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateInventoryFolderPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateInventoryFolderPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < FolderData.Length; j++) { length += FolderData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)FolderData.Length;
            for (int j = 0; j < FolderData.Length; j++) { FolderData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoveInventoryFolder packet</summary>
    public class MoveInventoryFolderPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>ParentID field</summary>
            public LLUUID ParentID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParentID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Stamp field</summary>
            public bool Stamp;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Stamp = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Stamp) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoveInventoryFolder</summary>
        public override PacketType Type { get { return PacketType.MoveInventoryFolder; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoveInventoryFolderPacket()
        {
            Header = new LowHeader();
            Header.ID = 335;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoveInventoryFolderPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoveInventoryFolderPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveInventoryFolder packet</summary>
    public class RemoveInventoryFolderPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveInventoryFolder</summary>
        public override PacketType Type { get { return PacketType.RemoveInventoryFolder; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>FolderData block</summary>
        public FolderDataBlock[] FolderData;

        /// <summary>Default constructor</summary>
        public RemoveInventoryFolderPacket()
        {
            Header = new LowHeader();
            Header.ID = 336;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            FolderData = new FolderDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveInventoryFolderPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveInventoryFolderPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < FolderData.Length; j++) { length += FolderData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)FolderData.Length;
            for (int j = 0; j < FolderData.Length; j++) { FolderData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>FetchInventoryDescendents packet</summary>
    public class FetchInventoryDescendentsPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>SortOrder field</summary>
            public int SortOrder;
            /// <summary>FetchFolders field</summary>
            public bool FetchFolders;
            /// <summary>FetchItems field</summary>
            public bool FetchItems;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 38;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    SortOrder = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    FetchFolders = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    FetchItems = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SortOrder % 256);
                bytes[i++] = (byte)((SortOrder >> 8) % 256);
                bytes[i++] = (byte)((SortOrder >> 16) % 256);
                bytes[i++] = (byte)((SortOrder >> 24) % 256);
                bytes[i++] = (byte)((FetchFolders) ? 1 : 0);
                bytes[i++] = (byte)((FetchItems) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.FetchInventoryDescendents</summary>
        public override PacketType Type { get { return PacketType.FetchInventoryDescendents; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public FetchInventoryDescendentsPacket()
        {
            Header = new LowHeader();
            Header.ID = 337;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public FetchInventoryDescendentsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public FetchInventoryDescendentsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InventoryDescendents packet</summary>
    public class InventoryDescendentsPacket : Packet
    {
        /// <summary>ItemData block</summary>
        public class ItemDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 137;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ItemDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ItemDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Descendents field</summary>
            public int Descendents;
            /// <summary>Version field</summary>
            public int Version;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 56;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Descendents = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Version = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Descendents % 256);
                bytes[i++] = (byte)((Descendents >> 8) % 256);
                bytes[i++] = (byte)((Descendents >> 16) % 256);
                bytes[i++] = (byte)((Descendents >> 24) % 256);
                bytes[i++] = (byte)(Version % 256);
                bytes[i++] = (byte)((Version >> 8) % 256);
                bytes[i++] = (byte)((Version >> 16) % 256);
                bytes[i++] = (byte)((Version >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>ParentID field</summary>
            public LLUUID ParentID;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 34;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    ParentID = new LLUUID(bytes, i); i += 16;
                    Type = (sbyte)bytes[i++];
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(ParentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Type;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InventoryDescendents</summary>
        public override PacketType Type { get { return PacketType.InventoryDescendents; } }
        /// <summary>ItemData block</summary>
        public ItemDataBlock[] ItemData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>FolderData block</summary>
        public FolderDataBlock[] FolderData;

        /// <summary>Default constructor</summary>
        public InventoryDescendentsPacket()
        {
            Header = new LowHeader();
            Header.ID = 338;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ItemData = new ItemDataBlock[0];
            AgentData = new AgentDataBlock();
            FolderData = new FolderDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InventoryDescendentsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ItemData = new ItemDataBlock[count];
            for (int j = 0; j < count; j++)
            { ItemData[j] = new ItemDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InventoryDescendentsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ItemData = new ItemDataBlock[count];
            for (int j = 0; j < count; j++)
            { ItemData[j] = new ItemDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ItemData.Length; j++) { length += ItemData[j].Length; }
            for (int j = 0; j < FolderData.Length; j++) { length += FolderData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ItemData.Length;
            for (int j = 0; j < ItemData.Length; j++) { ItemData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)FolderData.Length;
            for (int j = 0; j < FolderData.Length; j++) { FolderData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>FetchInventory packet</summary>
    public class FetchInventoryPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.FetchInventory</summary>
        public override PacketType Type { get { return PacketType.FetchInventory; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public FetchInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 339;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public FetchInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public FetchInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>FetchInventoryReply packet</summary>
    public class FetchInventoryReplyPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 137;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.FetchInventoryReply</summary>
        public override PacketType Type { get { return PacketType.FetchInventoryReply; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public FetchInventoryReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 340;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public FetchInventoryReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public FetchInventoryReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>BulkUpdateInventory packet</summary>
    public class BulkUpdateInventoryPacket : Packet
    {
        /// <summary>ItemData block</summary>
        public class ItemDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 137;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ItemDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ItemDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>ParentID field</summary>
            public LLUUID ParentID;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 34;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    ParentID = new LLUUID(bytes, i); i += 16;
                    Type = (sbyte)bytes[i++];
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(ParentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Type;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.BulkUpdateInventory</summary>
        public override PacketType Type { get { return PacketType.BulkUpdateInventory; } }
        /// <summary>ItemData block</summary>
        public ItemDataBlock[] ItemData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>FolderData block</summary>
        public FolderDataBlock[] FolderData;

        /// <summary>Default constructor</summary>
        public BulkUpdateInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 341;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ItemData = new ItemDataBlock[0];
            AgentData = new AgentDataBlock();
            FolderData = new FolderDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public BulkUpdateInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ItemData = new ItemDataBlock[count];
            for (int j = 0; j < count; j++)
            { ItemData[j] = new ItemDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public BulkUpdateInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ItemData = new ItemDataBlock[count];
            for (int j = 0; j < count; j++)
            { ItemData[j] = new ItemDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ItemData.Length; j++) { length += ItemData[j].Length; }
            for (int j = 0; j < FolderData.Length; j++) { length += FolderData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ItemData.Length;
            for (int j = 0; j < ItemData.Length; j++) { ItemData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)FolderData.Length;
            for (int j = 0; j < FolderData.Length; j++) { FolderData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestInventoryAsset packet</summary>
    public class RequestInventoryAssetPacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 64;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    QueryID = new LLUUID(bytes, i); i += 16;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestInventoryAsset</summary>
        public override PacketType Type { get { return PacketType.RequestInventoryAsset; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;

        /// <summary>Default constructor</summary>
        public RequestInventoryAssetPacket()
        {
            Header = new LowHeader();
            Header.ID = 342;
            Header.Reliable = true;
            QueryData = new QueryDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestInventoryAssetPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestInventoryAssetPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InventoryAssetResponse packet</summary>
    public class InventoryAssetResponsePacket : Packet
    {
        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>IsReadable field</summary>
            public bool IsReadable;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                    AssetID = new LLUUID(bytes, i); i += 16;
                    IsReadable = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((IsReadable) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InventoryAssetResponse</summary>
        public override PacketType Type { get { return PacketType.InventoryAssetResponse; } }
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;

        /// <summary>Default constructor</summary>
        public InventoryAssetResponsePacket()
        {
            Header = new LowHeader();
            Header.ID = 343;
            Header.Reliable = true;
            QueryData = new QueryDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InventoryAssetResponsePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InventoryAssetResponsePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += QueryData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveInventoryObjects packet</summary>
    public class RemoveInventoryObjectsPacket : Packet
    {
        /// <summary>ItemData block</summary>
        public class ItemDataBlock
        {
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ItemDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ItemDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveInventoryObjects</summary>
        public override PacketType Type { get { return PacketType.RemoveInventoryObjects; } }
        /// <summary>ItemData block</summary>
        public ItemDataBlock[] ItemData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>FolderData block</summary>
        public FolderDataBlock[] FolderData;

        /// <summary>Default constructor</summary>
        public RemoveInventoryObjectsPacket()
        {
            Header = new LowHeader();
            Header.ID = 344;
            Header.Reliable = true;
            ItemData = new ItemDataBlock[0];
            AgentData = new AgentDataBlock();
            FolderData = new FolderDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveInventoryObjectsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ItemData = new ItemDataBlock[count];
            for (int j = 0; j < count; j++)
            { ItemData[j] = new ItemDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveInventoryObjectsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ItemData = new ItemDataBlock[count];
            for (int j = 0; j < count; j++)
            { ItemData[j] = new ItemDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ItemData.Length; j++) { length += ItemData[j].Length; }
            for (int j = 0; j < FolderData.Length; j++) { length += FolderData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ItemData.Length;
            for (int j = 0; j < ItemData.Length; j++) { ItemData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)FolderData.Length;
            for (int j = 0; j < FolderData.Length; j++) { FolderData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PurgeInventoryDescendents packet</summary>
    public class PurgeInventoryDescendentsPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PurgeInventoryDescendents</summary>
        public override PacketType Type { get { return PacketType.PurgeInventoryDescendents; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public PurgeInventoryDescendentsPacket()
        {
            Header = new LowHeader();
            Header.ID = 345;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PurgeInventoryDescendentsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PurgeInventoryDescendentsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateTaskInventory packet</summary>
    public class UpdateTaskInventoryPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 136;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>UpdateData block</summary>
        public class UpdateDataBlock
        {
            /// <summary>Key field</summary>
            public byte Key;
            /// <summary>LocalID field</summary>
            public uint LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UpdateDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UpdateDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Key = (byte)bytes[i++];
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = Key;
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateTaskInventory</summary>
        public override PacketType Type { get { return PacketType.UpdateTaskInventory; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>UpdateData block</summary>
        public UpdateDataBlock UpdateData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UpdateTaskInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 346;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock();
            UpdateData = new UpdateDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateTaskInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            UpdateData = new UpdateDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateTaskInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            UpdateData = new UpdateDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += UpdateData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            UpdateData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveTaskInventory packet</summary>
    public class RemoveTaskInventoryPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveTaskInventory</summary>
        public override PacketType Type { get { return PacketType.RemoveTaskInventory; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RemoveTaskInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 347;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveTaskInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveTaskInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoveTaskInventory packet</summary>
    public class MoveTaskInventoryPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoveTaskInventory</summary>
        public override PacketType Type { get { return PacketType.MoveTaskInventory; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoveTaskInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 348;
            Header.Reliable = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoveTaskInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoveTaskInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestTaskInventory packet</summary>
    public class RequestTaskInventoryPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>LocalID field</summary>
            public uint LocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestTaskInventory</summary>
        public override PacketType Type { get { return PacketType.RequestTaskInventory; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RequestTaskInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 349;
            Header.Reliable = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestTaskInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestTaskInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ReplyTaskInventory packet</summary>
    public class ReplyTaskInventoryPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }
            /// <summary>Serial field</summary>
            public short Serial;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    TaskID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                    Serial = (short)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
                bytes[i++] = (byte)(Serial % 256);
                bytes[i++] = (byte)((Serial >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ReplyTaskInventory</summary>
        public override PacketType Type { get { return PacketType.ReplyTaskInventory; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;

        /// <summary>Default constructor</summary>
        public ReplyTaskInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 350;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ReplyTaskInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ReplyTaskInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DeRezObject packet</summary>
    public class DeRezObjectPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>Destination field</summary>
            public byte Destination;
            /// <summary>PacketNumber field</summary>
            public byte PacketNumber;
            /// <summary>PacketCount field</summary>
            public byte PacketCount;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;
            /// <summary>DestinationID field</summary>
            public LLUUID DestinationID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 51;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                    Destination = (byte)bytes[i++];
                    PacketNumber = (byte)bytes[i++];
                    PacketCount = (byte)bytes[i++];
                    TransactionID = new LLUUID(bytes, i); i += 16;
                    DestinationID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Destination;
                bytes[i++] = PacketNumber;
                bytes[i++] = PacketCount;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(DestinationID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DeRezObject</summary>
        public override PacketType Type { get { return PacketType.DeRezObject; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DeRezObjectPacket()
        {
            Header = new LowHeader();
            Header.ID = 351;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentBlock = new AgentBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DeRezObjectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentBlock = new AgentBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DeRezObjectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentBlock = new AgentBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentBlock.Length;            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DeRezAck packet</summary>
    public class DeRezAckPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DeRezAck</summary>
        public override PacketType Type { get { return PacketType.DeRezAck; } }

        /// <summary>Default constructor</summary>
        public DeRezAckPacket()
        {
            Header = new LowHeader();
            Header.ID = 352;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DeRezAckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DeRezAckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RezObject packet</summary>
    public class RezObjectPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 136;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>RezData block</summary>
        public class RezDataBlock
        {
            /// <summary>RezSelected field</summary>
            public bool RezSelected;
            /// <summary>RemoveItem field</summary>
            public bool RemoveItem;
            /// <summary>RayStart field</summary>
            public LLVector3 RayStart;
            /// <summary>ItemFlags field</summary>
            public uint ItemFlags;
            /// <summary>FromTaskID field</summary>
            public LLUUID FromTaskID;
            /// <summary>RayEndIsIntersection field</summary>
            public bool RayEndIsIntersection;
            /// <summary>RayEnd field</summary>
            public LLVector3 RayEnd;
            /// <summary>BypassRaycast field</summary>
            public byte BypassRaycast;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>RayTargetID field</summary>
            public LLUUID RayTargetID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 76;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RezDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RezDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RezSelected = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RemoveItem = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RayStart = new LLVector3(bytes, i); i += 12;
                    ItemFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    FromTaskID = new LLUUID(bytes, i); i += 16;
                    RayEndIsIntersection = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RayEnd = new LLVector3(bytes, i); i += 12;
                    BypassRaycast = (byte)bytes[i++];
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RayTargetID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((RezSelected) ? 1 : 0);
                bytes[i++] = (byte)((RemoveItem) ? 1 : 0);
                Array.Copy(RayStart.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(ItemFlags % 256);
                bytes[i++] = (byte)((ItemFlags >> 8) % 256);
                bytes[i++] = (byte)((ItemFlags >> 16) % 256);
                bytes[i++] = (byte)((ItemFlags >> 24) % 256);
                Array.Copy(FromTaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((RayEndIsIntersection) ? 1 : 0);
                Array.Copy(RayEnd.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = BypassRaycast;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                Array.Copy(RayTargetID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RezObject</summary>
        public override PacketType Type { get { return PacketType.RezObject; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>RezData block</summary>
        public RezDataBlock RezData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RezObjectPacket()
        {
            Header = new LowHeader();
            Header.ID = 353;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock();
            RezData = new RezDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RezObjectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            RezData = new RezDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RezObjectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            RezData = new RezDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += RezData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            RezData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DeclineInventory packet</summary>
    public class DeclineInventoryPacket : Packet
    {
        /// <summary>InfoBlock block</summary>
        public class InfoBlockBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DeclineInventory</summary>
        public override PacketType Type { get { return PacketType.DeclineInventory; } }
        /// <summary>InfoBlock block</summary>
        public InfoBlockBlock InfoBlock;

        /// <summary>Default constructor</summary>
        public DeclineInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 354;
            Header.Reliable = true;
            InfoBlock = new InfoBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DeclineInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InfoBlock = new InfoBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DeclineInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InfoBlock = new InfoBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InfoBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InfoBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TransferInventory packet</summary>
    public class TransferInventoryPacket : Packet
    {
        /// <summary>InfoBlock block</summary>
        public class InfoBlockBlock
        {
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    DestID = new LLUUID(bytes, i); i += 16;
                    SourceID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>InventoryBlock block</summary>
        public class InventoryBlockBlock
        {
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>InventoryID field</summary>
            public LLUUID InventoryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Type = (sbyte)bytes[i++];
                    InventoryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Type;
                Array.Copy(InventoryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TransferInventory</summary>
        public override PacketType Type { get { return PacketType.TransferInventory; } }
        /// <summary>InfoBlock block</summary>
        public InfoBlockBlock InfoBlock;
        /// <summary>InventoryBlock block</summary>
        public InventoryBlockBlock[] InventoryBlock;

        /// <summary>Default constructor</summary>
        public TransferInventoryPacket()
        {
            Header = new LowHeader();
            Header.ID = 355;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InfoBlock = new InfoBlockBlock();
            InventoryBlock = new InventoryBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TransferInventoryPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InfoBlock = new InfoBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            InventoryBlock = new InventoryBlockBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryBlock[j] = new InventoryBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TransferInventoryPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InfoBlock = new InfoBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            InventoryBlock = new InventoryBlockBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryBlock[j] = new InventoryBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InfoBlock.Length;;
            for (int j = 0; j < InventoryBlock.Length; j++) { length += InventoryBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InfoBlock.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryBlock.Length;
            for (int j = 0; j < InventoryBlock.Length; j++) { InventoryBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TransferInventoryAck packet</summary>
    public class TransferInventoryAckPacket : Packet
    {
        /// <summary>InfoBlock block</summary>
        public class InfoBlockBlock
        {
            /// <summary>InventoryID field</summary>
            public LLUUID InventoryID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    InventoryID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(InventoryID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TransferInventoryAck</summary>
        public override PacketType Type { get { return PacketType.TransferInventoryAck; } }
        /// <summary>InfoBlock block</summary>
        public InfoBlockBlock InfoBlock;

        /// <summary>Default constructor</summary>
        public TransferInventoryAckPacket()
        {
            Header = new LowHeader();
            Header.ID = 356;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InfoBlock = new InfoBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TransferInventoryAckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InfoBlock = new InfoBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TransferInventoryAckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InfoBlock = new InfoBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InfoBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InfoBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestFriendship packet</summary>
    public class RequestFriendshipPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 64;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    DestID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    SourceID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestFriendship</summary>
        public override PacketType Type { get { return PacketType.RequestFriendship; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public RequestFriendshipPacket()
        {
            Header = new LowHeader();
            Header.ID = 357;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestFriendshipPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestFriendshipPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AcceptFriendship packet</summary>
    public class AcceptFriendshipPacket : Packet
    {
        /// <summary>TransactionBlock block</summary>
        public class TransactionBlockBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AcceptFriendship</summary>
        public override PacketType Type { get { return PacketType.AcceptFriendship; } }
        /// <summary>TransactionBlock block</summary>
        public TransactionBlockBlock TransactionBlock;
        /// <summary>FolderData block</summary>
        public FolderDataBlock[] FolderData;

        /// <summary>Default constructor</summary>
        public AcceptFriendshipPacket()
        {
            Header = new LowHeader();
            Header.ID = 358;
            Header.Reliable = true;
            TransactionBlock = new TransactionBlockBlock();
            FolderData = new FolderDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AcceptFriendshipPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AcceptFriendshipPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransactionBlock.Length;;
            for (int j = 0; j < FolderData.Length; j++) { length += FolderData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransactionBlock.ToBytes(bytes, ref i);
            bytes[i++] = (byte)FolderData.Length;
            for (int j = 0; j < FolderData.Length; j++) { FolderData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DeclineFriendship packet</summary>
    public class DeclineFriendshipPacket : Packet
    {
        /// <summary>TransactionBlock block</summary>
        public class TransactionBlockBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DeclineFriendship</summary>
        public override PacketType Type { get { return PacketType.DeclineFriendship; } }
        /// <summary>TransactionBlock block</summary>
        public TransactionBlockBlock TransactionBlock;

        /// <summary>Default constructor</summary>
        public DeclineFriendshipPacket()
        {
            Header = new LowHeader();
            Header.ID = 359;
            Header.Reliable = true;
            TransactionBlock = new TransactionBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DeclineFriendshipPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DeclineFriendshipPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransactionBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransactionBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>FormFriendship packet</summary>
    public class FormFriendshipPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    DestID = new LLUUID(bytes, i); i += 16;
                    SourceID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.FormFriendship</summary>
        public override PacketType Type { get { return PacketType.FormFriendship; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public FormFriendshipPacket()
        {
            Header = new LowHeader();
            Header.ID = 360;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public FormFriendshipPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public FormFriendshipPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TerminateFriendship packet</summary>
    public class TerminateFriendshipPacket : Packet
    {
        /// <summary>ExBlock block</summary>
        public class ExBlockBlock
        {
            /// <summary>OtherID field</summary>
            public LLUUID OtherID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ExBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ExBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    OtherID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(OtherID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TerminateFriendship</summary>
        public override PacketType Type { get { return PacketType.TerminateFriendship; } }
        /// <summary>ExBlock block</summary>
        public ExBlockBlock ExBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public TerminateFriendshipPacket()
        {
            Header = new LowHeader();
            Header.ID = 361;
            Header.Reliable = true;
            ExBlock = new ExBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TerminateFriendshipPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ExBlock = new ExBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TerminateFriendshipPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ExBlock = new ExBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ExBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ExBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>OfferCallingCard packet</summary>
    public class OfferCallingCardPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    DestID = new LLUUID(bytes, i); i += 16;
                    SourceID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.OfferCallingCard</summary>
        public override PacketType Type { get { return PacketType.OfferCallingCard; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public OfferCallingCardPacket()
        {
            Header = new LowHeader();
            Header.ID = 362;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public OfferCallingCardPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public OfferCallingCardPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AcceptCallingCard packet</summary>
    public class AcceptCallingCardPacket : Packet
    {
        /// <summary>TransactionBlock block</summary>
        public class TransactionBlockBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>FolderData block</summary>
        public class FolderDataBlock
        {
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FolderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FolderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AcceptCallingCard</summary>
        public override PacketType Type { get { return PacketType.AcceptCallingCard; } }
        /// <summary>TransactionBlock block</summary>
        public TransactionBlockBlock TransactionBlock;
        /// <summary>FolderData block</summary>
        public FolderDataBlock[] FolderData;

        /// <summary>Default constructor</summary>
        public AcceptCallingCardPacket()
        {
            Header = new LowHeader();
            Header.ID = 363;
            Header.Reliable = true;
            TransactionBlock = new TransactionBlockBlock();
            FolderData = new FolderDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AcceptCallingCardPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AcceptCallingCardPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
            int count = (int)bytes[i++];
            FolderData = new FolderDataBlock[count];
            for (int j = 0; j < count; j++)
            { FolderData[j] = new FolderDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransactionBlock.Length;;
            for (int j = 0; j < FolderData.Length; j++) { length += FolderData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransactionBlock.ToBytes(bytes, ref i);
            bytes[i++] = (byte)FolderData.Length;
            for (int j = 0; j < FolderData.Length; j++) { FolderData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DeclineCallingCard packet</summary>
    public class DeclineCallingCardPacket : Packet
    {
        /// <summary>TransactionBlock block</summary>
        public class TransactionBlockBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DeclineCallingCard</summary>
        public override PacketType Type { get { return PacketType.DeclineCallingCard; } }
        /// <summary>TransactionBlock block</summary>
        public TransactionBlockBlock TransactionBlock;

        /// <summary>Default constructor</summary>
        public DeclineCallingCardPacket()
        {
            Header = new LowHeader();
            Header.ID = 364;
            Header.Reliable = true;
            TransactionBlock = new TransactionBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DeclineCallingCardPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DeclineCallingCardPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransactionBlock = new TransactionBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TransactionBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransactionBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RezScript packet</summary>
    public class RezScriptPacket : Packet
    {
        /// <summary>UpdateBlock block</summary>
        public class UpdateBlockBlock
        {
            /// <summary>Enabled field</summary>
            public bool Enabled;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UpdateBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UpdateBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Enabled = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Enabled) ? 1 : 0);
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>InventoryBlock block</summary>
        public class InventoryBlockBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 136;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RezScript</summary>
        public override PacketType Type { get { return PacketType.RezScript; } }
        /// <summary>UpdateBlock block</summary>
        public UpdateBlockBlock UpdateBlock;
        /// <summary>InventoryBlock block</summary>
        public InventoryBlockBlock InventoryBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RezScriptPacket()
        {
            Header = new LowHeader();
            Header.ID = 365;
            Header.Reliable = true;
            Header.Zerocoded = true;
            UpdateBlock = new UpdateBlockBlock();
            InventoryBlock = new InventoryBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RezScriptPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            UpdateBlock = new UpdateBlockBlock(bytes, ref i);
            InventoryBlock = new InventoryBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RezScriptPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            UpdateBlock = new UpdateBlockBlock(bytes, ref i);
            InventoryBlock = new InventoryBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += UpdateBlock.Length;            length += InventoryBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            UpdateBlock.ToBytes(bytes, ref i);
            InventoryBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CreateInventoryItem packet</summary>
    public class CreateInventoryItemPacket : Packet
    {
        /// <summary>InventoryBlock block</summary>
        public class InventoryBlockBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 22;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    FolderID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CreateInventoryItem</summary>
        public override PacketType Type { get { return PacketType.CreateInventoryItem; } }
        /// <summary>InventoryBlock block</summary>
        public InventoryBlockBlock InventoryBlock;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public CreateInventoryItemPacket()
        {
            Header = new LowHeader();
            Header.ID = 366;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryBlock = new InventoryBlockBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CreateInventoryItemPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryBlock = new InventoryBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CreateInventoryItemPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryBlock = new InventoryBlockBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryBlock.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryBlock.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CreateLandmarkForEvent packet</summary>
    public class CreateLandmarkForEventPacket : Packet
    {
        /// <summary>InventoryBlock block</summary>
        public class InventoryBlockBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    FolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>EventID field</summary>
            public uint EventID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CreateLandmarkForEvent</summary>
        public override PacketType Type { get { return PacketType.CreateLandmarkForEvent; } }
        /// <summary>InventoryBlock block</summary>
        public InventoryBlockBlock InventoryBlock;
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public CreateLandmarkForEventPacket()
        {
            Header = new LowHeader();
            Header.ID = 367;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryBlock = new InventoryBlockBlock();
            EventData = new EventDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CreateLandmarkForEventPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryBlock = new InventoryBlockBlock(bytes, ref i);
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CreateLandmarkForEventPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryBlock = new InventoryBlockBlock(bytes, ref i);
            EventData = new EventDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryBlock.Length;            length += EventData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryBlock.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EventLocationRequest packet</summary>
    public class EventLocationRequestPacket : Packet
    {
        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>EventID field</summary>
            public uint EventID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EventID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(EventID % 256);
                bytes[i++] = (byte)((EventID >> 8) % 256);
                bytes[i++] = (byte)((EventID >> 16) % 256);
                bytes[i++] = (byte)((EventID >> 24) % 256);
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EventLocationRequest</summary>
        public override PacketType Type { get { return PacketType.EventLocationRequest; } }
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;

        /// <summary>Default constructor</summary>
        public EventLocationRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 368;
            Header.Reliable = true;
            Header.Zerocoded = true;
            EventData = new EventDataBlock();
            QueryData = new QueryDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EventLocationRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            EventData = new EventDataBlock(bytes, ref i);
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EventLocationRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EventData = new EventDataBlock(bytes, ref i);
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += EventData.Length;            length += QueryData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EventLocationReply packet</summary>
    public class EventLocationReplyPacket : Packet
    {
        /// <summary>EventData block</summary>
        public class EventDataBlock
        {
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>Success field</summary>
            public bool Success;
            /// <summary>RegionPos field</summary>
            public LLVector3 RegionPos;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EventDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EventDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionID = new LLUUID(bytes, i); i += 16;
                    Success = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RegionPos = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Success) ? 1 : 0);
                Array.Copy(RegionPos.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>QueryData block</summary>
        public class QueryDataBlock
        {
            /// <summary>QueryID field</summary>
            public LLUUID QueryID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public QueryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public QueryDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    QueryID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(QueryID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EventLocationReply</summary>
        public override PacketType Type { get { return PacketType.EventLocationReply; } }
        /// <summary>EventData block</summary>
        public EventDataBlock EventData;
        /// <summary>QueryData block</summary>
        public QueryDataBlock QueryData;

        /// <summary>Default constructor</summary>
        public EventLocationReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 369;
            Header.Reliable = true;
            Header.Zerocoded = true;
            EventData = new EventDataBlock();
            QueryData = new QueryDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EventLocationReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            EventData = new EventDataBlock(bytes, ref i);
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EventLocationReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EventData = new EventDataBlock(bytes, ref i);
            QueryData = new QueryDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += EventData.Length;            length += QueryData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EventData.ToBytes(bytes, ref i);
            QueryData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionHandleRequest packet</summary>
    public class RegionHandleRequestPacket : Packet
    {
        /// <summary>RequestBlock block</summary>
        public class RequestBlockBlock
        {
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionHandleRequest</summary>
        public override PacketType Type { get { return PacketType.RegionHandleRequest; } }
        /// <summary>RequestBlock block</summary>
        public RequestBlockBlock RequestBlock;

        /// <summary>Default constructor</summary>
        public RegionHandleRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 370;
            Header.Reliable = true;
            RequestBlock = new RequestBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionHandleRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestBlock = new RequestBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionHandleRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestBlock = new RequestBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RegionIDAndHandleReply packet</summary>
    public class RegionIDAndHandleReplyPacket : Packet
    {
        /// <summary>ReplyBlock block</summary>
        public class ReplyBlockBlock
        {
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReplyBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReplyBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RegionIDAndHandleReply</summary>
        public override PacketType Type { get { return PacketType.RegionIDAndHandleReply; } }
        /// <summary>ReplyBlock block</summary>
        public ReplyBlockBlock ReplyBlock;

        /// <summary>Default constructor</summary>
        public RegionIDAndHandleReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 371;
            Header.Reliable = true;
            ReplyBlock = new ReplyBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RegionIDAndHandleReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ReplyBlock = new ReplyBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RegionIDAndHandleReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ReplyBlock = new ReplyBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ReplyBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ReplyBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyTransferRequest packet</summary>
    public class MoneyTransferRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>AggregatePermInventory field</summary>
            public byte AggregatePermInventory;
            /// <summary>AggregatePermNextOwner field</summary>
            public byte AggregatePermNextOwner;
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>Amount field</summary>
            public int Amount;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>TransactionType field</summary>
            public int TransactionType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 43;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AggregatePermInventory = (byte)bytes[i++];
                    AggregatePermNextOwner = (byte)bytes[i++];
                    DestID = new LLUUID(bytes, i); i += 16;
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (byte)bytes[i++];
                    SourceID = new LLUUID(bytes, i); i += 16;
                    TransactionType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = AggregatePermInventory;
                bytes[i++] = AggregatePermNextOwner;
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = Flags;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TransactionType % 256);
                bytes[i++] = (byte)((TransactionType >> 8) % 256);
                bytes[i++] = (byte)((TransactionType >> 16) % 256);
                bytes[i++] = (byte)((TransactionType >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyTransferRequest</summary>
        public override PacketType Type { get { return PacketType.MoneyTransferRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneyTransferRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 372;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyTransferRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyTransferRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyTransferBackend packet</summary>
    public class MoneyTransferBackendPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>AggregatePermInventory field</summary>
            public byte AggregatePermInventory;
            /// <summary>AggregatePermNextOwner field</summary>
            public byte AggregatePermNextOwner;
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>Amount field</summary>
            public int Amount;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>SourceID field</summary>
            public LLUUID SourceID;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;
            /// <summary>TransactionTime field</summary>
            public uint TransactionTime;
            /// <summary>TransactionType field</summary>
            public int TransactionType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 63;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AggregatePermInventory = (byte)bytes[i++];
                    AggregatePermNextOwner = (byte)bytes[i++];
                    DestID = new LLUUID(bytes, i); i += 16;
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (byte)bytes[i++];
                    SourceID = new LLUUID(bytes, i); i += 16;
                    TransactionID = new LLUUID(bytes, i); i += 16;
                    TransactionTime = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = AggregatePermInventory;
                bytes[i++] = AggregatePermNextOwner;
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = Flags;
                Array.Copy(SourceID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TransactionTime % 256);
                bytes[i++] = (byte)((TransactionTime >> 8) % 256);
                bytes[i++] = (byte)((TransactionTime >> 16) % 256);
                bytes[i++] = (byte)((TransactionTime >> 24) % 256);
                bytes[i++] = (byte)(TransactionType % 256);
                bytes[i++] = (byte)((TransactionType >> 8) % 256);
                bytes[i++] = (byte)((TransactionType >> 16) % 256);
                bytes[i++] = (byte)((TransactionType >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyTransferBackend</summary>
        public override PacketType Type { get { return PacketType.MoneyTransferBackend; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;

        /// <summary>Default constructor</summary>
        public MoneyTransferBackendPacket()
        {
            Header = new LowHeader();
            Header.ID = 373;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyTransferBackendPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyTransferBackendPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>BulkMoneyTransfer packet</summary>
    public class BulkMoneyTransferPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>DestID field</summary>
            public LLUUID DestID;
            /// <summary>Amount field</summary>
            public int Amount;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;
            /// <summary>TransactionType field</summary>
            public int TransactionType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 42;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    DestID = new LLUUID(bytes, i); i += 16;
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (byte)bytes[i++];
                    TransactionID = new LLUUID(bytes, i); i += 16;
                    TransactionType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(DestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = Flags;
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TransactionType % 256);
                bytes[i++] = (byte)((TransactionType >> 8) % 256);
                bytes[i++] = (byte)((TransactionType >> 16) % 256);
                bytes[i++] = (byte)((TransactionType >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RegionX field</summary>
            public uint RegionX;
            /// <summary>RegionY field</summary>
            public uint RegionY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RegionX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionX % 256);
                bytes[i++] = (byte)((RegionX >> 8) % 256);
                bytes[i++] = (byte)((RegionX >> 16) % 256);
                bytes[i++] = (byte)((RegionX >> 24) % 256);
                bytes[i++] = (byte)(RegionY % 256);
                bytes[i++] = (byte)((RegionY >> 8) % 256);
                bytes[i++] = (byte)((RegionY >> 16) % 256);
                bytes[i++] = (byte)((RegionY >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.BulkMoneyTransfer</summary>
        public override PacketType Type { get { return PacketType.BulkMoneyTransfer; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock[] MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public BulkMoneyTransferPacket()
        {
            Header = new LowHeader();
            Header.ID = 374;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public BulkMoneyTransferPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            MoneyData = new MoneyDataBlock[count];
            for (int j = 0; j < count; j++)
            { MoneyData[j] = new MoneyDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public BulkMoneyTransferPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            MoneyData = new MoneyDataBlock[count];
            for (int j = 0; j < count; j++)
            { MoneyData[j] = new MoneyDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < MoneyData.Length; j++) { length += MoneyData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)MoneyData.Length;
            for (int j = 0; j < MoneyData.Length; j++) { MoneyData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AdjustBalance packet</summary>
    public class AdjustBalancePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Delta field</summary>
            public int Delta;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Delta = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Delta % 256);
                bytes[i++] = (byte)((Delta >> 8) % 256);
                bytes[i++] = (byte)((Delta >> 16) % 256);
                bytes[i++] = (byte)((Delta >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AdjustBalance</summary>
        public override PacketType Type { get { return PacketType.AdjustBalance; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AdjustBalancePacket()
        {
            Header = new LowHeader();
            Header.ID = 375;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AdjustBalancePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AdjustBalancePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyBalanceRequest packet</summary>
    public class MoneyBalanceRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyBalanceRequest</summary>
        public override PacketType Type { get { return PacketType.MoneyBalanceRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneyBalanceRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 376;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyBalanceRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyBalanceRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyBalanceReply packet</summary>
    public class MoneyBalanceReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>MoneyBalance field</summary>
            public int MoneyBalance;
            /// <summary>SquareMetersCredit field</summary>
            public int SquareMetersCredit;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>SquareMetersCommitted field</summary>
            public int SquareMetersCommitted;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;
            /// <summary>TransactionSuccess field</summary>
            public bool TransactionSuccess;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 45;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    MoneyBalance = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SquareMetersCredit = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    SquareMetersCommitted = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionID = new LLUUID(bytes, i); i += 16;
                    TransactionSuccess = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MoneyBalance % 256);
                bytes[i++] = (byte)((MoneyBalance >> 8) % 256);
                bytes[i++] = (byte)((MoneyBalance >> 16) % 256);
                bytes[i++] = (byte)((MoneyBalance >> 24) % 256);
                bytes[i++] = (byte)(SquareMetersCredit % 256);
                bytes[i++] = (byte)((SquareMetersCredit >> 8) % 256);
                bytes[i++] = (byte)((SquareMetersCredit >> 16) % 256);
                bytes[i++] = (byte)((SquareMetersCredit >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(SquareMetersCommitted % 256);
                bytes[i++] = (byte)((SquareMetersCommitted >> 8) % 256);
                bytes[i++] = (byte)((SquareMetersCommitted >> 16) % 256);
                bytes[i++] = (byte)((SquareMetersCommitted >> 24) % 256);
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((TransactionSuccess) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyBalanceReply</summary>
        public override PacketType Type { get { return PacketType.MoneyBalanceReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;

        /// <summary>Default constructor</summary>
        public MoneyBalanceReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 377;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyBalanceReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyBalanceReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RoutedMoneyBalanceReply packet</summary>
    public class RoutedMoneyBalanceReplyPacket : Packet
    {
        /// <summary>TargetBlock block</summary>
        public class TargetBlockBlock
        {
            /// <summary>TargetIP field</summary>
            public uint TargetIP;
            /// <summary>TargetPort field</summary>
            public ushort TargetPort;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TargetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TargetBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TargetPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TargetIP % 256);
                bytes[i++] = (byte)((TargetIP >> 8) % 256);
                bytes[i++] = (byte)((TargetIP >> 16) % 256);
                bytes[i++] = (byte)((TargetIP >> 24) % 256);
                bytes[i++] = (byte)(TargetPort % 256);
                bytes[i++] = (byte)((TargetPort >> 8) % 256);
            }
        }

        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>MoneyBalance field</summary>
            public int MoneyBalance;
            /// <summary>SquareMetersCredit field</summary>
            public int SquareMetersCredit;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>SquareMetersCommitted field</summary>
            public int SquareMetersCommitted;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;
            /// <summary>TransactionSuccess field</summary>
            public bool TransactionSuccess;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 45;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    MoneyBalance = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SquareMetersCredit = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    SquareMetersCommitted = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionID = new LLUUID(bytes, i); i += 16;
                    TransactionSuccess = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MoneyBalance % 256);
                bytes[i++] = (byte)((MoneyBalance >> 8) % 256);
                bytes[i++] = (byte)((MoneyBalance >> 16) % 256);
                bytes[i++] = (byte)((MoneyBalance >> 24) % 256);
                bytes[i++] = (byte)(SquareMetersCredit % 256);
                bytes[i++] = (byte)((SquareMetersCredit >> 8) % 256);
                bytes[i++] = (byte)((SquareMetersCredit >> 16) % 256);
                bytes[i++] = (byte)((SquareMetersCredit >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(SquareMetersCommitted % 256);
                bytes[i++] = (byte)((SquareMetersCommitted >> 8) % 256);
                bytes[i++] = (byte)((SquareMetersCommitted >> 16) % 256);
                bytes[i++] = (byte)((SquareMetersCommitted >> 24) % 256);
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((TransactionSuccess) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RoutedMoneyBalanceReply</summary>
        public override PacketType Type { get { return PacketType.RoutedMoneyBalanceReply; } }
        /// <summary>TargetBlock block</summary>
        public TargetBlockBlock TargetBlock;
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;

        /// <summary>Default constructor</summary>
        public RoutedMoneyBalanceReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 378;
            Header.Reliable = true;
            Header.Zerocoded = true;
            TargetBlock = new TargetBlockBlock();
            MoneyData = new MoneyDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RoutedMoneyBalanceReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RoutedMoneyBalanceReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TargetBlock.Length;            length += MoneyData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TargetBlock.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyHistoryRequest packet</summary>
    public class MoneyHistoryRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>StartPeriod field</summary>
            public int StartPeriod;
            /// <summary>EndPeriod field</summary>
            public int EndPeriod;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    StartPeriod = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EndPeriod = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(StartPeriod % 256);
                bytes[i++] = (byte)((StartPeriod >> 8) % 256);
                bytes[i++] = (byte)((StartPeriod >> 16) % 256);
                bytes[i++] = (byte)((StartPeriod >> 24) % 256);
                bytes[i++] = (byte)(EndPeriod % 256);
                bytes[i++] = (byte)((EndPeriod >> 8) % 256);
                bytes[i++] = (byte)((EndPeriod >> 16) % 256);
                bytes[i++] = (byte)((EndPeriod >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyHistoryRequest</summary>
        public override PacketType Type { get { return PacketType.MoneyHistoryRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;

        /// <summary>Default constructor</summary>
        public MoneyHistoryRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 379;
            Header.Reliable = true;
            MoneyData = new MoneyDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyHistoryRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyHistoryRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyHistoryReply packet</summary>
    public class MoneyHistoryReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>Balance field</summary>
            public int Balance;
            /// <summary>TaxEstimate field</summary>
            public int TaxEstimate;
            private byte[] _startdate;
            /// <summary>StartDate field</summary>
            public byte[] StartDate
            {
                get { return _startdate; }
                set
                {
                    if (value == null) { _startdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdate = new byte[value.Length]; Array.Copy(value, _startdate, value.Length); }
                }
            }
            /// <summary>StartPeriod field</summary>
            public int StartPeriod;
            /// <summary>StipendEstimate field</summary>
            public int StipendEstimate;
            /// <summary>EndPeriod field</summary>
            public int EndPeriod;
            /// <summary>BonusEstimate field</summary>
            public int BonusEstimate;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (StartDate != null) { length += 1 + StartDate.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Balance = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _startdate = new byte[length];
                    Array.Copy(bytes, i, _startdate, 0, length); i += length;
                    StartPeriod = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    StipendEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EndPeriod = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    BonusEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Balance % 256);
                bytes[i++] = (byte)((Balance >> 8) % 256);
                bytes[i++] = (byte)((Balance >> 16) % 256);
                bytes[i++] = (byte)((Balance >> 24) % 256);
                bytes[i++] = (byte)(TaxEstimate % 256);
                bytes[i++] = (byte)((TaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((TaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((TaxEstimate >> 24) % 256);
                bytes[i++] = (byte)StartDate.Length;
                Array.Copy(StartDate, 0, bytes, i, StartDate.Length); i += StartDate.Length;
                bytes[i++] = (byte)(StartPeriod % 256);
                bytes[i++] = (byte)((StartPeriod >> 8) % 256);
                bytes[i++] = (byte)((StartPeriod >> 16) % 256);
                bytes[i++] = (byte)((StartPeriod >> 24) % 256);
                bytes[i++] = (byte)(StipendEstimate % 256);
                bytes[i++] = (byte)((StipendEstimate >> 8) % 256);
                bytes[i++] = (byte)((StipendEstimate >> 16) % 256);
                bytes[i++] = (byte)((StipendEstimate >> 24) % 256);
                bytes[i++] = (byte)(EndPeriod % 256);
                bytes[i++] = (byte)((EndPeriod >> 8) % 256);
                bytes[i++] = (byte)((EndPeriod >> 16) % 256);
                bytes[i++] = (byte)((EndPeriod >> 24) % 256);
                bytes[i++] = (byte)(BonusEstimate % 256);
                bytes[i++] = (byte)((BonusEstimate >> 8) % 256);
                bytes[i++] = (byte)((BonusEstimate >> 16) % 256);
                bytes[i++] = (byte)((BonusEstimate >> 24) % 256);
            }
        }

        /// <summary>HistoryData block</summary>
        public class HistoryDataBlock
        {
            /// <summary>Amount field</summary>
            public int Amount;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HistoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HistoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyHistoryReply</summary>
        public override PacketType Type { get { return PacketType.MoneyHistoryReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>HistoryData block</summary>
        public HistoryDataBlock[] HistoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneyHistoryReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 380;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            HistoryData = new HistoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyHistoryReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyHistoryReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            for (int j = 0; j < HistoryData.Length; j++) { length += HistoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)HistoryData.Length;
            for (int j = 0; j < HistoryData.Length; j++) { HistoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneySummaryRequest packet</summary>
    public class MoneySummaryRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneySummaryRequest</summary>
        public override PacketType Type { get { return PacketType.MoneySummaryRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneySummaryRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 381;
            Header.Reliable = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneySummaryRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneySummaryRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneySummaryReply packet</summary>
    public class MoneySummaryReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>ParcelDirFeeCurrent field</summary>
            public int ParcelDirFeeCurrent;
            private byte[] _taxdate;
            /// <summary>TaxDate field</summary>
            public byte[] TaxDate
            {
                get { return _taxdate; }
                set
                {
                    if (value == null) { _taxdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _taxdate = new byte[value.Length]; Array.Copy(value, _taxdate, value.Length); }
                }
            }
            /// <summary>Balance field</summary>
            public int Balance;
            /// <summary>ParcelDirFeeEstimate field</summary>
            public int ParcelDirFeeEstimate;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>ObjectTaxCurrent field</summary>
            public int ObjectTaxCurrent;
            /// <summary>LightTaxCurrent field</summary>
            public int LightTaxCurrent;
            /// <summary>LandTaxCurrent field</summary>
            public int LandTaxCurrent;
            /// <summary>GroupTaxCurrent field</summary>
            public int GroupTaxCurrent;
            /// <summary>TotalDebits field</summary>
            public int TotalDebits;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>ObjectTaxEstimate field</summary>
            public int ObjectTaxEstimate;
            /// <summary>LightTaxEstimate field</summary>
            public int LightTaxEstimate;
            /// <summary>LandTaxEstimate field</summary>
            public int LandTaxEstimate;
            /// <summary>GroupTaxEstimate field</summary>
            public int GroupTaxEstimate;
            private byte[] _lasttaxdate;
            /// <summary>LastTaxDate field</summary>
            public byte[] LastTaxDate
            {
                get { return _lasttaxdate; }
                set
                {
                    if (value == null) { _lasttaxdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lasttaxdate = new byte[value.Length]; Array.Copy(value, _lasttaxdate, value.Length); }
                }
            }
            private byte[] _startdate;
            /// <summary>StartDate field</summary>
            public byte[] StartDate
            {
                get { return _startdate; }
                set
                {
                    if (value == null) { _startdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdate = new byte[value.Length]; Array.Copy(value, _startdate, value.Length); }
                }
            }
            /// <summary>TotalCredits field</summary>
            public int TotalCredits;
            /// <summary>StipendEstimate field</summary>
            public int StipendEstimate;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;
            /// <summary>BonusEstimate field</summary>
            public int BonusEstimate;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 84;
                    if (TaxDate != null) { length += 1 + TaxDate.Length; }
                    if (LastTaxDate != null) { length += 1 + LastTaxDate.Length; }
                    if (StartDate != null) { length += 1 + StartDate.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ParcelDirFeeCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _taxdate = new byte[length];
                    Array.Copy(bytes, i, _taxdate, 0, length); i += length;
                    Balance = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParcelDirFeeEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RequestID = new LLUUID(bytes, i); i += 16;
                    ObjectTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LightTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LandTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TotalDebits = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ObjectTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LightTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LandTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _lasttaxdate = new byte[length];
                    Array.Copy(bytes, i, _lasttaxdate, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _startdate = new byte[length];
                    Array.Copy(bytes, i, _startdate, 0, length); i += length;
                    TotalCredits = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    StipendEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    BonusEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ParcelDirFeeCurrent % 256);
                bytes[i++] = (byte)((ParcelDirFeeCurrent >> 8) % 256);
                bytes[i++] = (byte)((ParcelDirFeeCurrent >> 16) % 256);
                bytes[i++] = (byte)((ParcelDirFeeCurrent >> 24) % 256);
                bytes[i++] = (byte)TaxDate.Length;
                Array.Copy(TaxDate, 0, bytes, i, TaxDate.Length); i += TaxDate.Length;
                bytes[i++] = (byte)(Balance % 256);
                bytes[i++] = (byte)((Balance >> 8) % 256);
                bytes[i++] = (byte)((Balance >> 16) % 256);
                bytes[i++] = (byte)((Balance >> 24) % 256);
                bytes[i++] = (byte)(ParcelDirFeeEstimate % 256);
                bytes[i++] = (byte)((ParcelDirFeeEstimate >> 8) % 256);
                bytes[i++] = (byte)((ParcelDirFeeEstimate >> 16) % 256);
                bytes[i++] = (byte)((ParcelDirFeeEstimate >> 24) % 256);
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ObjectTaxCurrent % 256);
                bytes[i++] = (byte)((ObjectTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((ObjectTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((ObjectTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(LightTaxCurrent % 256);
                bytes[i++] = (byte)((LightTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((LightTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((LightTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(LandTaxCurrent % 256);
                bytes[i++] = (byte)((LandTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((LandTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((LandTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(GroupTaxCurrent % 256);
                bytes[i++] = (byte)((GroupTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((GroupTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((GroupTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(TotalDebits % 256);
                bytes[i++] = (byte)((TotalDebits >> 8) % 256);
                bytes[i++] = (byte)((TotalDebits >> 16) % 256);
                bytes[i++] = (byte)((TotalDebits >> 24) % 256);
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(ObjectTaxEstimate % 256);
                bytes[i++] = (byte)((ObjectTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((ObjectTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((ObjectTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)(LightTaxEstimate % 256);
                bytes[i++] = (byte)((LightTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((LightTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((LightTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)(LandTaxEstimate % 256);
                bytes[i++] = (byte)((LandTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((LandTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((LandTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)(GroupTaxEstimate % 256);
                bytes[i++] = (byte)((GroupTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((GroupTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((GroupTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)LastTaxDate.Length;
                Array.Copy(LastTaxDate, 0, bytes, i, LastTaxDate.Length); i += LastTaxDate.Length;
                bytes[i++] = (byte)StartDate.Length;
                Array.Copy(StartDate, 0, bytes, i, StartDate.Length); i += StartDate.Length;
                bytes[i++] = (byte)(TotalCredits % 256);
                bytes[i++] = (byte)((TotalCredits >> 8) % 256);
                bytes[i++] = (byte)((TotalCredits >> 16) % 256);
                bytes[i++] = (byte)((TotalCredits >> 24) % 256);
                bytes[i++] = (byte)(StipendEstimate % 256);
                bytes[i++] = (byte)((StipendEstimate >> 8) % 256);
                bytes[i++] = (byte)((StipendEstimate >> 16) % 256);
                bytes[i++] = (byte)((StipendEstimate >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
                bytes[i++] = (byte)(BonusEstimate % 256);
                bytes[i++] = (byte)((BonusEstimate >> 8) % 256);
                bytes[i++] = (byte)((BonusEstimate >> 16) % 256);
                bytes[i++] = (byte)((BonusEstimate >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneySummaryReply</summary>
        public override PacketType Type { get { return PacketType.MoneySummaryReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneySummaryReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 382;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneySummaryReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneySummaryReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyDetailsRequest packet</summary>
    public class MoneyDetailsRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyDetailsRequest</summary>
        public override PacketType Type { get { return PacketType.MoneyDetailsRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneyDetailsRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 383;
            Header.Reliable = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyDetailsRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyDetailsRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyDetailsReply packet</summary>
    public class MoneyDetailsReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            private byte[] _startdate;
            /// <summary>StartDate field</summary>
            public byte[] StartDate
            {
                get { return _startdate; }
                set
                {
                    if (value == null) { _startdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdate = new byte[value.Length]; Array.Copy(value, _startdate, value.Length); }
                }
            }
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (StartDate != null) { length += 1 + StartDate.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _startdate = new byte[length];
                    Array.Copy(bytes, i, _startdate, 0, length); i += length;
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)StartDate.Length;
                Array.Copy(StartDate, 0, bytes, i, StartDate.Length); i += StartDate.Length;
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>HistoryData block</summary>
        public class HistoryDataBlock
        {
            /// <summary>Amount field</summary>
            public int Amount;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HistoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HistoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyDetailsReply</summary>
        public override PacketType Type { get { return PacketType.MoneyDetailsReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>HistoryData block</summary>
        public HistoryDataBlock[] HistoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneyDetailsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 384;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            HistoryData = new HistoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyDetailsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyDetailsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            for (int j = 0; j < HistoryData.Length; j++) { length += HistoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)HistoryData.Length;
            for (int j = 0; j < HistoryData.Length; j++) { HistoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyTransactionsRequest packet</summary>
    public class MoneyTransactionsRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyTransactionsRequest</summary>
        public override PacketType Type { get { return PacketType.MoneyTransactionsRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneyTransactionsRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 385;
            Header.Reliable = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyTransactionsRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyTransactionsRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MoneyTransactionsReply packet</summary>
    public class MoneyTransactionsReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            private byte[] _startdate;
            /// <summary>StartDate field</summary>
            public byte[] StartDate
            {
                get { return _startdate; }
                set
                {
                    if (value == null) { _startdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdate = new byte[value.Length]; Array.Copy(value, _startdate, value.Length); }
                }
            }
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (StartDate != null) { length += 1 + StartDate.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _startdate = new byte[length];
                    Array.Copy(bytes, i, _startdate, 0, length); i += length;
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)StartDate.Length;
                Array.Copy(StartDate, 0, bytes, i, StartDate.Length); i += StartDate.Length;
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>HistoryData block</summary>
        public class HistoryDataBlock
        {
            private byte[] _time;
            /// <summary>Time field</summary>
            public byte[] Time
            {
                get { return _time; }
                set
                {
                    if (value == null) { _time = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _time = new byte[value.Length]; Array.Copy(value, _time, value.Length); }
                }
            }
            private byte[] _item;
            /// <summary>Item field</summary>
            public byte[] Item
            {
                get { return _item; }
                set
                {
                    if (value == null) { _item = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _item = new byte[value.Length]; Array.Copy(value, _item, value.Length); }
                }
            }
            private byte[] _user;
            /// <summary>User field</summary>
            public byte[] User
            {
                get { return _user; }
                set
                {
                    if (value == null) { _user = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _user = new byte[value.Length]; Array.Copy(value, _user, value.Length); }
                }
            }
            /// <summary>Type field</summary>
            public int Type;
            /// <summary>Amount field</summary>
            public int Amount;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    if (Time != null) { length += 1 + Time.Length; }
                    if (Item != null) { length += 1 + Item.Length; }
                    if (User != null) { length += 1 + User.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HistoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HistoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _time = new byte[length];
                    Array.Copy(bytes, i, _time, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _item = new byte[length];
                    Array.Copy(bytes, i, _item, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _user = new byte[length];
                    Array.Copy(bytes, i, _user, 0, length); i += length;
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Time.Length;
                Array.Copy(Time, 0, bytes, i, Time.Length); i += Time.Length;
                bytes[i++] = (byte)Item.Length;
                Array.Copy(Item, 0, bytes, i, Item.Length); i += Item.Length;
                bytes[i++] = (byte)User.Length;
                Array.Copy(User, 0, bytes, i, User.Length); i += User.Length;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MoneyTransactionsReply</summary>
        public override PacketType Type { get { return PacketType.MoneyTransactionsReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>HistoryData block</summary>
        public HistoryDataBlock[] HistoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MoneyTransactionsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 386;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            HistoryData = new HistoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MoneyTransactionsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MoneyTransactionsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            for (int j = 0; j < HistoryData.Length; j++) { length += HistoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)HistoryData.Length;
            for (int j = 0; j < HistoryData.Length; j++) { HistoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GestureRequest packet</summary>
    public class GestureRequestPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Reset field</summary>
            public bool Reset;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Reset = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Reset) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GestureRequest</summary>
        public override PacketType Type { get { return PacketType.GestureRequest; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public GestureRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 387;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GestureRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GestureRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ActivateGestures packet</summary>
    public class ActivateGesturesPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GestureFlags field</summary>
            public uint GestureFlags;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 37;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GestureFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(GestureFlags % 256);
                bytes[i++] = (byte)((GestureFlags >> 8) % 256);
                bytes[i++] = (byte)((GestureFlags >> 16) % 256);
                bytes[i++] = (byte)((GestureFlags >> 24) % 256);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ActivateGestures</summary>
        public override PacketType Type { get { return PacketType.ActivateGestures; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ActivateGesturesPacket()
        {
            Header = new LowHeader();
            Header.ID = 388;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ActivateGesturesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ActivateGesturesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DeactivateGestures packet</summary>
    public class DeactivateGesturesPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>GestureFlags field</summary>
            public uint GestureFlags;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GestureFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(GestureFlags % 256);
                bytes[i++] = (byte)((GestureFlags >> 8) % 256);
                bytes[i++] = (byte)((GestureFlags >> 16) % 256);
                bytes[i++] = (byte)((GestureFlags >> 24) % 256);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DeactivateGestures</summary>
        public override PacketType Type { get { return PacketType.DeactivateGestures; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public DeactivateGesturesPacket()
        {
            Header = new LowHeader();
            Header.ID = 389;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DeactivateGesturesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DeactivateGesturesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InventoryUpdate packet</summary>
    public class InventoryUpdatePacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>IsComplete field</summary>
            public byte IsComplete;
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    IsComplete = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = IsComplete;
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InventoryUpdate</summary>
        public override PacketType Type { get { return PacketType.InventoryUpdate; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public InventoryUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 390;
            Header.Reliable = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InventoryUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InventoryUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MuteListUpdate packet</summary>
    public class MuteListUpdatePacket : Packet
    {
        /// <summary>MuteData block</summary>
        public class MuteDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MuteDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MuteDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MuteListUpdate</summary>
        public override PacketType Type { get { return PacketType.MuteListUpdate; } }
        /// <summary>MuteData block</summary>
        public MuteDataBlock MuteData;

        /// <summary>Default constructor</summary>
        public MuteListUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 391;
            Header.Reliable = true;
            MuteData = new MuteDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MuteListUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MuteListUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MuteData = new MuteDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MuteData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MuteData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UseCachedMuteList packet</summary>
    public class UseCachedMuteListPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UseCachedMuteList</summary>
        public override PacketType Type { get { return PacketType.UseCachedMuteList; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UseCachedMuteListPacket()
        {
            Header = new LowHeader();
            Header.ID = 392;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UseCachedMuteListPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UseCachedMuteListPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserLoginLocationReply packet</summary>
    public class UserLoginLocationReplyPacket : Packet
    {
        /// <summary>URLBlock block</summary>
        public class URLBlockBlock
        {
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>LocationLookAt field</summary>
            public LLVector3 LocationLookAt;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public URLBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public URLBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LocationLookAt = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                Array.Copy(LocationLookAt.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>SimulatorBlock block</summary>
        public class SimulatorBlockBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>Port field</summary>
            public ushort Port;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
            }
        }

        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>SecPerDay field</summary>
            public uint SecPerDay;
            /// <summary>MetersPerGrid field</summary>
            public float MetersPerGrid;
            /// <summary>UsecSinceStart field</summary>
            public ulong UsecSinceStart;
            /// <summary>LocationValid field</summary>
            public bool LocationValid;
            /// <summary>SecPerYear field</summary>
            public uint SecPerYear;
            /// <summary>GridsPerEdge field</summary>
            public uint GridsPerEdge;
            /// <summary>Handle field</summary>
            public ulong Handle;
            /// <summary>SunAngVelocity field</summary>
            public LLVector3 SunAngVelocity;
            /// <summary>SunDirection field</summary>
            public LLVector3 SunDirection;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 57;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SecPerDay = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    MetersPerGrid = BitConverter.ToSingle(bytes, i); i += 4;
                    UsecSinceStart = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LocationValid = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    SecPerYear = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridsPerEdge = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Handle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SunAngVelocity = new LLVector3(bytes, i); i += 12;
                    SunDirection = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(SecPerDay % 256);
                bytes[i++] = (byte)((SecPerDay >> 8) % 256);
                bytes[i++] = (byte)((SecPerDay >> 16) % 256);
                bytes[i++] = (byte)((SecPerDay >> 24) % 256);
                ba = BitConverter.GetBytes(MetersPerGrid);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(UsecSinceStart % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 8) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 16) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 24) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 32) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 40) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 48) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 56) % 256);
                bytes[i++] = (byte)((LocationValid) ? 1 : 0);
                bytes[i++] = (byte)(SecPerYear % 256);
                bytes[i++] = (byte)((SecPerYear >> 8) % 256);
                bytes[i++] = (byte)((SecPerYear >> 16) % 256);
                bytes[i++] = (byte)((SecPerYear >> 24) % 256);
                bytes[i++] = (byte)(GridsPerEdge % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 8) % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 16) % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 24) % 256);
                bytes[i++] = (byte)(Handle % 256);
                bytes[i++] = (byte)((Handle >> 8) % 256);
                bytes[i++] = (byte)((Handle >> 16) % 256);
                bytes[i++] = (byte)((Handle >> 24) % 256);
                bytes[i++] = (byte)((Handle >> 32) % 256);
                bytes[i++] = (byte)((Handle >> 40) % 256);
                bytes[i++] = (byte)((Handle >> 48) % 256);
                bytes[i++] = (byte)((Handle >> 56) % 256);
                Array.Copy(SunAngVelocity.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(SunDirection.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserLoginLocationReply</summary>
        public override PacketType Type { get { return PacketType.UserLoginLocationReply; } }
        /// <summary>URLBlock block</summary>
        public URLBlockBlock URLBlock;
        /// <summary>SimulatorBlock block</summary>
        public SimulatorBlockBlock SimulatorBlock;
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UserLoginLocationReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 393;
            Header.Reliable = true;
            Header.Zerocoded = true;
            URLBlock = new URLBlockBlock();
            SimulatorBlock = new SimulatorBlockBlock();
            RegionInfo = new RegionInfoBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserLoginLocationReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            URLBlock = new URLBlockBlock(bytes, ref i);
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserLoginLocationReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            URLBlock = new URLBlockBlock(bytes, ref i);
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += URLBlock.Length;            length += SimulatorBlock.Length;            length += RegionInfo.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            URLBlock.ToBytes(bytes, ref i);
            SimulatorBlock.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserSimLocationReply packet</summary>
    public class UserSimLocationReplyPacket : Packet
    {
        /// <summary>SimulatorBlock block</summary>
        public class SimulatorBlockBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>AccessOK field</summary>
            public byte AccessOK;
            /// <summary>SimHandle field</summary>
            public ulong SimHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    AccessOK = (byte)bytes[i++];
                    SimHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                bytes[i++] = AccessOK;
                bytes[i++] = (byte)(SimHandle % 256);
                bytes[i++] = (byte)((SimHandle >> 8) % 256);
                bytes[i++] = (byte)((SimHandle >> 16) % 256);
                bytes[i++] = (byte)((SimHandle >> 24) % 256);
                bytes[i++] = (byte)((SimHandle >> 32) % 256);
                bytes[i++] = (byte)((SimHandle >> 40) % 256);
                bytes[i++] = (byte)((SimHandle >> 48) % 256);
                bytes[i++] = (byte)((SimHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserSimLocationReply</summary>
        public override PacketType Type { get { return PacketType.UserSimLocationReply; } }
        /// <summary>SimulatorBlock block</summary>
        public SimulatorBlockBlock SimulatorBlock;

        /// <summary>Default constructor</summary>
        public UserSimLocationReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 394;
            Header.Reliable = true;
            SimulatorBlock = new SimulatorBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserSimLocationReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserSimLocationReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SimulatorBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimulatorBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserListReply packet</summary>
    public class UserListReplyPacket : Packet
    {
        /// <summary>UserBlock block</summary>
        public class UserBlockBlock
        {
            private byte[] _lastname;
            /// <summary>LastName field</summary>
            public byte[] LastName
            {
                get { return _lastname; }
                set
                {
                    if (value == null) { _lastname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lastname = new byte[value.Length]; Array.Copy(value, _lastname, value.Length); }
                }
            }
            private byte[] _firstname;
            /// <summary>FirstName field</summary>
            public byte[] FirstName
            {
                get { return _firstname; }
                set
                {
                    if (value == null) { _firstname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _firstname = new byte[value.Length]; Array.Copy(value, _firstname, value.Length); }
                }
            }
            /// <summary>Status field</summary>
            public byte Status;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    if (LastName != null) { length += 1 + LastName.Length; }
                    if (FirstName != null) { length += 1 + FirstName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _lastname = new byte[length];
                    Array.Copy(bytes, i, _lastname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _firstname = new byte[length];
                    Array.Copy(bytes, i, _firstname, 0, length); i += length;
                    Status = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)LastName.Length;
                Array.Copy(LastName, 0, bytes, i, LastName.Length); i += LastName.Length;
                bytes[i++] = (byte)FirstName.Length;
                Array.Copy(FirstName, 0, bytes, i, FirstName.Length); i += FirstName.Length;
                bytes[i++] = Status;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserListReply</summary>
        public override PacketType Type { get { return PacketType.UserListReply; } }
        /// <summary>UserBlock block</summary>
        public UserBlockBlock[] UserBlock;

        /// <summary>Default constructor</summary>
        public UserListReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 395;
            Header.Reliable = true;
            UserBlock = new UserBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserListReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            UserBlock = new UserBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UserBlock[j] = new UserBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserListReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            UserBlock = new UserBlockBlock[count];
            for (int j = 0; j < count; j++)
            { UserBlock[j] = new UserBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < UserBlock.Length; j++) { length += UserBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)UserBlock.Length;
            for (int j = 0; j < UserBlock.Length; j++) { UserBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>OnlineNotification packet</summary>
    public class OnlineNotificationPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.OnlineNotification</summary>
        public override PacketType Type { get { return PacketType.OnlineNotification; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock[] AgentBlock;

        /// <summary>Default constructor</summary>
        public OnlineNotificationPacket()
        {
            Header = new LowHeader();
            Header.ID = 396;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public OnlineNotificationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public OnlineNotificationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentBlock.Length; j++) { length += AgentBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentBlock.Length;
            for (int j = 0; j < AgentBlock.Length; j++) { AgentBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>OfflineNotification packet</summary>
    public class OfflineNotificationPacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.OfflineNotification</summary>
        public override PacketType Type { get { return PacketType.OfflineNotification; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock[] AgentBlock;

        /// <summary>Default constructor</summary>
        public OfflineNotificationPacket()
        {
            Header = new LowHeader();
            Header.ID = 397;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public OfflineNotificationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public OfflineNotificationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentBlock = new AgentBlockBlock[count];
            for (int j = 0; j < count; j++)
            { AgentBlock[j] = new AgentBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentBlock.Length; j++) { length += AgentBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentBlock.Length;
            for (int j = 0; j < AgentBlock.Length; j++) { AgentBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetStartLocationRequest packet</summary>
    public class SetStartLocationRequestPacket : Packet
    {
        /// <summary>StartLocationData block</summary>
        public class StartLocationDataBlock
        {
            /// <summary>LocationPos field</summary>
            public LLVector3 LocationPos;
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>LocationLookAt field</summary>
            public LLVector3 LocationLookAt;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public StartLocationDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public StartLocationDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    LocationPos = new LLVector3(bytes, i); i += 12;
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LocationLookAt = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(LocationPos.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                Array.Copy(LocationLookAt.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetStartLocationRequest</summary>
        public override PacketType Type { get { return PacketType.SetStartLocationRequest; } }
        /// <summary>StartLocationData block</summary>
        public StartLocationDataBlock StartLocationData;

        /// <summary>Default constructor</summary>
        public SetStartLocationRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 398;
            Header.Reliable = true;
            Header.Zerocoded = true;
            StartLocationData = new StartLocationDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetStartLocationRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            StartLocationData = new StartLocationDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetStartLocationRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            StartLocationData = new StartLocationDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += StartLocationData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            StartLocationData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetStartLocation packet</summary>
    public class SetStartLocationPacket : Packet
    {
        /// <summary>StartLocationData block</summary>
        public class StartLocationDataBlock
        {
            /// <summary>LocationPos field</summary>
            public LLVector3 LocationPos;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>LocationLookAt field</summary>
            public LLVector3 LocationLookAt;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 68;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public StartLocationDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public StartLocationDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocationPos = new LLVector3(bytes, i); i += 12;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RegionID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LocationLookAt = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(LocationPos.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                Array.Copy(LocationLookAt.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetStartLocation</summary>
        public override PacketType Type { get { return PacketType.SetStartLocation; } }
        /// <summary>StartLocationData block</summary>
        public StartLocationDataBlock StartLocationData;

        /// <summary>Default constructor</summary>
        public SetStartLocationPacket()
        {
            Header = new LowHeader();
            Header.ID = 399;
            Header.Reliable = true;
            Header.Zerocoded = true;
            StartLocationData = new StartLocationDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetStartLocationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            StartLocationData = new StartLocationDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetStartLocationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            StartLocationData = new StartLocationDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += StartLocationData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            StartLocationData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserLoginLocationRequest packet</summary>
    public class UserLoginLocationRequestPacket : Packet
    {
        /// <summary>URLBlock block</summary>
        public class URLBlockBlock
        {
            private byte[] _simname;
            /// <summary>SimName field</summary>
            public byte[] SimName
            {
                get { return _simname; }
                set
                {
                    if (value == null) { _simname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simname = new byte[value.Length]; Array.Copy(value, _simname, value.Length); }
                }
            }
            /// <summary>Pos field</summary>
            public LLVector3 Pos;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    if (SimName != null) { length += 1 + SimName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public URLBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public URLBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simname = new byte[length];
                    Array.Copy(bytes, i, _simname, 0, length); i += length;
                    Pos = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimName.Length;
                Array.Copy(SimName, 0, bytes, i, SimName.Length); i += SimName.Length;
                Array.Copy(Pos.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>PositionBlock block</summary>
        public class PositionBlockBlock
        {
            /// <summary>ViewerRegion field</summary>
            public ulong ViewerRegion;
            /// <summary>ViewerPosition field</summary>
            public LLVector3 ViewerPosition;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PositionBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PositionBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ViewerRegion = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    ViewerPosition = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ViewerRegion % 256);
                bytes[i++] = (byte)((ViewerRegion >> 8) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 16) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 24) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 32) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 40) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 48) % 256);
                bytes[i++] = (byte)((ViewerRegion >> 56) % 256);
                Array.Copy(ViewerPosition.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>UserBlock block</summary>
        public class UserBlockBlock
        {
            /// <summary>FirstLogin field</summary>
            public bool FirstLogin;
            /// <summary>TravelAccess field</summary>
            public byte TravelAccess;
            /// <summary>LimitedToEstate field</summary>
            public uint LimitedToEstate;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 22;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    FirstLogin = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    TravelAccess = (byte)bytes[i++];
                    LimitedToEstate = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((FirstLogin) ? 1 : 0);
                bytes[i++] = TravelAccess;
                bytes[i++] = (byte)(LimitedToEstate % 256);
                bytes[i++] = (byte)((LimitedToEstate >> 8) % 256);
                bytes[i++] = (byte)((LimitedToEstate >> 16) % 256);
                bytes[i++] = (byte)((LimitedToEstate >> 24) % 256);
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserLoginLocationRequest</summary>
        public override PacketType Type { get { return PacketType.UserLoginLocationRequest; } }
        /// <summary>URLBlock block</summary>
        public URLBlockBlock URLBlock;
        /// <summary>PositionBlock block</summary>
        public PositionBlockBlock PositionBlock;
        /// <summary>UserBlock block</summary>
        public UserBlockBlock UserBlock;

        /// <summary>Default constructor</summary>
        public UserLoginLocationRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 400;
            Header.Reliable = true;
            Header.Zerocoded = true;
            URLBlock = new URLBlockBlock();
            PositionBlock = new PositionBlockBlock();
            UserBlock = new UserBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserLoginLocationRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            URLBlock = new URLBlockBlock(bytes, ref i);
            PositionBlock = new PositionBlockBlock(bytes, ref i);
            UserBlock = new UserBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserLoginLocationRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            URLBlock = new URLBlockBlock(bytes, ref i);
            PositionBlock = new PositionBlockBlock(bytes, ref i);
            UserBlock = new UserBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += URLBlock.Length;            length += PositionBlock.Length;            length += UserBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            URLBlock.ToBytes(bytes, ref i);
            PositionBlock.ToBytes(bytes, ref i);
            UserBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SpaceLoginLocationReply packet</summary>
    public class SpaceLoginLocationReplyPacket : Packet
    {
        /// <summary>SimulatorBlock block</summary>
        public class SimulatorBlockBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 11;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    SimAccess = (byte)bytes[i++];
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = SimAccess;
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
            }
        }

        /// <summary>UserBlock block</summary>
        public class UserBlockBlock
        {
            /// <summary>LocationPos field</summary>
            public LLVector3 LocationPos;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>LocationID field</summary>
            public uint LocationID;
            /// <summary>LocationLookAt field</summary>
            public LLVector3 LocationLookAt;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LocationPos = new LLVector3(bytes, i); i += 12;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    LocationID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LocationLookAt = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(LocationPos.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(LocationID % 256);
                bytes[i++] = (byte)((LocationID >> 8) % 256);
                bytes[i++] = (byte)((LocationID >> 16) % 256);
                bytes[i++] = (byte)((LocationID >> 24) % 256);
                Array.Copy(LocationLookAt.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>RegionInfo block</summary>
        public class RegionInfoBlock
        {
            /// <summary>SecPerDay field</summary>
            public uint SecPerDay;
            /// <summary>MetersPerGrid field</summary>
            public float MetersPerGrid;
            /// <summary>UsecSinceStart field</summary>
            public ulong UsecSinceStart;
            /// <summary>SecPerYear field</summary>
            public uint SecPerYear;
            /// <summary>GridsPerEdge field</summary>
            public uint GridsPerEdge;
            /// <summary>Handle field</summary>
            public ulong Handle;
            /// <summary>SunAngVelocity field</summary>
            public LLVector3 SunAngVelocity;
            /// <summary>SunDirection field</summary>
            public LLVector3 SunDirection;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 56;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SecPerDay = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    MetersPerGrid = BitConverter.ToSingle(bytes, i); i += 4;
                    UsecSinceStart = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SecPerYear = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridsPerEdge = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Handle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SunAngVelocity = new LLVector3(bytes, i); i += 12;
                    SunDirection = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(SecPerDay % 256);
                bytes[i++] = (byte)((SecPerDay >> 8) % 256);
                bytes[i++] = (byte)((SecPerDay >> 16) % 256);
                bytes[i++] = (byte)((SecPerDay >> 24) % 256);
                ba = BitConverter.GetBytes(MetersPerGrid);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(UsecSinceStart % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 8) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 16) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 24) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 32) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 40) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 48) % 256);
                bytes[i++] = (byte)((UsecSinceStart >> 56) % 256);
                bytes[i++] = (byte)(SecPerYear % 256);
                bytes[i++] = (byte)((SecPerYear >> 8) % 256);
                bytes[i++] = (byte)((SecPerYear >> 16) % 256);
                bytes[i++] = (byte)((SecPerYear >> 24) % 256);
                bytes[i++] = (byte)(GridsPerEdge % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 8) % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 16) % 256);
                bytes[i++] = (byte)((GridsPerEdge >> 24) % 256);
                bytes[i++] = (byte)(Handle % 256);
                bytes[i++] = (byte)((Handle >> 8) % 256);
                bytes[i++] = (byte)((Handle >> 16) % 256);
                bytes[i++] = (byte)((Handle >> 24) % 256);
                bytes[i++] = (byte)((Handle >> 32) % 256);
                bytes[i++] = (byte)((Handle >> 40) % 256);
                bytes[i++] = (byte)((Handle >> 48) % 256);
                bytes[i++] = (byte)((Handle >> 56) % 256);
                Array.Copy(SunAngVelocity.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(SunDirection.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SpaceLoginLocationReply</summary>
        public override PacketType Type { get { return PacketType.SpaceLoginLocationReply; } }
        /// <summary>SimulatorBlock block</summary>
        public SimulatorBlockBlock SimulatorBlock;
        /// <summary>UserBlock block</summary>
        public UserBlockBlock UserBlock;
        /// <summary>RegionInfo block</summary>
        public RegionInfoBlock RegionInfo;

        /// <summary>Default constructor</summary>
        public SpaceLoginLocationReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 401;
            Header.Reliable = true;
            Header.Zerocoded = true;
            SimulatorBlock = new SimulatorBlockBlock();
            UserBlock = new UserBlockBlock();
            RegionInfo = new RegionInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SpaceLoginLocationReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            UserBlock = new UserBlockBlock(bytes, ref i);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SpaceLoginLocationReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            UserBlock = new UserBlockBlock(bytes, ref i);
            RegionInfo = new RegionInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += SimulatorBlock.Length;            length += UserBlock.Length;            length += RegionInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimulatorBlock.ToBytes(bytes, ref i);
            UserBlock.ToBytes(bytes, ref i);
            RegionInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>NetTest packet</summary>
    public class NetTestPacket : Packet
    {
        /// <summary>NetBlock block</summary>
        public class NetBlockBlock
        {
            /// <summary>Port field</summary>
            public ushort Port;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NetBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.NetTest</summary>
        public override PacketType Type { get { return PacketType.NetTest; } }
        /// <summary>NetBlock block</summary>
        public NetBlockBlock NetBlock;

        /// <summary>Default constructor</summary>
        public NetTestPacket()
        {
            Header = new LowHeader();
            Header.ID = 402;
            Header.Reliable = true;
            NetBlock = new NetBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public NetTestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            NetBlock = new NetBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public NetTestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            NetBlock = new NetBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += NetBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            NetBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetCPURatio packet</summary>
    public class SetCPURatioPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>Ratio field</summary>
            public byte Ratio;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Ratio = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = Ratio;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetCPURatio</summary>
        public override PacketType Type { get { return PacketType.SetCPURatio; } }
        /// <summary>Data block</summary>
        public DataBlock Data;

        /// <summary>Default constructor</summary>
        public SetCPURatioPacket()
        {
            Header = new LowHeader();
            Header.ID = 403;
            Header.Reliable = true;
            Data = new DataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetCPURatioPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetCPURatioPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimCrashed packet</summary>
    public class SimCrashedPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>RegionX field</summary>
            public uint RegionX;
            /// <summary>RegionY field</summary>
            public uint RegionY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionX % 256);
                bytes[i++] = (byte)((RegionX >> 8) % 256);
                bytes[i++] = (byte)((RegionX >> 16) % 256);
                bytes[i++] = (byte)((RegionX >> 24) % 256);
                bytes[i++] = (byte)(RegionY % 256);
                bytes[i++] = (byte)((RegionY >> 8) % 256);
                bytes[i++] = (byte)((RegionY >> 16) % 256);
                bytes[i++] = (byte)((RegionY >> 24) % 256);
            }
        }

        /// <summary>Users block</summary>
        public class UsersBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UsersBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UsersBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimCrashed</summary>
        public override PacketType Type { get { return PacketType.SimCrashed; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>Users block</summary>
        public UsersBlock[] Users;

        /// <summary>Default constructor</summary>
        public SimCrashedPacket()
        {
            Header = new LowHeader();
            Header.ID = 404;
            Header.Reliable = true;
            Data = new DataBlock();
            Users = new UsersBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimCrashedPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Users = new UsersBlock[count];
            for (int j = 0; j < count; j++)
            { Users[j] = new UsersBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimCrashedPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Users = new UsersBlock[count];
            for (int j = 0; j < count; j++)
            { Users[j] = new UsersBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;;
            for (int j = 0; j < Users.Length; j++) { length += Users[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Users.Length;
            for (int j = 0; j < Users.Length; j++) { Users[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorPauseState packet</summary>
    public class SimulatorPauseStatePacket : Packet
    {
        /// <summary>PauseBlock block</summary>
        public class PauseBlockBlock
        {
            /// <summary>TasksPaused field</summary>
            public uint TasksPaused;
            /// <summary>SimPaused field</summary>
            public uint SimPaused;
            /// <summary>LayersPaused field</summary>
            public uint LayersPaused;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PauseBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PauseBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TasksPaused = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SimPaused = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LayersPaused = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TasksPaused % 256);
                bytes[i++] = (byte)((TasksPaused >> 8) % 256);
                bytes[i++] = (byte)((TasksPaused >> 16) % 256);
                bytes[i++] = (byte)((TasksPaused >> 24) % 256);
                bytes[i++] = (byte)(SimPaused % 256);
                bytes[i++] = (byte)((SimPaused >> 8) % 256);
                bytes[i++] = (byte)((SimPaused >> 16) % 256);
                bytes[i++] = (byte)((SimPaused >> 24) % 256);
                bytes[i++] = (byte)(LayersPaused % 256);
                bytes[i++] = (byte)((LayersPaused >> 8) % 256);
                bytes[i++] = (byte)((LayersPaused >> 16) % 256);
                bytes[i++] = (byte)((LayersPaused >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorPauseState</summary>
        public override PacketType Type { get { return PacketType.SimulatorPauseState; } }
        /// <summary>PauseBlock block</summary>
        public PauseBlockBlock PauseBlock;

        /// <summary>Default constructor</summary>
        public SimulatorPauseStatePacket()
        {
            Header = new LowHeader();
            Header.ID = 405;
            Header.Reliable = true;
            PauseBlock = new PauseBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorPauseStatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PauseBlock = new PauseBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorPauseStatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PauseBlock = new PauseBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PauseBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PauseBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimulatorThrottleSettings packet</summary>
    public class SimulatorThrottleSettingsPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>Throttle block</summary>
        public class ThrottleBlock
        {
            private byte[] _throttles;
            /// <summary>Throttles field</summary>
            public byte[] Throttles
            {
                get { return _throttles; }
                set
                {
                    if (value == null) { _throttles = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _throttles = new byte[value.Length]; Array.Copy(value, _throttles, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Throttles != null) { length += 1 + Throttles.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ThrottleBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ThrottleBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _throttles = new byte[length];
                    Array.Copy(bytes, i, _throttles, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Throttles.Length;
                Array.Copy(Throttles, 0, bytes, i, Throttles.Length); i += Throttles.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimulatorThrottleSettings</summary>
        public override PacketType Type { get { return PacketType.SimulatorThrottleSettings; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;
        /// <summary>Throttle block</summary>
        public ThrottleBlock Throttle;

        /// <summary>Default constructor</summary>
        public SimulatorThrottleSettingsPacket()
        {
            Header = new LowHeader();
            Header.ID = 406;
            Header.Reliable = true;
            Sender = new SenderBlock();
            Throttle = new ThrottleBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimulatorThrottleSettingsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
            Throttle = new ThrottleBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimulatorThrottleSettingsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
            Throttle = new ThrottleBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Sender.Length;            length += Throttle.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            Throttle.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>NameValuePair packet</summary>
    public class NameValuePairPacket : Packet
    {
        /// <summary>NameValueData block</summary>
        public class NameValueDataBlock
        {
            private byte[] _nvpair;
            /// <summary>NVPair field</summary>
            public byte[] NVPair
            {
                get { return _nvpair; }
                set
                {
                    if (value == null) { _nvpair = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _nvpair = new byte[value.Length]; Array.Copy(value, _nvpair, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (NVPair != null) { length += 2 + NVPair.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NameValueDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NameValueDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _nvpair = new byte[length];
                    Array.Copy(bytes, i, _nvpair, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(NVPair.Length % 256);
                bytes[i++] = (byte)((NVPair.Length >> 8) % 256);
                Array.Copy(NVPair, 0, bytes, i, NVPair.Length); i += NVPair.Length;
            }
        }

        /// <summary>TaskData block</summary>
        public class TaskDataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TaskDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TaskDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.NameValuePair</summary>
        public override PacketType Type { get { return PacketType.NameValuePair; } }
        /// <summary>NameValueData block</summary>
        public NameValueDataBlock[] NameValueData;
        /// <summary>TaskData block</summary>
        public TaskDataBlock TaskData;

        /// <summary>Default constructor</summary>
        public NameValuePairPacket()
        {
            Header = new LowHeader();
            Header.ID = 407;
            Header.Reliable = true;
            NameValueData = new NameValueDataBlock[0];
            TaskData = new TaskDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public NameValuePairPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            NameValueData = new NameValueDataBlock[count];
            for (int j = 0; j < count; j++)
            { NameValueData[j] = new NameValueDataBlock(bytes, ref i); }
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public NameValuePairPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            NameValueData = new NameValueDataBlock[count];
            for (int j = 0; j < count; j++)
            { NameValueData[j] = new NameValueDataBlock(bytes, ref i); }
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TaskData.Length;;
            for (int j = 0; j < NameValueData.Length; j++) { length += NameValueData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)NameValueData.Length;
            for (int j = 0; j < NameValueData.Length; j++) { NameValueData[j].ToBytes(bytes, ref i); }
            TaskData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveNameValuePair packet</summary>
    public class RemoveNameValuePairPacket : Packet
    {
        /// <summary>NameValueData block</summary>
        public class NameValueDataBlock
        {
            private byte[] _nvpair;
            /// <summary>NVPair field</summary>
            public byte[] NVPair
            {
                get { return _nvpair; }
                set
                {
                    if (value == null) { _nvpair = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _nvpair = new byte[value.Length]; Array.Copy(value, _nvpair, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (NVPair != null) { length += 2 + NVPair.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NameValueDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NameValueDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _nvpair = new byte[length];
                    Array.Copy(bytes, i, _nvpair, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(NVPair.Length % 256);
                bytes[i++] = (byte)((NVPair.Length >> 8) % 256);
                Array.Copy(NVPair, 0, bytes, i, NVPair.Length); i += NVPair.Length;
            }
        }

        /// <summary>TaskData block</summary>
        public class TaskDataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TaskDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TaskDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveNameValuePair</summary>
        public override PacketType Type { get { return PacketType.RemoveNameValuePair; } }
        /// <summary>NameValueData block</summary>
        public NameValueDataBlock[] NameValueData;
        /// <summary>TaskData block</summary>
        public TaskDataBlock TaskData;

        /// <summary>Default constructor</summary>
        public RemoveNameValuePairPacket()
        {
            Header = new LowHeader();
            Header.ID = 408;
            Header.Reliable = true;
            NameValueData = new NameValueDataBlock[0];
            TaskData = new TaskDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveNameValuePairPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            NameValueData = new NameValueDataBlock[count];
            for (int j = 0; j < count; j++)
            { NameValueData[j] = new NameValueDataBlock(bytes, ref i); }
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveNameValuePairPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            NameValueData = new NameValueDataBlock[count];
            for (int j = 0; j < count; j++)
            { NameValueData[j] = new NameValueDataBlock(bytes, ref i); }
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TaskData.Length;;
            for (int j = 0; j < NameValueData.Length; j++) { length += NameValueData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)NameValueData.Length;
            for (int j = 0; j < NameValueData.Length; j++) { NameValueData[j].ToBytes(bytes, ref i); }
            TaskData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GetNameValuePair packet</summary>
    public class GetNameValuePairPacket : Packet
    {
        /// <summary>NameValueName block</summary>
        public class NameValueNameBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Name != null) { length += 2 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NameValueNameBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NameValueNameBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Name.Length % 256);
                bytes[i++] = (byte)((Name.Length >> 8) % 256);
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
            }
        }

        /// <summary>TaskData block</summary>
        public class TaskDataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TaskDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TaskDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GetNameValuePair</summary>
        public override PacketType Type { get { return PacketType.GetNameValuePair; } }
        /// <summary>NameValueName block</summary>
        public NameValueNameBlock[] NameValueName;
        /// <summary>TaskData block</summary>
        public TaskDataBlock TaskData;

        /// <summary>Default constructor</summary>
        public GetNameValuePairPacket()
        {
            Header = new LowHeader();
            Header.ID = 409;
            Header.Reliable = true;
            NameValueName = new NameValueNameBlock[0];
            TaskData = new TaskDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GetNameValuePairPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            NameValueName = new NameValueNameBlock[count];
            for (int j = 0; j < count; j++)
            { NameValueName[j] = new NameValueNameBlock(bytes, ref i); }
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GetNameValuePairPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            NameValueName = new NameValueNameBlock[count];
            for (int j = 0; j < count; j++)
            { NameValueName[j] = new NameValueNameBlock(bytes, ref i); }
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TaskData.Length;;
            for (int j = 0; j < NameValueName.Length; j++) { length += NameValueName[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)NameValueName.Length;
            for (int j = 0; j < NameValueName.Length; j++) { NameValueName[j].ToBytes(bytes, ref i); }
            TaskData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateAttachment packet</summary>
    public class UpdateAttachmentPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 136;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>OperationData block</summary>
        public class OperationDataBlock
        {
            /// <summary>AddItem field</summary>
            public bool AddItem;
            /// <summary>UseExistingAsset field</summary>
            public bool UseExistingAsset;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public OperationDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public OperationDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AddItem = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    UseExistingAsset = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((AddItem) ? 1 : 0);
                bytes[i++] = (byte)((UseExistingAsset) ? 1 : 0);
            }
        }

        /// <summary>AttachmentBlock block</summary>
        public class AttachmentBlockBlock
        {
            /// <summary>AttachmentPoint field</summary>
            public byte AttachmentPoint;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AttachmentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AttachmentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AttachmentPoint = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = AttachmentPoint;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateAttachment</summary>
        public override PacketType Type { get { return PacketType.UpdateAttachment; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock InventoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>OperationData block</summary>
        public OperationDataBlock OperationData;
        /// <summary>AttachmentBlock block</summary>
        public AttachmentBlockBlock AttachmentBlock;

        /// <summary>Default constructor</summary>
        public UpdateAttachmentPacket()
        {
            Header = new LowHeader();
            Header.ID = 410;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock();
            AgentData = new AgentDataBlock();
            OperationData = new OperationDataBlock();
            AttachmentBlock = new AttachmentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateAttachmentPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            OperationData = new OperationDataBlock(bytes, ref i);
            AttachmentBlock = new AttachmentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateAttachmentPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InventoryData = new InventoryDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
            OperationData = new OperationDataBlock(bytes, ref i);
            AttachmentBlock = new AttachmentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InventoryData.Length;            length += AgentData.Length;            length += OperationData.Length;            length += AttachmentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InventoryData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            OperationData.ToBytes(bytes, ref i);
            AttachmentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RemoveAttachment packet</summary>
    public class RemoveAttachmentPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AttachmentBlock block</summary>
        public class AttachmentBlockBlock
        {
            /// <summary>AttachmentPoint field</summary>
            public byte AttachmentPoint;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AttachmentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AttachmentBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AttachmentPoint = (byte)bytes[i++];
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = AttachmentPoint;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RemoveAttachment</summary>
        public override PacketType Type { get { return PacketType.RemoveAttachment; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>AttachmentBlock block</summary>
        public AttachmentBlockBlock AttachmentBlock;

        /// <summary>Default constructor</summary>
        public RemoveAttachmentPacket()
        {
            Header = new LowHeader();
            Header.ID = 411;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            AttachmentBlock = new AttachmentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RemoveAttachmentPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            AttachmentBlock = new AttachmentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RemoveAttachmentPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            AttachmentBlock = new AttachmentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += AttachmentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            AttachmentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AssetUploadRequest packet</summary>
    public class AssetUploadRequestPacket : Packet
    {
        /// <summary>AssetBlock block</summary>
        public class AssetBlockBlock
        {
            /// <summary>UUID field</summary>
            public LLUUID UUID;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>Tempfile field</summary>
            public bool Tempfile;
            private byte[] _assetdata;
            /// <summary>AssetData field</summary>
            public byte[] AssetData
            {
                get { return _assetdata; }
                set
                {
                    if (value == null) { _assetdata = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _assetdata = new byte[value.Length]; Array.Copy(value, _assetdata, value.Length); }
                }
            }
            /// <summary>StoreLocal field</summary>
            public bool StoreLocal;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 19;
                    if (AssetData != null) { length += 2 + AssetData.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AssetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AssetBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    UUID = new LLUUID(bytes, i); i += 16;
                    Type = (sbyte)bytes[i++];
                    Tempfile = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _assetdata = new byte[length];
                    Array.Copy(bytes, i, _assetdata, 0, length); i += length;
                    StoreLocal = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(UUID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Type;
                bytes[i++] = (byte)((Tempfile) ? 1 : 0);
                bytes[i++] = (byte)(AssetData.Length % 256);
                bytes[i++] = (byte)((AssetData.Length >> 8) % 256);
                Array.Copy(AssetData, 0, bytes, i, AssetData.Length); i += AssetData.Length;
                bytes[i++] = (byte)((StoreLocal) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AssetUploadRequest</summary>
        public override PacketType Type { get { return PacketType.AssetUploadRequest; } }
        /// <summary>AssetBlock block</summary>
        public AssetBlockBlock AssetBlock;

        /// <summary>Default constructor</summary>
        public AssetUploadRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 412;
            Header.Reliable = true;
            AssetBlock = new AssetBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AssetUploadRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AssetBlock = new AssetBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AssetUploadRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AssetBlock = new AssetBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AssetBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AssetBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AssetUploadComplete packet</summary>
    public class AssetUploadCompletePacket : Packet
    {
        /// <summary>AssetBlock block</summary>
        public class AssetBlockBlock
        {
            /// <summary>UUID field</summary>
            public LLUUID UUID;
            /// <summary>Success field</summary>
            public bool Success;
            /// <summary>Type field</summary>
            public sbyte Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AssetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AssetBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    UUID = new LLUUID(bytes, i); i += 16;
                    Success = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Type = (sbyte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(UUID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Success) ? 1 : 0);
                bytes[i++] = (byte)Type;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AssetUploadComplete</summary>
        public override PacketType Type { get { return PacketType.AssetUploadComplete; } }
        /// <summary>AssetBlock block</summary>
        public AssetBlockBlock AssetBlock;

        /// <summary>Default constructor</summary>
        public AssetUploadCompletePacket()
        {
            Header = new LowHeader();
            Header.ID = 413;
            Header.Reliable = true;
            AssetBlock = new AssetBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AssetUploadCompletePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AssetBlock = new AssetBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AssetUploadCompletePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AssetBlock = new AssetBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AssetBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AssetBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ReputationAgentAssign packet</summary>
    public class ReputationAgentAssignPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>RateeID field</summary>
            public LLUUID RateeID;
            /// <summary>RatorID field</summary>
            public LLUUID RatorID;
            /// <summary>Appearance field</summary>
            public float Appearance;
            /// <summary>Behavior field</summary>
            public float Behavior;
            /// <summary>Building field</summary>
            public float Building;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RateeID = new LLUUID(bytes, i); i += 16;
                    RatorID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Appearance = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Behavior = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Building = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(RateeID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Appearance);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(Behavior);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(Building);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ReputationAgentAssign</summary>
        public override PacketType Type { get { return PacketType.ReputationAgentAssign; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public ReputationAgentAssignPacket()
        {
            Header = new LowHeader();
            Header.ID = 414;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ReputationAgentAssignPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ReputationAgentAssignPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ReputationIndividualRequest packet</summary>
    public class ReputationIndividualRequestPacket : Packet
    {
        /// <summary>ReputationData block</summary>
        public class ReputationDataBlock
        {
            /// <summary>ToID field</summary>
            public LLUUID ToID;
            /// <summary>FromID field</summary>
            public LLUUID FromID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReputationDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReputationDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ToID = new LLUUID(bytes, i); i += 16;
                    FromID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ToID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FromID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ReputationIndividualRequest</summary>
        public override PacketType Type { get { return PacketType.ReputationIndividualRequest; } }
        /// <summary>ReputationData block</summary>
        public ReputationDataBlock ReputationData;

        /// <summary>Default constructor</summary>
        public ReputationIndividualRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 415;
            Header.Reliable = true;
            ReputationData = new ReputationDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ReputationIndividualRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ReputationData = new ReputationDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ReputationIndividualRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ReputationData = new ReputationDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ReputationData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ReputationData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ReputationIndividualReply packet</summary>
    public class ReputationIndividualReplyPacket : Packet
    {
        /// <summary>ReputationData block</summary>
        public class ReputationDataBlock
        {
            /// <summary>Appearance field</summary>
            public float Appearance;
            /// <summary>ToID field</summary>
            public LLUUID ToID;
            /// <summary>Behavior field</summary>
            public float Behavior;
            /// <summary>FromID field</summary>
            public LLUUID FromID;
            /// <summary>Building field</summary>
            public float Building;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReputationDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReputationDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Appearance = BitConverter.ToSingle(bytes, i); i += 4;
                    ToID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Behavior = BitConverter.ToSingle(bytes, i); i += 4;
                    FromID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Building = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Appearance);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(ToID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Behavior);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(FromID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Building);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ReputationIndividualReply</summary>
        public override PacketType Type { get { return PacketType.ReputationIndividualReply; } }
        /// <summary>ReputationData block</summary>
        public ReputationDataBlock ReputationData;

        /// <summary>Default constructor</summary>
        public ReputationIndividualReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 416;
            Header.Reliable = true;
            ReputationData = new ReputationDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ReputationIndividualReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ReputationData = new ReputationDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ReputationIndividualReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ReputationData = new ReputationDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ReputationData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ReputationData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EmailMessageRequest packet</summary>
    public class EmailMessageRequestPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _subject;
            /// <summary>Subject field</summary>
            public byte[] Subject
            {
                get { return _subject; }
                set
                {
                    if (value == null) { _subject = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _subject = new byte[value.Length]; Array.Copy(value, _subject, value.Length); }
                }
            }
            private byte[] _fromaddress;
            /// <summary>FromAddress field</summary>
            public byte[] FromAddress
            {
                get { return _fromaddress; }
                set
                {
                    if (value == null) { _fromaddress = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _fromaddress = new byte[value.Length]; Array.Copy(value, _fromaddress, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Subject != null) { length += 1 + Subject.Length; }
                    if (FromAddress != null) { length += 1 + FromAddress.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _subject = new byte[length];
                    Array.Copy(bytes, i, _subject, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _fromaddress = new byte[length];
                    Array.Copy(bytes, i, _fromaddress, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Subject.Length;
                Array.Copy(Subject, 0, bytes, i, Subject.Length); i += Subject.Length;
                bytes[i++] = (byte)FromAddress.Length;
                Array.Copy(FromAddress, 0, bytes, i, FromAddress.Length); i += FromAddress.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EmailMessageRequest</summary>
        public override PacketType Type { get { return PacketType.EmailMessageRequest; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public EmailMessageRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 417;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EmailMessageRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EmailMessageRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EmailMessageReply packet</summary>
    public class EmailMessageReplyPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }
            private byte[] _subject;
            /// <summary>Subject field</summary>
            public byte[] Subject
            {
                get { return _subject; }
                set
                {
                    if (value == null) { _subject = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _subject = new byte[value.Length]; Array.Copy(value, _subject, value.Length); }
                }
            }
            /// <summary>Time field</summary>
            public uint Time;
            private byte[] _fromaddress;
            /// <summary>FromAddress field</summary>
            public byte[] FromAddress
            {
                get { return _fromaddress; }
                set
                {
                    if (value == null) { _fromaddress = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _fromaddress = new byte[value.Length]; Array.Copy(value, _fromaddress, value.Length); }
                }
            }
            /// <summary>More field</summary>
            public uint More;
            private byte[] _mailfilter;
            /// <summary>MailFilter field</summary>
            public byte[] MailFilter
            {
                get { return _mailfilter; }
                set
                {
                    if (value == null) { _mailfilter = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mailfilter = new byte[value.Length]; Array.Copy(value, _mailfilter, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (Data != null) { length += 2 + Data.Length; }
                    if (Subject != null) { length += 1 + Subject.Length; }
                    if (FromAddress != null) { length += 1 + FromAddress.Length; }
                    if (MailFilter != null) { length += 1 + MailFilter.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _subject = new byte[length];
                    Array.Copy(bytes, i, _subject, 0, length); i += length;
                    Time = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _fromaddress = new byte[length];
                    Array.Copy(bytes, i, _fromaddress, 0, length); i += length;
                    More = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _mailfilter = new byte[length];
                    Array.Copy(bytes, i, _mailfilter, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
                bytes[i++] = (byte)Subject.Length;
                Array.Copy(Subject, 0, bytes, i, Subject.Length); i += Subject.Length;
                bytes[i++] = (byte)(Time % 256);
                bytes[i++] = (byte)((Time >> 8) % 256);
                bytes[i++] = (byte)((Time >> 16) % 256);
                bytes[i++] = (byte)((Time >> 24) % 256);
                bytes[i++] = (byte)FromAddress.Length;
                Array.Copy(FromAddress, 0, bytes, i, FromAddress.Length); i += FromAddress.Length;
                bytes[i++] = (byte)(More % 256);
                bytes[i++] = (byte)((More >> 8) % 256);
                bytes[i++] = (byte)((More >> 16) % 256);
                bytes[i++] = (byte)((More >> 24) % 256);
                bytes[i++] = (byte)MailFilter.Length;
                Array.Copy(MailFilter, 0, bytes, i, MailFilter.Length); i += MailFilter.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EmailMessageReply</summary>
        public override PacketType Type { get { return PacketType.EmailMessageReply; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public EmailMessageReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 418;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EmailMessageReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EmailMessageReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptDataRequest packet</summary>
    public class ScriptDataRequestPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>RequestType field</summary>
            public sbyte RequestType;
            private byte[] _request;
            /// <summary>Request field</summary>
            public byte[] Request
            {
                get { return _request; }
                set
                {
                    if (value == null) { _request = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _request = new byte[value.Length]; Array.Copy(value, _request, value.Length); }
                }
            }
            /// <summary>Hash field</summary>
            public ulong Hash;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 10;
                    if (Request != null) { length += 2 + Request.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RequestType = (sbyte)bytes[i++];
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _request = new byte[length];
                    Array.Copy(bytes, i, _request, 0, length); i += length;
                    Hash = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)RequestType;
                bytes[i++] = (byte)(Request.Length % 256);
                bytes[i++] = (byte)((Request.Length >> 8) % 256);
                Array.Copy(Request, 0, bytes, i, Request.Length); i += Request.Length;
                bytes[i++] = (byte)(Hash % 256);
                bytes[i++] = (byte)((Hash >> 8) % 256);
                bytes[i++] = (byte)((Hash >> 16) % 256);
                bytes[i++] = (byte)((Hash >> 24) % 256);
                bytes[i++] = (byte)((Hash >> 32) % 256);
                bytes[i++] = (byte)((Hash >> 40) % 256);
                bytes[i++] = (byte)((Hash >> 48) % 256);
                bytes[i++] = (byte)((Hash >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptDataRequest</summary>
        public override PacketType Type { get { return PacketType.ScriptDataRequest; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock[] DataBlock;

        /// <summary>Default constructor</summary>
        public ScriptDataRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 419;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptDataRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptDataRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < DataBlock.Length; j++) { length += DataBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)DataBlock.Length;
            for (int j = 0; j < DataBlock.Length; j++) { DataBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptDataReply packet</summary>
    public class ScriptDataReplyPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>Hash field</summary>
            public ulong Hash;
            private byte[] _reply;
            /// <summary>Reply field</summary>
            public byte[] Reply
            {
                get { return _reply; }
                set
                {
                    if (value == null) { _reply = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _reply = new byte[value.Length]; Array.Copy(value, _reply, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    if (Reply != null) { length += 2 + Reply.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Hash = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _reply = new byte[length];
                    Array.Copy(bytes, i, _reply, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Hash % 256);
                bytes[i++] = (byte)((Hash >> 8) % 256);
                bytes[i++] = (byte)((Hash >> 16) % 256);
                bytes[i++] = (byte)((Hash >> 24) % 256);
                bytes[i++] = (byte)((Hash >> 32) % 256);
                bytes[i++] = (byte)((Hash >> 40) % 256);
                bytes[i++] = (byte)((Hash >> 48) % 256);
                bytes[i++] = (byte)((Hash >> 56) % 256);
                bytes[i++] = (byte)(Reply.Length % 256);
                bytes[i++] = (byte)((Reply.Length >> 8) % 256);
                Array.Copy(Reply, 0, bytes, i, Reply.Length); i += Reply.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptDataReply</summary>
        public override PacketType Type { get { return PacketType.ScriptDataReply; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock[] DataBlock;

        /// <summary>Default constructor</summary>
        public ScriptDataReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 420;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptDataReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptDataReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < DataBlock.Length; j++) { length += DataBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)DataBlock.Length;
            for (int j = 0; j < DataBlock.Length; j++) { DataBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CreateGroupRequest packet</summary>
    public class CreateGroupRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>AllowPublish field</summary>
            public bool AllowPublish;
            private byte[] _charter;
            /// <summary>Charter field</summary>
            public byte[] Charter
            {
                get { return _charter; }
                set
                {
                    if (value == null) { _charter = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _charter = new byte[value.Length]; Array.Copy(value, _charter, value.Length); }
                }
            }
            /// <summary>ShowInList field</summary>
            public bool ShowInList;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InsigniaID field</summary>
            public LLUUID InsigniaID;
            /// <summary>MembershipFee field</summary>
            public int MembershipFee;
            /// <summary>MaturePublish field</summary>
            public bool MaturePublish;
            /// <summary>OpenEnrollment field</summary>
            public bool OpenEnrollment;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (Charter != null) { length += 2 + Charter.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AllowPublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _charter = new byte[length];
                    Array.Copy(bytes, i, _charter, 0, length); i += length;
                    ShowInList = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InsigniaID = new LLUUID(bytes, i); i += 16;
                    MembershipFee = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MaturePublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    OpenEnrollment = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((AllowPublish) ? 1 : 0);
                bytes[i++] = (byte)(Charter.Length % 256);
                bytes[i++] = (byte)((Charter.Length >> 8) % 256);
                Array.Copy(Charter, 0, bytes, i, Charter.Length); i += Charter.Length;
                bytes[i++] = (byte)((ShowInList) ? 1 : 0);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(InsigniaID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MembershipFee % 256);
                bytes[i++] = (byte)((MembershipFee >> 8) % 256);
                bytes[i++] = (byte)((MembershipFee >> 16) % 256);
                bytes[i++] = (byte)((MembershipFee >> 24) % 256);
                bytes[i++] = (byte)((MaturePublish) ? 1 : 0);
                bytes[i++] = (byte)((OpenEnrollment) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CreateGroupRequest</summary>
        public override PacketType Type { get { return PacketType.CreateGroupRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public CreateGroupRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 421;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CreateGroupRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CreateGroupRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CreateGroupReply packet</summary>
    public class CreateGroupReplyPacket : Packet
    {
        /// <summary>ReplyData block</summary>
        public class ReplyDataBlock
        {
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>Success field</summary>
            public bool Success;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (Message != null) { length += 1 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReplyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReplyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    Success = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Message.Length;
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                bytes[i++] = (byte)((Success) ? 1 : 0);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CreateGroupReply</summary>
        public override PacketType Type { get { return PacketType.CreateGroupReply; } }
        /// <summary>ReplyData block</summary>
        public ReplyDataBlock ReplyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public CreateGroupReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 422;
            Header.Reliable = true;
            ReplyData = new ReplyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CreateGroupReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ReplyData = new ReplyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CreateGroupReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ReplyData = new ReplyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ReplyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ReplyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateGroupInfo packet</summary>
    public class UpdateGroupInfoPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>AllowPublish field</summary>
            public bool AllowPublish;
            private byte[] _charter;
            /// <summary>Charter field</summary>
            public byte[] Charter
            {
                get { return _charter; }
                set
                {
                    if (value == null) { _charter = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _charter = new byte[value.Length]; Array.Copy(value, _charter, value.Length); }
                }
            }
            /// <summary>ShowInList field</summary>
            public bool ShowInList;
            /// <summary>InsigniaID field</summary>
            public LLUUID InsigniaID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>MembershipFee field</summary>
            public int MembershipFee;
            /// <summary>MaturePublish field</summary>
            public bool MaturePublish;
            /// <summary>OpenEnrollment field</summary>
            public bool OpenEnrollment;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 40;
                    if (Charter != null) { length += 2 + Charter.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AllowPublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _charter = new byte[length];
                    Array.Copy(bytes, i, _charter, 0, length); i += length;
                    ShowInList = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    InsigniaID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    MembershipFee = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MaturePublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    OpenEnrollment = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((AllowPublish) ? 1 : 0);
                bytes[i++] = (byte)(Charter.Length % 256);
                bytes[i++] = (byte)((Charter.Length >> 8) % 256);
                Array.Copy(Charter, 0, bytes, i, Charter.Length); i += Charter.Length;
                bytes[i++] = (byte)((ShowInList) ? 1 : 0);
                Array.Copy(InsigniaID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MembershipFee % 256);
                bytes[i++] = (byte)((MembershipFee >> 8) % 256);
                bytes[i++] = (byte)((MembershipFee >> 16) % 256);
                bytes[i++] = (byte)((MembershipFee >> 24) % 256);
                bytes[i++] = (byte)((MaturePublish) ? 1 : 0);
                bytes[i++] = (byte)((OpenEnrollment) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateGroupInfo</summary>
        public override PacketType Type { get { return PacketType.UpdateGroupInfo; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public UpdateGroupInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 423;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateGroupInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateGroupInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupRoleChanges packet</summary>
    public class GroupRoleChangesPacket : Packet
    {
        /// <summary>RoleChange block</summary>
        public class RoleChangeBlock
        {
            /// <summary>MemberID field</summary>
            public LLUUID MemberID;
            /// <summary>Change field</summary>
            public uint Change;
            /// <summary>RoleID field</summary>
            public LLUUID RoleID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 37;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RoleChangeBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RoleChangeBlock(byte[] bytes, ref int i)
            {
                try
                {
                    MemberID = new LLUUID(bytes, i); i += 16;
                    Change = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RoleID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(MemberID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Change % 256);
                bytes[i++] = (byte)((Change >> 8) % 256);
                bytes[i++] = (byte)((Change >> 16) % 256);
                bytes[i++] = (byte)((Change >> 24) % 256);
                Array.Copy(RoleID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupRoleChanges</summary>
        public override PacketType Type { get { return PacketType.GroupRoleChanges; } }
        /// <summary>RoleChange block</summary>
        public RoleChangeBlock[] RoleChange;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupRoleChangesPacket()
        {
            Header = new LowHeader();
            Header.ID = 424;
            Header.Reliable = true;
            RoleChange = new RoleChangeBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupRoleChangesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RoleChange = new RoleChangeBlock[count];
            for (int j = 0; j < count; j++)
            { RoleChange[j] = new RoleChangeBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupRoleChangesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RoleChange = new RoleChangeBlock[count];
            for (int j = 0; j < count; j++)
            { RoleChange[j] = new RoleChangeBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < RoleChange.Length; j++) { length += RoleChange[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RoleChange.Length;
            for (int j = 0; j < RoleChange.Length; j++) { RoleChange[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>JoinGroupRequest packet</summary>
    public class JoinGroupRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.JoinGroupRequest</summary>
        public override PacketType Type { get { return PacketType.JoinGroupRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public JoinGroupRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 425;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public JoinGroupRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public JoinGroupRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>JoinGroupReply packet</summary>
    public class JoinGroupReplyPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>Success field</summary>
            public bool Success;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Success = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Success) ? 1 : 0);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.JoinGroupReply</summary>
        public override PacketType Type { get { return PacketType.JoinGroupReply; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public JoinGroupReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 426;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public JoinGroupReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public JoinGroupReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EjectGroupMemberRequest packet</summary>
    public class EjectGroupMemberRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>EjectData block</summary>
        public class EjectDataBlock
        {
            /// <summary>EjecteeID field</summary>
            public LLUUID EjecteeID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EjecteeID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(EjecteeID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EjectGroupMemberRequest</summary>
        public override PacketType Type { get { return PacketType.EjectGroupMemberRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>EjectData block</summary>
        public EjectDataBlock[] EjectData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public EjectGroupMemberRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 427;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            EjectData = new EjectDataBlock[0];
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EjectGroupMemberRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            EjectData = new EjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { EjectData[j] = new EjectDataBlock(bytes, ref i); }
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EjectGroupMemberRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            EjectData = new EjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { EjectData[j] = new EjectDataBlock(bytes, ref i); }
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            for (int j = 0; j < EjectData.Length; j++) { length += EjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)EjectData.Length;
            for (int j = 0; j < EjectData.Length; j++) { EjectData[j].ToBytes(bytes, ref i); }
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EjectGroupMemberReply packet</summary>
    public class EjectGroupMemberReplyPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>EjectData block</summary>
        public class EjectDataBlock
        {
            /// <summary>Success field</summary>
            public bool Success;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Success = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Success) ? 1 : 0);
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EjectGroupMemberReply</summary>
        public override PacketType Type { get { return PacketType.EjectGroupMemberReply; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>EjectData block</summary>
        public EjectDataBlock EjectData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public EjectGroupMemberReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 428;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            EjectData = new EjectDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EjectGroupMemberReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            EjectData = new EjectDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EjectGroupMemberReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            EjectData = new EjectDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += EjectData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            EjectData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LeaveGroupRequest packet</summary>
    public class LeaveGroupRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LeaveGroupRequest</summary>
        public override PacketType Type { get { return PacketType.LeaveGroupRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public LeaveGroupRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 429;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LeaveGroupRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LeaveGroupRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LeaveGroupReply packet</summary>
    public class LeaveGroupReplyPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>Success field</summary>
            public bool Success;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Success = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Success) ? 1 : 0);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LeaveGroupReply</summary>
        public override PacketType Type { get { return PacketType.LeaveGroupReply; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public LeaveGroupReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 430;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LeaveGroupReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LeaveGroupReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InviteGroupRequest packet</summary>
    public class InviteGroupRequestPacket : Packet
    {
        /// <summary>InviteData block</summary>
        public class InviteDataBlock
        {
            /// <summary>RoleID field</summary>
            public LLUUID RoleID;
            /// <summary>InviteeID field</summary>
            public LLUUID InviteeID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InviteDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InviteDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RoleID = new LLUUID(bytes, i); i += 16;
                    InviteeID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RoleID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(InviteeID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InviteGroupRequest</summary>
        public override PacketType Type { get { return PacketType.InviteGroupRequest; } }
        /// <summary>InviteData block</summary>
        public InviteDataBlock[] InviteData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public InviteGroupRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 431;
            Header.Reliable = true;
            InviteData = new InviteDataBlock[0];
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InviteGroupRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InviteData = new InviteDataBlock[count];
            for (int j = 0; j < count; j++)
            { InviteData[j] = new InviteDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InviteGroupRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InviteData = new InviteDataBlock[count];
            for (int j = 0; j < count; j++)
            { InviteData[j] = new InviteDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            for (int j = 0; j < InviteData.Length; j++) { length += InviteData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InviteData.Length;
            for (int j = 0; j < InviteData.Length; j++) { InviteData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InviteGroupResponse packet</summary>
    public class InviteGroupResponsePacket : Packet
    {
        /// <summary>InviteData block</summary>
        public class InviteDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>MembershipFee field</summary>
            public int MembershipFee;
            /// <summary>RoleID field</summary>
            public LLUUID RoleID;
            /// <summary>InviteeID field</summary>
            public LLUUID InviteeID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 68;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InviteDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InviteDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    MembershipFee = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RoleID = new LLUUID(bytes, i); i += 16;
                    InviteeID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MembershipFee % 256);
                bytes[i++] = (byte)((MembershipFee >> 8) % 256);
                bytes[i++] = (byte)((MembershipFee >> 16) % 256);
                bytes[i++] = (byte)((MembershipFee >> 24) % 256);
                Array.Copy(RoleID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(InviteeID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InviteGroupResponse</summary>
        public override PacketType Type { get { return PacketType.InviteGroupResponse; } }
        /// <summary>InviteData block</summary>
        public InviteDataBlock InviteData;

        /// <summary>Default constructor</summary>
        public InviteGroupResponsePacket()
        {
            Header = new LowHeader();
            Header.ID = 432;
            Header.Reliable = true;
            InviteData = new InviteDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InviteGroupResponsePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            InviteData = new InviteDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InviteGroupResponsePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            InviteData = new InviteDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += InviteData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            InviteData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupProfileRequest packet</summary>
    public class GroupProfileRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupProfileRequest</summary>
        public override PacketType Type { get { return PacketType.GroupProfileRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupProfileRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 433;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupProfileRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupProfileRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupProfileReply packet</summary>
    public class GroupProfileReplyPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>OwnerRole field</summary>
            public LLUUID OwnerRole;
            /// <summary>AllowPublish field</summary>
            public bool AllowPublish;
            private byte[] _charter;
            /// <summary>Charter field</summary>
            public byte[] Charter
            {
                get { return _charter; }
                set
                {
                    if (value == null) { _charter = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _charter = new byte[value.Length]; Array.Copy(value, _charter, value.Length); }
                }
            }
            /// <summary>GroupMembershipCount field</summary>
            public int GroupMembershipCount;
            /// <summary>ShowInList field</summary>
            public bool ShowInList;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _membertitle;
            /// <summary>MemberTitle field</summary>
            public byte[] MemberTitle
            {
                get { return _membertitle; }
                set
                {
                    if (value == null) { _membertitle = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _membertitle = new byte[value.Length]; Array.Copy(value, _membertitle, value.Length); }
                }
            }
            /// <summary>InsigniaID field</summary>
            public LLUUID InsigniaID;
            /// <summary>GroupRolesCount field</summary>
            public int GroupRolesCount;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>MembershipFee field</summary>
            public int MembershipFee;
            /// <summary>MaturePublish field</summary>
            public bool MaturePublish;
            /// <summary>PowersMask field</summary>
            public ulong PowersMask;
            /// <summary>Money field</summary>
            public int Money;
            /// <summary>FounderID field</summary>
            public LLUUID FounderID;
            /// <summary>OpenEnrollment field</summary>
            public bool OpenEnrollment;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 92;
                    if (Charter != null) { length += 2 + Charter.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (MemberTitle != null) { length += 1 + MemberTitle.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    OwnerRole = new LLUUID(bytes, i); i += 16;
                    AllowPublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _charter = new byte[length];
                    Array.Copy(bytes, i, _charter, 0, length); i += length;
                    GroupMembershipCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ShowInList = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _membertitle = new byte[length];
                    Array.Copy(bytes, i, _membertitle, 0, length); i += length;
                    InsigniaID = new LLUUID(bytes, i); i += 16;
                    GroupRolesCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    MembershipFee = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MaturePublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    PowersMask = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Money = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    FounderID = new LLUUID(bytes, i); i += 16;
                    OpenEnrollment = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(OwnerRole.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AllowPublish) ? 1 : 0);
                bytes[i++] = (byte)(Charter.Length % 256);
                bytes[i++] = (byte)((Charter.Length >> 8) % 256);
                Array.Copy(Charter, 0, bytes, i, Charter.Length); i += Charter.Length;
                bytes[i++] = (byte)(GroupMembershipCount % 256);
                bytes[i++] = (byte)((GroupMembershipCount >> 8) % 256);
                bytes[i++] = (byte)((GroupMembershipCount >> 16) % 256);
                bytes[i++] = (byte)((GroupMembershipCount >> 24) % 256);
                bytes[i++] = (byte)((ShowInList) ? 1 : 0);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)MemberTitle.Length;
                Array.Copy(MemberTitle, 0, bytes, i, MemberTitle.Length); i += MemberTitle.Length;
                Array.Copy(InsigniaID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(GroupRolesCount % 256);
                bytes[i++] = (byte)((GroupRolesCount >> 8) % 256);
                bytes[i++] = (byte)((GroupRolesCount >> 16) % 256);
                bytes[i++] = (byte)((GroupRolesCount >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MembershipFee % 256);
                bytes[i++] = (byte)((MembershipFee >> 8) % 256);
                bytes[i++] = (byte)((MembershipFee >> 16) % 256);
                bytes[i++] = (byte)((MembershipFee >> 24) % 256);
                bytes[i++] = (byte)((MaturePublish) ? 1 : 0);
                bytes[i++] = (byte)(PowersMask % 256);
                bytes[i++] = (byte)((PowersMask >> 8) % 256);
                bytes[i++] = (byte)((PowersMask >> 16) % 256);
                bytes[i++] = (byte)((PowersMask >> 24) % 256);
                bytes[i++] = (byte)((PowersMask >> 32) % 256);
                bytes[i++] = (byte)((PowersMask >> 40) % 256);
                bytes[i++] = (byte)((PowersMask >> 48) % 256);
                bytes[i++] = (byte)((PowersMask >> 56) % 256);
                bytes[i++] = (byte)(Money % 256);
                bytes[i++] = (byte)((Money >> 8) % 256);
                bytes[i++] = (byte)((Money >> 16) % 256);
                bytes[i++] = (byte)((Money >> 24) % 256);
                Array.Copy(FounderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((OpenEnrollment) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupProfileReply</summary>
        public override PacketType Type { get { return PacketType.GroupProfileReply; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupProfileReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 434;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupProfileReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupProfileReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupAccountSummaryRequest packet</summary>
    public class GroupAccountSummaryRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupAccountSummaryRequest</summary>
        public override PacketType Type { get { return PacketType.GroupAccountSummaryRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupAccountSummaryRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 435;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupAccountSummaryRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupAccountSummaryRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupAccountSummaryReply packet</summary>
    public class GroupAccountSummaryReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>ParcelDirFeeCurrent field</summary>
            public int ParcelDirFeeCurrent;
            private byte[] _taxdate;
            /// <summary>TaxDate field</summary>
            public byte[] TaxDate
            {
                get { return _taxdate; }
                set
                {
                    if (value == null) { _taxdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _taxdate = new byte[value.Length]; Array.Copy(value, _taxdate, value.Length); }
                }
            }
            /// <summary>Balance field</summary>
            public int Balance;
            /// <summary>ParcelDirFeeEstimate field</summary>
            public int ParcelDirFeeEstimate;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>ObjectTaxCurrent field</summary>
            public int ObjectTaxCurrent;
            /// <summary>LightTaxCurrent field</summary>
            public int LightTaxCurrent;
            /// <summary>LandTaxCurrent field</summary>
            public int LandTaxCurrent;
            /// <summary>GroupTaxCurrent field</summary>
            public int GroupTaxCurrent;
            /// <summary>TotalDebits field</summary>
            public int TotalDebits;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>ObjectTaxEstimate field</summary>
            public int ObjectTaxEstimate;
            /// <summary>LightTaxEstimate field</summary>
            public int LightTaxEstimate;
            /// <summary>LandTaxEstimate field</summary>
            public int LandTaxEstimate;
            /// <summary>GroupTaxEstimate field</summary>
            public int GroupTaxEstimate;
            private byte[] _lasttaxdate;
            /// <summary>LastTaxDate field</summary>
            public byte[] LastTaxDate
            {
                get { return _lasttaxdate; }
                set
                {
                    if (value == null) { _lasttaxdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lasttaxdate = new byte[value.Length]; Array.Copy(value, _lasttaxdate, value.Length); }
                }
            }
            /// <summary>NonExemptMembers field</summary>
            public int NonExemptMembers;
            private byte[] _startdate;
            /// <summary>StartDate field</summary>
            public byte[] StartDate
            {
                get { return _startdate; }
                set
                {
                    if (value == null) { _startdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdate = new byte[value.Length]; Array.Copy(value, _startdate, value.Length); }
                }
            }
            /// <summary>TotalCredits field</summary>
            public int TotalCredits;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 80;
                    if (TaxDate != null) { length += 1 + TaxDate.Length; }
                    if (LastTaxDate != null) { length += 1 + LastTaxDate.Length; }
                    if (StartDate != null) { length += 1 + StartDate.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ParcelDirFeeCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _taxdate = new byte[length];
                    Array.Copy(bytes, i, _taxdate, 0, length); i += length;
                    Balance = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParcelDirFeeEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RequestID = new LLUUID(bytes, i); i += 16;
                    ObjectTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LightTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LandTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupTaxCurrent = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TotalDebits = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ObjectTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LightTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    LandTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupTaxEstimate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _lasttaxdate = new byte[length];
                    Array.Copy(bytes, i, _lasttaxdate, 0, length); i += length;
                    NonExemptMembers = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _startdate = new byte[length];
                    Array.Copy(bytes, i, _startdate, 0, length); i += length;
                    TotalCredits = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ParcelDirFeeCurrent % 256);
                bytes[i++] = (byte)((ParcelDirFeeCurrent >> 8) % 256);
                bytes[i++] = (byte)((ParcelDirFeeCurrent >> 16) % 256);
                bytes[i++] = (byte)((ParcelDirFeeCurrent >> 24) % 256);
                bytes[i++] = (byte)TaxDate.Length;
                Array.Copy(TaxDate, 0, bytes, i, TaxDate.Length); i += TaxDate.Length;
                bytes[i++] = (byte)(Balance % 256);
                bytes[i++] = (byte)((Balance >> 8) % 256);
                bytes[i++] = (byte)((Balance >> 16) % 256);
                bytes[i++] = (byte)((Balance >> 24) % 256);
                bytes[i++] = (byte)(ParcelDirFeeEstimate % 256);
                bytes[i++] = (byte)((ParcelDirFeeEstimate >> 8) % 256);
                bytes[i++] = (byte)((ParcelDirFeeEstimate >> 16) % 256);
                bytes[i++] = (byte)((ParcelDirFeeEstimate >> 24) % 256);
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ObjectTaxCurrent % 256);
                bytes[i++] = (byte)((ObjectTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((ObjectTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((ObjectTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(LightTaxCurrent % 256);
                bytes[i++] = (byte)((LightTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((LightTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((LightTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(LandTaxCurrent % 256);
                bytes[i++] = (byte)((LandTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((LandTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((LandTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(GroupTaxCurrent % 256);
                bytes[i++] = (byte)((GroupTaxCurrent >> 8) % 256);
                bytes[i++] = (byte)((GroupTaxCurrent >> 16) % 256);
                bytes[i++] = (byte)((GroupTaxCurrent >> 24) % 256);
                bytes[i++] = (byte)(TotalDebits % 256);
                bytes[i++] = (byte)((TotalDebits >> 8) % 256);
                bytes[i++] = (byte)((TotalDebits >> 16) % 256);
                bytes[i++] = (byte)((TotalDebits >> 24) % 256);
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(ObjectTaxEstimate % 256);
                bytes[i++] = (byte)((ObjectTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((ObjectTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((ObjectTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)(LightTaxEstimate % 256);
                bytes[i++] = (byte)((LightTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((LightTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((LightTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)(LandTaxEstimate % 256);
                bytes[i++] = (byte)((LandTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((LandTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((LandTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)(GroupTaxEstimate % 256);
                bytes[i++] = (byte)((GroupTaxEstimate >> 8) % 256);
                bytes[i++] = (byte)((GroupTaxEstimate >> 16) % 256);
                bytes[i++] = (byte)((GroupTaxEstimate >> 24) % 256);
                bytes[i++] = (byte)LastTaxDate.Length;
                Array.Copy(LastTaxDate, 0, bytes, i, LastTaxDate.Length); i += LastTaxDate.Length;
                bytes[i++] = (byte)(NonExemptMembers % 256);
                bytes[i++] = (byte)((NonExemptMembers >> 8) % 256);
                bytes[i++] = (byte)((NonExemptMembers >> 16) % 256);
                bytes[i++] = (byte)((NonExemptMembers >> 24) % 256);
                bytes[i++] = (byte)StartDate.Length;
                Array.Copy(StartDate, 0, bytes, i, StartDate.Length); i += StartDate.Length;
                bytes[i++] = (byte)(TotalCredits % 256);
                bytes[i++] = (byte)((TotalCredits >> 8) % 256);
                bytes[i++] = (byte)((TotalCredits >> 16) % 256);
                bytes[i++] = (byte)((TotalCredits >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupAccountSummaryReply</summary>
        public override PacketType Type { get { return PacketType.GroupAccountSummaryReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupAccountSummaryReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 436;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupAccountSummaryReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupAccountSummaryReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupAccountDetailsRequest packet</summary>
    public class GroupAccountDetailsRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupAccountDetailsRequest</summary>
        public override PacketType Type { get { return PacketType.GroupAccountDetailsRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupAccountDetailsRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 437;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupAccountDetailsRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupAccountDetailsRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupAccountDetailsReply packet</summary>
    public class GroupAccountDetailsReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            private byte[] _startdate;
            /// <summary>StartDate field</summary>
            public byte[] StartDate
            {
                get { return _startdate; }
                set
                {
                    if (value == null) { _startdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdate = new byte[value.Length]; Array.Copy(value, _startdate, value.Length); }
                }
            }
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (StartDate != null) { length += 1 + StartDate.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _startdate = new byte[length];
                    Array.Copy(bytes, i, _startdate, 0, length); i += length;
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)StartDate.Length;
                Array.Copy(StartDate, 0, bytes, i, StartDate.Length); i += StartDate.Length;
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>HistoryData block</summary>
        public class HistoryDataBlock
        {
            /// <summary>Amount field</summary>
            public int Amount;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HistoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HistoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupAccountDetailsReply</summary>
        public override PacketType Type { get { return PacketType.GroupAccountDetailsReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>HistoryData block</summary>
        public HistoryDataBlock[] HistoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupAccountDetailsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 438;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            HistoryData = new HistoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupAccountDetailsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupAccountDetailsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            for (int j = 0; j < HistoryData.Length; j++) { length += HistoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)HistoryData.Length;
            for (int j = 0; j < HistoryData.Length; j++) { HistoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupAccountTransactionsRequest packet</summary>
    public class GroupAccountTransactionsRequestPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupAccountTransactionsRequest</summary>
        public override PacketType Type { get { return PacketType.GroupAccountTransactionsRequest; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupAccountTransactionsRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 439;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupAccountTransactionsRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupAccountTransactionsRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupAccountTransactionsReply packet</summary>
    public class GroupAccountTransactionsReplyPacket : Packet
    {
        /// <summary>MoneyData block</summary>
        public class MoneyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>IntervalDays field</summary>
            public int IntervalDays;
            private byte[] _startdate;
            /// <summary>StartDate field</summary>
            public byte[] StartDate
            {
                get { return _startdate; }
                set
                {
                    if (value == null) { _startdate = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdate = new byte[value.Length]; Array.Copy(value, _startdate, value.Length); }
                }
            }
            /// <summary>CurrentInterval field</summary>
            public int CurrentInterval;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    if (StartDate != null) { length += 1 + StartDate.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MoneyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MoneyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    IntervalDays = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _startdate = new byte[length];
                    Array.Copy(bytes, i, _startdate, 0, length); i += length;
                    CurrentInterval = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntervalDays % 256);
                bytes[i++] = (byte)((IntervalDays >> 8) % 256);
                bytes[i++] = (byte)((IntervalDays >> 16) % 256);
                bytes[i++] = (byte)((IntervalDays >> 24) % 256);
                bytes[i++] = (byte)StartDate.Length;
                Array.Copy(StartDate, 0, bytes, i, StartDate.Length); i += StartDate.Length;
                bytes[i++] = (byte)(CurrentInterval % 256);
                bytes[i++] = (byte)((CurrentInterval >> 8) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 16) % 256);
                bytes[i++] = (byte)((CurrentInterval >> 24) % 256);
            }
        }

        /// <summary>HistoryData block</summary>
        public class HistoryDataBlock
        {
            private byte[] _time;
            /// <summary>Time field</summary>
            public byte[] Time
            {
                get { return _time; }
                set
                {
                    if (value == null) { _time = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _time = new byte[value.Length]; Array.Copy(value, _time, value.Length); }
                }
            }
            private byte[] _item;
            /// <summary>Item field</summary>
            public byte[] Item
            {
                get { return _item; }
                set
                {
                    if (value == null) { _item = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _item = new byte[value.Length]; Array.Copy(value, _item, value.Length); }
                }
            }
            private byte[] _user;
            /// <summary>User field</summary>
            public byte[] User
            {
                get { return _user; }
                set
                {
                    if (value == null) { _user = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _user = new byte[value.Length]; Array.Copy(value, _user, value.Length); }
                }
            }
            /// <summary>Type field</summary>
            public int Type;
            /// <summary>Amount field</summary>
            public int Amount;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 9;
                    if (Time != null) { length += 1 + Time.Length; }
                    if (Item != null) { length += 1 + Item.Length; }
                    if (User != null) { length += 1 + User.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HistoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HistoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _time = new byte[length];
                    Array.Copy(bytes, i, _time, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _item = new byte[length];
                    Array.Copy(bytes, i, _item, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _user = new byte[length];
                    Array.Copy(bytes, i, _user, 0, length); i += length;
                    Type = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Amount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Time.Length;
                Array.Copy(Time, 0, bytes, i, Time.Length); i += Time.Length;
                bytes[i++] = (byte)Item.Length;
                Array.Copy(Item, 0, bytes, i, Item.Length); i += Item.Length;
                bytes[i++] = (byte)User.Length;
                Array.Copy(User, 0, bytes, i, User.Length); i += User.Length;
                bytes[i++] = (byte)(Type % 256);
                bytes[i++] = (byte)((Type >> 8) % 256);
                bytes[i++] = (byte)((Type >> 16) % 256);
                bytes[i++] = (byte)((Type >> 24) % 256);
                bytes[i++] = (byte)(Amount % 256);
                bytes[i++] = (byte)((Amount >> 8) % 256);
                bytes[i++] = (byte)((Amount >> 16) % 256);
                bytes[i++] = (byte)((Amount >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupAccountTransactionsReply</summary>
        public override PacketType Type { get { return PacketType.GroupAccountTransactionsReply; } }
        /// <summary>MoneyData block</summary>
        public MoneyDataBlock MoneyData;
        /// <summary>HistoryData block</summary>
        public HistoryDataBlock[] HistoryData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupAccountTransactionsReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 440;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MoneyData = new MoneyDataBlock();
            HistoryData = new HistoryDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupAccountTransactionsReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupAccountTransactionsReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MoneyData = new MoneyDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            HistoryData = new HistoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { HistoryData[j] = new HistoryDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MoneyData.Length;            length += AgentData.Length;;
            for (int j = 0; j < HistoryData.Length; j++) { length += HistoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MoneyData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)HistoryData.Length;
            for (int j = 0; j < HistoryData.Length; j++) { HistoryData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupActiveProposalsRequest packet</summary>
    public class GroupActiveProposalsRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TransactionData block</summary>
        public class TransactionDataBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupActiveProposalsRequest</summary>
        public override PacketType Type { get { return PacketType.GroupActiveProposalsRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>TransactionData block</summary>
        public TransactionDataBlock TransactionData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupActiveProposalsRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 441;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            TransactionData = new TransactionDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupActiveProposalsRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupActiveProposalsRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += TransactionData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            TransactionData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupActiveProposalItemReply packet</summary>
    public class GroupActiveProposalItemReplyPacket : Packet
    {
        /// <summary>ProposalData block</summary>
        public class ProposalDataBlock
        {
            private byte[] _startdatetime;
            /// <summary>StartDateTime field</summary>
            public byte[] StartDateTime
            {
                get { return _startdatetime; }
                set
                {
                    if (value == null) { _startdatetime = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdatetime = new byte[value.Length]; Array.Copy(value, _startdatetime, value.Length); }
                }
            }
            private byte[] _proposaltext;
            /// <summary>ProposalText field</summary>
            public byte[] ProposalText
            {
                get { return _proposaltext; }
                set
                {
                    if (value == null) { _proposaltext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _proposaltext = new byte[value.Length]; Array.Copy(value, _proposaltext, value.Length); }
                }
            }
            /// <summary>Majority field</summary>
            public float Majority;
            private byte[] _tersedateid;
            /// <summary>TerseDateID field</summary>
            public byte[] TerseDateID
            {
                get { return _tersedateid; }
                set
                {
                    if (value == null) { _tersedateid = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _tersedateid = new byte[value.Length]; Array.Copy(value, _tersedateid, value.Length); }
                }
            }
            private byte[] _enddatetime;
            /// <summary>EndDateTime field</summary>
            public byte[] EndDateTime
            {
                get { return _enddatetime; }
                set
                {
                    if (value == null) { _enddatetime = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _enddatetime = new byte[value.Length]; Array.Copy(value, _enddatetime, value.Length); }
                }
            }
            /// <summary>VoteID field</summary>
            public LLUUID VoteID;
            /// <summary>AlreadyVoted field</summary>
            public bool AlreadyVoted;
            private byte[] _votecast;
            /// <summary>VoteCast field</summary>
            public byte[] VoteCast
            {
                get { return _votecast; }
                set
                {
                    if (value == null) { _votecast = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _votecast = new byte[value.Length]; Array.Copy(value, _votecast, value.Length); }
                }
            }
            /// <summary>Quorum field</summary>
            public int Quorum;
            /// <summary>VoteInitiator field</summary>
            public LLUUID VoteInitiator;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 42;
                    if (StartDateTime != null) { length += 1 + StartDateTime.Length; }
                    if (ProposalText != null) { length += 1 + ProposalText.Length; }
                    if (TerseDateID != null) { length += 1 + TerseDateID.Length; }
                    if (EndDateTime != null) { length += 1 + EndDateTime.Length; }
                    if (VoteCast != null) { length += 1 + VoteCast.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ProposalDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ProposalDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _startdatetime = new byte[length];
                    Array.Copy(bytes, i, _startdatetime, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _proposaltext = new byte[length];
                    Array.Copy(bytes, i, _proposaltext, 0, length); i += length;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Majority = BitConverter.ToSingle(bytes, i); i += 4;
                    length = (ushort)bytes[i++];
                    _tersedateid = new byte[length];
                    Array.Copy(bytes, i, _tersedateid, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _enddatetime = new byte[length];
                    Array.Copy(bytes, i, _enddatetime, 0, length); i += length;
                    VoteID = new LLUUID(bytes, i); i += 16;
                    AlreadyVoted = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _votecast = new byte[length];
                    Array.Copy(bytes, i, _votecast, 0, length); i += length;
                    Quorum = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    VoteInitiator = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)StartDateTime.Length;
                Array.Copy(StartDateTime, 0, bytes, i, StartDateTime.Length); i += StartDateTime.Length;
                bytes[i++] = (byte)ProposalText.Length;
                Array.Copy(ProposalText, 0, bytes, i, ProposalText.Length); i += ProposalText.Length;
                ba = BitConverter.GetBytes(Majority);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)TerseDateID.Length;
                Array.Copy(TerseDateID, 0, bytes, i, TerseDateID.Length); i += TerseDateID.Length;
                bytes[i++] = (byte)EndDateTime.Length;
                Array.Copy(EndDateTime, 0, bytes, i, EndDateTime.Length); i += EndDateTime.Length;
                Array.Copy(VoteID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AlreadyVoted) ? 1 : 0);
                bytes[i++] = (byte)VoteCast.Length;
                Array.Copy(VoteCast, 0, bytes, i, VoteCast.Length); i += VoteCast.Length;
                bytes[i++] = (byte)(Quorum % 256);
                bytes[i++] = (byte)((Quorum >> 8) % 256);
                bytes[i++] = (byte)((Quorum >> 16) % 256);
                bytes[i++] = (byte)((Quorum >> 24) % 256);
                Array.Copy(VoteInitiator.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TransactionData block</summary>
        public class TransactionDataBlock
        {
            /// <summary>TotalNumItems field</summary>
            public uint TotalNumItems;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TotalNumItems = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TotalNumItems % 256);
                bytes[i++] = (byte)((TotalNumItems >> 8) % 256);
                bytes[i++] = (byte)((TotalNumItems >> 16) % 256);
                bytes[i++] = (byte)((TotalNumItems >> 24) % 256);
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupActiveProposalItemReply</summary>
        public override PacketType Type { get { return PacketType.GroupActiveProposalItemReply; } }
        /// <summary>ProposalData block</summary>
        public ProposalDataBlock[] ProposalData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>TransactionData block</summary>
        public TransactionDataBlock TransactionData;

        /// <summary>Default constructor</summary>
        public GroupActiveProposalItemReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 442;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ProposalData = new ProposalDataBlock[0];
            AgentData = new AgentDataBlock();
            TransactionData = new TransactionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupActiveProposalItemReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ProposalData = new ProposalDataBlock[count];
            for (int j = 0; j < count; j++)
            { ProposalData[j] = new ProposalDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupActiveProposalItemReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ProposalData = new ProposalDataBlock[count];
            for (int j = 0; j < count; j++)
            { ProposalData[j] = new ProposalDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += TransactionData.Length;;
            for (int j = 0; j < ProposalData.Length; j++) { length += ProposalData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ProposalData.Length;
            for (int j = 0; j < ProposalData.Length; j++) { ProposalData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            TransactionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupVoteHistoryRequest packet</summary>
    public class GroupVoteHistoryRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TransactionData block</summary>
        public class TransactionDataBlock
        {
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupVoteHistoryRequest</summary>
        public override PacketType Type { get { return PacketType.GroupVoteHistoryRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>TransactionData block</summary>
        public TransactionDataBlock TransactionData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupVoteHistoryRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 443;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            TransactionData = new TransactionDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupVoteHistoryRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupVoteHistoryRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += TransactionData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            TransactionData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupVoteHistoryItemReply packet</summary>
    public class GroupVoteHistoryItemReplyPacket : Packet
    {
        /// <summary>HistoryItemData block</summary>
        public class HistoryItemDataBlock
        {
            private byte[] _startdatetime;
            /// <summary>StartDateTime field</summary>
            public byte[] StartDateTime
            {
                get { return _startdatetime; }
                set
                {
                    if (value == null) { _startdatetime = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _startdatetime = new byte[value.Length]; Array.Copy(value, _startdatetime, value.Length); }
                }
            }
            private byte[] _voteresult;
            /// <summary>VoteResult field</summary>
            public byte[] VoteResult
            {
                get { return _voteresult; }
                set
                {
                    if (value == null) { _voteresult = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _voteresult = new byte[value.Length]; Array.Copy(value, _voteresult, value.Length); }
                }
            }
            private byte[] _proposaltext;
            /// <summary>ProposalText field</summary>
            public byte[] ProposalText
            {
                get { return _proposaltext; }
                set
                {
                    if (value == null) { _proposaltext = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _proposaltext = new byte[value.Length]; Array.Copy(value, _proposaltext, value.Length); }
                }
            }
            /// <summary>Majority field</summary>
            public float Majority;
            private byte[] _tersedateid;
            /// <summary>TerseDateID field</summary>
            public byte[] TerseDateID
            {
                get { return _tersedateid; }
                set
                {
                    if (value == null) { _tersedateid = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _tersedateid = new byte[value.Length]; Array.Copy(value, _tersedateid, value.Length); }
                }
            }
            private byte[] _enddatetime;
            /// <summary>EndDateTime field</summary>
            public byte[] EndDateTime
            {
                get { return _enddatetime; }
                set
                {
                    if (value == null) { _enddatetime = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _enddatetime = new byte[value.Length]; Array.Copy(value, _enddatetime, value.Length); }
                }
            }
            /// <summary>VoteID field</summary>
            public LLUUID VoteID;
            /// <summary>Quorum field</summary>
            public int Quorum;
            private byte[] _votetype;
            /// <summary>VoteType field</summary>
            public byte[] VoteType
            {
                get { return _votetype; }
                set
                {
                    if (value == null) { _votetype = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _votetype = new byte[value.Length]; Array.Copy(value, _votetype, value.Length); }
                }
            }
            /// <summary>VoteInitiator field</summary>
            public LLUUID VoteInitiator;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 40;
                    if (StartDateTime != null) { length += 1 + StartDateTime.Length; }
                    if (VoteResult != null) { length += 1 + VoteResult.Length; }
                    if (ProposalText != null) { length += 2 + ProposalText.Length; }
                    if (TerseDateID != null) { length += 1 + TerseDateID.Length; }
                    if (EndDateTime != null) { length += 1 + EndDateTime.Length; }
                    if (VoteType != null) { length += 1 + VoteType.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HistoryItemDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HistoryItemDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _startdatetime = new byte[length];
                    Array.Copy(bytes, i, _startdatetime, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _voteresult = new byte[length];
                    Array.Copy(bytes, i, _voteresult, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _proposaltext = new byte[length];
                    Array.Copy(bytes, i, _proposaltext, 0, length); i += length;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Majority = BitConverter.ToSingle(bytes, i); i += 4;
                    length = (ushort)bytes[i++];
                    _tersedateid = new byte[length];
                    Array.Copy(bytes, i, _tersedateid, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _enddatetime = new byte[length];
                    Array.Copy(bytes, i, _enddatetime, 0, length); i += length;
                    VoteID = new LLUUID(bytes, i); i += 16;
                    Quorum = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _votetype = new byte[length];
                    Array.Copy(bytes, i, _votetype, 0, length); i += length;
                    VoteInitiator = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)StartDateTime.Length;
                Array.Copy(StartDateTime, 0, bytes, i, StartDateTime.Length); i += StartDateTime.Length;
                bytes[i++] = (byte)VoteResult.Length;
                Array.Copy(VoteResult, 0, bytes, i, VoteResult.Length); i += VoteResult.Length;
                bytes[i++] = (byte)(ProposalText.Length % 256);
                bytes[i++] = (byte)((ProposalText.Length >> 8) % 256);
                Array.Copy(ProposalText, 0, bytes, i, ProposalText.Length); i += ProposalText.Length;
                ba = BitConverter.GetBytes(Majority);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)TerseDateID.Length;
                Array.Copy(TerseDateID, 0, bytes, i, TerseDateID.Length); i += TerseDateID.Length;
                bytes[i++] = (byte)EndDateTime.Length;
                Array.Copy(EndDateTime, 0, bytes, i, EndDateTime.Length); i += EndDateTime.Length;
                Array.Copy(VoteID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Quorum % 256);
                bytes[i++] = (byte)((Quorum >> 8) % 256);
                bytes[i++] = (byte)((Quorum >> 16) % 256);
                bytes[i++] = (byte)((Quorum >> 24) % 256);
                bytes[i++] = (byte)VoteType.Length;
                Array.Copy(VoteType, 0, bytes, i, VoteType.Length); i += VoteType.Length;
                Array.Copy(VoteInitiator.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>VoteItem block</summary>
        public class VoteItemBlock
        {
            /// <summary>CandidateID field</summary>
            public LLUUID CandidateID;
            private byte[] _votecast;
            /// <summary>VoteCast field</summary>
            public byte[] VoteCast
            {
                get { return _votecast; }
                set
                {
                    if (value == null) { _votecast = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _votecast = new byte[value.Length]; Array.Copy(value, _votecast, value.Length); }
                }
            }
            /// <summary>NumVotes field</summary>
            public int NumVotes;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    if (VoteCast != null) { length += 1 + VoteCast.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public VoteItemBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public VoteItemBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    CandidateID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _votecast = new byte[length];
                    Array.Copy(bytes, i, _votecast, 0, length); i += length;
                    NumVotes = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(CandidateID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)VoteCast.Length;
                Array.Copy(VoteCast, 0, bytes, i, VoteCast.Length); i += VoteCast.Length;
                bytes[i++] = (byte)(NumVotes % 256);
                bytes[i++] = (byte)((NumVotes >> 8) % 256);
                bytes[i++] = (byte)((NumVotes >> 16) % 256);
                bytes[i++] = (byte)((NumVotes >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TransactionData block</summary>
        public class TransactionDataBlock
        {
            /// <summary>TotalNumItems field</summary>
            public uint TotalNumItems;
            /// <summary>TransactionID field</summary>
            public LLUUID TransactionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransactionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransactionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TotalNumItems = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TransactionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TotalNumItems % 256);
                bytes[i++] = (byte)((TotalNumItems >> 8) % 256);
                bytes[i++] = (byte)((TotalNumItems >> 16) % 256);
                bytes[i++] = (byte)((TotalNumItems >> 24) % 256);
                Array.Copy(TransactionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupVoteHistoryItemReply</summary>
        public override PacketType Type { get { return PacketType.GroupVoteHistoryItemReply; } }
        /// <summary>HistoryItemData block</summary>
        public HistoryItemDataBlock HistoryItemData;
        /// <summary>VoteItem block</summary>
        public VoteItemBlock[] VoteItem;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>TransactionData block</summary>
        public TransactionDataBlock TransactionData;

        /// <summary>Default constructor</summary>
        public GroupVoteHistoryItemReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 444;
            Header.Reliable = true;
            Header.Zerocoded = true;
            HistoryItemData = new HistoryItemDataBlock();
            VoteItem = new VoteItemBlock[0];
            AgentData = new AgentDataBlock();
            TransactionData = new TransactionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupVoteHistoryItemReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            HistoryItemData = new HistoryItemDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            VoteItem = new VoteItemBlock[count];
            for (int j = 0; j < count; j++)
            { VoteItem[j] = new VoteItemBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupVoteHistoryItemReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            HistoryItemData = new HistoryItemDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            VoteItem = new VoteItemBlock[count];
            for (int j = 0; j < count; j++)
            { VoteItem[j] = new VoteItemBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            TransactionData = new TransactionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += HistoryItemData.Length;            length += AgentData.Length;            length += TransactionData.Length;;
            for (int j = 0; j < VoteItem.Length; j++) { length += VoteItem[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            HistoryItemData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)VoteItem.Length;
            for (int j = 0; j < VoteItem.Length; j++) { VoteItem[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            TransactionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartGroupProposal packet</summary>
    public class StartGroupProposalPacket : Packet
    {
        /// <summary>ProposalData block</summary>
        public class ProposalDataBlock
        {
            /// <summary>Duration field</summary>
            public int Duration;
            private byte[] _proposaltext;
            /// <summary>ProposalText field</summary>
            public byte[] ProposalText
            {
                get { return _proposaltext; }
                set
                {
                    if (value == null) { _proposaltext = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _proposaltext = new byte[value.Length]; Array.Copy(value, _proposaltext, value.Length); }
                }
            }
            /// <summary>Majority field</summary>
            public float Majority;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>Quorum field</summary>
            public int Quorum;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    if (ProposalText != null) { length += 1 + ProposalText.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ProposalDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ProposalDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Duration = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _proposaltext = new byte[length];
                    Array.Copy(bytes, i, _proposaltext, 0, length); i += length;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Majority = BitConverter.ToSingle(bytes, i); i += 4;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    Quorum = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(Duration % 256);
                bytes[i++] = (byte)((Duration >> 8) % 256);
                bytes[i++] = (byte)((Duration >> 16) % 256);
                bytes[i++] = (byte)((Duration >> 24) % 256);
                bytes[i++] = (byte)ProposalText.Length;
                Array.Copy(ProposalText, 0, bytes, i, ProposalText.Length); i += ProposalText.Length;
                ba = BitConverter.GetBytes(Majority);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Quorum % 256);
                bytes[i++] = (byte)((Quorum >> 8) % 256);
                bytes[i++] = (byte)((Quorum >> 16) % 256);
                bytes[i++] = (byte)((Quorum >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartGroupProposal</summary>
        public override PacketType Type { get { return PacketType.StartGroupProposal; } }
        /// <summary>ProposalData block</summary>
        public ProposalDataBlock ProposalData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public StartGroupProposalPacket()
        {
            Header = new LowHeader();
            Header.ID = 445;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ProposalData = new ProposalDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartGroupProposalPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ProposalData = new ProposalDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartGroupProposalPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ProposalData = new ProposalDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ProposalData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ProposalData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupProposalBallot packet</summary>
    public class GroupProposalBallotPacket : Packet
    {
        /// <summary>ProposalData block</summary>
        public class ProposalDataBlock
        {
            /// <summary>ProposalID field</summary>
            public LLUUID ProposalID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            private byte[] _votecast;
            /// <summary>VoteCast field</summary>
            public byte[] VoteCast
            {
                get { return _votecast; }
                set
                {
                    if (value == null) { _votecast = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _votecast = new byte[value.Length]; Array.Copy(value, _votecast, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    if (VoteCast != null) { length += 1 + VoteCast.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ProposalDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ProposalDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ProposalID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _votecast = new byte[length];
                    Array.Copy(bytes, i, _votecast, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ProposalID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)VoteCast.Length;
                Array.Copy(VoteCast, 0, bytes, i, VoteCast.Length); i += VoteCast.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupProposalBallot</summary>
        public override PacketType Type { get { return PacketType.GroupProposalBallot; } }
        /// <summary>ProposalData block</summary>
        public ProposalDataBlock ProposalData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupProposalBallotPacket()
        {
            Header = new LowHeader();
            Header.ID = 446;
            Header.Reliable = true;
            ProposalData = new ProposalDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupProposalBallotPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ProposalData = new ProposalDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupProposalBallotPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ProposalData = new ProposalDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ProposalData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ProposalData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TallyVotes packet</summary>
    public class TallyVotesPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TallyVotes</summary>
        public override PacketType Type { get { return PacketType.TallyVotes; } }

        /// <summary>Default constructor</summary>
        public TallyVotesPacket()
        {
            Header = new LowHeader();
            Header.ID = 447;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TallyVotesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TallyVotesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupMembersRequest packet</summary>
    public class GroupMembersRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupMembersRequest</summary>
        public override PacketType Type { get { return PacketType.GroupMembersRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupMembersRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 448;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupMembersRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupMembersRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupMembersReply packet</summary>
    public class GroupMembersReplyPacket : Packet
    {
        /// <summary>MemberData block</summary>
        public class MemberDataBlock
        {
            private byte[] _onlinestatus;
            /// <summary>OnlineStatus field</summary>
            public byte[] OnlineStatus
            {
                get { return _onlinestatus; }
                set
                {
                    if (value == null) { _onlinestatus = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _onlinestatus = new byte[value.Length]; Array.Copy(value, _onlinestatus, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Contribution field</summary>
            public int Contribution;
            /// <summary>IsOwner field</summary>
            public bool IsOwner;
            private byte[] _title;
            /// <summary>Title field</summary>
            public byte[] Title
            {
                get { return _title; }
                set
                {
                    if (value == null) { _title = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _title = new byte[value.Length]; Array.Copy(value, _title, value.Length); }
                }
            }
            /// <summary>AgentPowers field</summary>
            public ulong AgentPowers;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 30;
                    if (OnlineStatus != null) { length += 1 + OnlineStatus.Length; }
                    if (Title != null) { length += 1 + Title.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MemberDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MemberDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _onlinestatus = new byte[length];
                    Array.Copy(bytes, i, _onlinestatus, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Contribution = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    IsOwner = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _title = new byte[length];
                    Array.Copy(bytes, i, _title, 0, length); i += length;
                    AgentPowers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)OnlineStatus.Length;
                Array.Copy(OnlineStatus, 0, bytes, i, OnlineStatus.Length); i += OnlineStatus.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Contribution % 256);
                bytes[i++] = (byte)((Contribution >> 8) % 256);
                bytes[i++] = (byte)((Contribution >> 16) % 256);
                bytes[i++] = (byte)((Contribution >> 24) % 256);
                bytes[i++] = (byte)((IsOwner) ? 1 : 0);
                bytes[i++] = (byte)Title.Length;
                Array.Copy(Title, 0, bytes, i, Title.Length); i += Title.Length;
                bytes[i++] = (byte)(AgentPowers % 256);
                bytes[i++] = (byte)((AgentPowers >> 8) % 256);
                bytes[i++] = (byte)((AgentPowers >> 16) % 256);
                bytes[i++] = (byte)((AgentPowers >> 24) % 256);
                bytes[i++] = (byte)((AgentPowers >> 32) % 256);
                bytes[i++] = (byte)((AgentPowers >> 40) % 256);
                bytes[i++] = (byte)((AgentPowers >> 48) % 256);
                bytes[i++] = (byte)((AgentPowers >> 56) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>MemberCount field</summary>
            public int MemberCount;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    MemberCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(MemberCount % 256);
                bytes[i++] = (byte)((MemberCount >> 8) % 256);
                bytes[i++] = (byte)((MemberCount >> 16) % 256);
                bytes[i++] = (byte)((MemberCount >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupMembersReply</summary>
        public override PacketType Type { get { return PacketType.GroupMembersReply; } }
        /// <summary>MemberData block</summary>
        public MemberDataBlock[] MemberData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupMembersReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 449;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MemberData = new MemberDataBlock[0];
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupMembersReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            MemberData = new MemberDataBlock[count];
            for (int j = 0; j < count; j++)
            { MemberData[j] = new MemberDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupMembersReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            MemberData = new MemberDataBlock[count];
            for (int j = 0; j < count; j++)
            { MemberData[j] = new MemberDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            for (int j = 0; j < MemberData.Length; j++) { length += MemberData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)MemberData.Length;
            for (int j = 0; j < MemberData.Length; j++) { MemberData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ActivateGroup packet</summary>
    public class ActivateGroupPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ActivateGroup</summary>
        public override PacketType Type { get { return PacketType.ActivateGroup; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ActivateGroupPacket()
        {
            Header = new LowHeader();
            Header.ID = 450;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ActivateGroupPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ActivateGroupPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetGroupContribution packet</summary>
    public class SetGroupContributionPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>Contribution field</summary>
            public int Contribution;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Contribution = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Contribution % 256);
                bytes[i++] = (byte)((Contribution >> 8) % 256);
                bytes[i++] = (byte)((Contribution >> 16) % 256);
                bytes[i++] = (byte)((Contribution >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetGroupContribution</summary>
        public override PacketType Type { get { return PacketType.SetGroupContribution; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public SetGroupContributionPacket()
        {
            Header = new LowHeader();
            Header.ID = 451;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetGroupContributionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetGroupContributionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetGroupAcceptNotices packet</summary>
    public class SetGroupAcceptNoticesPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>AcceptNotices field</summary>
            public bool AcceptNotices;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupID = new LLUUID(bytes, i); i += 16;
                    AcceptNotices = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AcceptNotices) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetGroupAcceptNotices</summary>
        public override PacketType Type { get { return PacketType.SetGroupAcceptNotices; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public SetGroupAcceptNoticesPacket()
        {
            Header = new LowHeader();
            Header.ID = 452;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetGroupAcceptNoticesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetGroupAcceptNoticesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupRoleDataRequest packet</summary>
    public class GroupRoleDataRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupRoleDataRequest</summary>
        public override PacketType Type { get { return PacketType.GroupRoleDataRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupRoleDataRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 453;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupRoleDataRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupRoleDataRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupRoleDataReply packet</summary>
    public class GroupRoleDataReplyPacket : Packet
    {
        /// <summary>RoleData block</summary>
        public class RoleDataBlock
        {
            /// <summary>Members field</summary>
            public uint Members;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>RoleID field</summary>
            public LLUUID RoleID;
            /// <summary>Powers field</summary>
            public ulong Powers;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            private byte[] _title;
            /// <summary>Title field</summary>
            public byte[] Title
            {
                get { return _title; }
                set
                {
                    if (value == null) { _title = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _title = new byte[value.Length]; Array.Copy(value, _title, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    if (Title != null) { length += 1 + Title.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RoleDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RoleDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Members = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    RoleID = new LLUUID(bytes, i); i += 16;
                    Powers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _title = new byte[length];
                    Array.Copy(bytes, i, _title, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Members % 256);
                bytes[i++] = (byte)((Members >> 8) % 256);
                bytes[i++] = (byte)((Members >> 16) % 256);
                bytes[i++] = (byte)((Members >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(RoleID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Powers % 256);
                bytes[i++] = (byte)((Powers >> 8) % 256);
                bytes[i++] = (byte)((Powers >> 16) % 256);
                bytes[i++] = (byte)((Powers >> 24) % 256);
                bytes[i++] = (byte)((Powers >> 32) % 256);
                bytes[i++] = (byte)((Powers >> 40) % 256);
                bytes[i++] = (byte)((Powers >> 48) % 256);
                bytes[i++] = (byte)((Powers >> 56) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)Title.Length;
                Array.Copy(Title, 0, bytes, i, Title.Length); i += Title.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>RoleCount field</summary>
            public int RoleCount;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RoleCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RequestID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RoleCount % 256);
                bytes[i++] = (byte)((RoleCount >> 8) % 256);
                bytes[i++] = (byte)((RoleCount >> 16) % 256);
                bytes[i++] = (byte)((RoleCount >> 24) % 256);
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupRoleDataReply</summary>
        public override PacketType Type { get { return PacketType.GroupRoleDataReply; } }
        /// <summary>RoleData block</summary>
        public RoleDataBlock[] RoleData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupRoleDataReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 454;
            Header.Reliable = true;
            RoleData = new RoleDataBlock[0];
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupRoleDataReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RoleData = new RoleDataBlock[count];
            for (int j = 0; j < count; j++)
            { RoleData[j] = new RoleDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupRoleDataReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RoleData = new RoleDataBlock[count];
            for (int j = 0; j < count; j++)
            { RoleData[j] = new RoleDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            for (int j = 0; j < RoleData.Length; j++) { length += RoleData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RoleData.Length;
            for (int j = 0; j < RoleData.Length; j++) { RoleData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupRoleMembersRequest packet</summary>
    public class GroupRoleMembersRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupRoleMembersRequest</summary>
        public override PacketType Type { get { return PacketType.GroupRoleMembersRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock GroupData;

        /// <summary>Default constructor</summary>
        public GroupRoleMembersRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 455;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupRoleMembersRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupRoleMembersRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            GroupData = new GroupDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += GroupData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            GroupData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupRoleMembersReply packet</summary>
    public class GroupRoleMembersReplyPacket : Packet
    {
        /// <summary>MemberData block</summary>
        public class MemberDataBlock
        {
            /// <summary>MemberID field</summary>
            public LLUUID MemberID;
            /// <summary>RoleID field</summary>
            public LLUUID RoleID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MemberDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MemberDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    MemberID = new LLUUID(bytes, i); i += 16;
                    RoleID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(MemberID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RoleID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>TotalPairs field</summary>
            public uint TotalPairs;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 52;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    TotalPairs = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RequestID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TotalPairs % 256);
                bytes[i++] = (byte)((TotalPairs >> 8) % 256);
                bytes[i++] = (byte)((TotalPairs >> 16) % 256);
                bytes[i++] = (byte)((TotalPairs >> 24) % 256);
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupRoleMembersReply</summary>
        public override PacketType Type { get { return PacketType.GroupRoleMembersReply; } }
        /// <summary>MemberData block</summary>
        public MemberDataBlock[] MemberData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupRoleMembersReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 456;
            Header.Reliable = true;
            MemberData = new MemberDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupRoleMembersReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            MemberData = new MemberDataBlock[count];
            for (int j = 0; j < count; j++)
            { MemberData[j] = new MemberDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupRoleMembersReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            MemberData = new MemberDataBlock[count];
            for (int j = 0; j < count; j++)
            { MemberData[j] = new MemberDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < MemberData.Length; j++) { length += MemberData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)MemberData.Length;
            for (int j = 0; j < MemberData.Length; j++) { MemberData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupTitlesRequest packet</summary>
    public class GroupTitlesRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 64;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RequestID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupTitlesRequest</summary>
        public override PacketType Type { get { return PacketType.GroupTitlesRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupTitlesRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 457;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupTitlesRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupTitlesRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupTitlesReply packet</summary>
    public class GroupTitlesReplyPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RequestID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>Selected field</summary>
            public bool Selected;
            /// <summary>RoleID field</summary>
            public LLUUID RoleID;
            private byte[] _title;
            /// <summary>Title field</summary>
            public byte[] Title
            {
                get { return _title; }
                set
                {
                    if (value == null) { _title = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _title = new byte[value.Length]; Array.Copy(value, _title, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    if (Title != null) { length += 1 + Title.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Selected = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RoleID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _title = new byte[length];
                    Array.Copy(bytes, i, _title, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((Selected) ? 1 : 0);
                Array.Copy(RoleID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Title.Length;
                Array.Copy(Title, 0, bytes, i, Title.Length); i += Title.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupTitlesReply</summary>
        public override PacketType Type { get { return PacketType.GroupTitlesReply; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock[] GroupData;

        /// <summary>Default constructor</summary>
        public GroupTitlesReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 458;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupTitlesReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupTitlesReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < GroupData.Length; j++) { length += GroupData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)GroupData.Length;
            for (int j = 0; j < GroupData.Length; j++) { GroupData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupTitleUpdate packet</summary>
    public class GroupTitleUpdatePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>TitleRoleID field</summary>
            public LLUUID TitleRoleID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 64;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    TitleRoleID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(TitleRoleID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupTitleUpdate</summary>
        public override PacketType Type { get { return PacketType.GroupTitleUpdate; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupTitleUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 459;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupTitleUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupTitleUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupRoleUpdate packet</summary>
    public class GroupRoleUpdatePacket : Packet
    {
        /// <summary>RoleData block</summary>
        public class RoleDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>RoleID field</summary>
            public LLUUID RoleID;
            /// <summary>UpdateType field</summary>
            public byte UpdateType;
            /// <summary>Powers field</summary>
            public ulong Powers;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            private byte[] _title;
            /// <summary>Title field</summary>
            public byte[] Title
            {
                get { return _title; }
                set
                {
                    if (value == null) { _title = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _title = new byte[value.Length]; Array.Copy(value, _title, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    if (Title != null) { length += 1 + Title.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RoleDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RoleDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    RoleID = new LLUUID(bytes, i); i += 16;
                    UpdateType = (byte)bytes[i++];
                    Powers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _title = new byte[length];
                    Array.Copy(bytes, i, _title, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(RoleID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = UpdateType;
                bytes[i++] = (byte)(Powers % 256);
                bytes[i++] = (byte)((Powers >> 8) % 256);
                bytes[i++] = (byte)((Powers >> 16) % 256);
                bytes[i++] = (byte)((Powers >> 24) % 256);
                bytes[i++] = (byte)((Powers >> 32) % 256);
                bytes[i++] = (byte)((Powers >> 40) % 256);
                bytes[i++] = (byte)((Powers >> 48) % 256);
                bytes[i++] = (byte)((Powers >> 56) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)Title.Length;
                Array.Copy(Title, 0, bytes, i, Title.Length); i += Title.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupRoleUpdate</summary>
        public override PacketType Type { get { return PacketType.GroupRoleUpdate; } }
        /// <summary>RoleData block</summary>
        public RoleDataBlock[] RoleData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GroupRoleUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 460;
            Header.Reliable = true;
            RoleData = new RoleDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupRoleUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RoleData = new RoleDataBlock[count];
            for (int j = 0; j < count; j++)
            { RoleData[j] = new RoleDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupRoleUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RoleData = new RoleDataBlock[count];
            for (int j = 0; j < count; j++)
            { RoleData[j] = new RoleDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < RoleData.Length; j++) { length += RoleData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RoleData.Length;
            for (int j = 0; j < RoleData.Length; j++) { RoleData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LiveHelpGroupRequest packet</summary>
    public class LiveHelpGroupRequestPacket : Packet
    {
        /// <summary>RequestData block</summary>
        public class RequestDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    RequestID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LiveHelpGroupRequest</summary>
        public override PacketType Type { get { return PacketType.LiveHelpGroupRequest; } }
        /// <summary>RequestData block</summary>
        public RequestDataBlock RequestData;

        /// <summary>Default constructor</summary>
        public LiveHelpGroupRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 461;
            Header.Reliable = true;
            RequestData = new RequestDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LiveHelpGroupRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestData = new RequestDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LiveHelpGroupRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestData = new RequestDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LiveHelpGroupReply packet</summary>
    public class LiveHelpGroupReplyPacket : Packet
    {
        /// <summary>ReplyData block</summary>
        public class ReplyDataBlock
        {
            /// <summary>RequestID field</summary>
            public LLUUID RequestID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            private byte[] _selection;
            /// <summary>Selection field</summary>
            public byte[] Selection
            {
                get { return _selection; }
                set
                {
                    if (value == null) { _selection = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _selection = new byte[value.Length]; Array.Copy(value, _selection, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    if (Selection != null) { length += 1 + Selection.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReplyDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReplyDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RequestID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _selection = new byte[length];
                    Array.Copy(bytes, i, _selection, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(RequestID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Selection.Length;
                Array.Copy(Selection, 0, bytes, i, Selection.Length); i += Selection.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LiveHelpGroupReply</summary>
        public override PacketType Type { get { return PacketType.LiveHelpGroupReply; } }
        /// <summary>ReplyData block</summary>
        public ReplyDataBlock ReplyData;

        /// <summary>Default constructor</summary>
        public LiveHelpGroupReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 462;
            Header.Reliable = true;
            ReplyData = new ReplyDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LiveHelpGroupReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ReplyData = new ReplyDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LiveHelpGroupReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ReplyData = new ReplyDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ReplyData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ReplyData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentWearablesRequest packet</summary>
    public class AgentWearablesRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentWearablesRequest</summary>
        public override PacketType Type { get { return PacketType.AgentWearablesRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentWearablesRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 463;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentWearablesRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentWearablesRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentWearablesUpdate packet</summary>
    public class AgentWearablesUpdatePacket : Packet
    {
        /// <summary>WearableData block</summary>
        public class WearableDataBlock
        {
            /// <summary>WearableType field</summary>
            public byte WearableType;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 34;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public WearableDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public WearableDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    WearableType = (byte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = WearableType;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>SerialNum field</summary>
            public uint SerialNum;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SerialNum = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SerialNum % 256);
                bytes[i++] = (byte)((SerialNum >> 8) % 256);
                bytes[i++] = (byte)((SerialNum >> 16) % 256);
                bytes[i++] = (byte)((SerialNum >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentWearablesUpdate</summary>
        public override PacketType Type { get { return PacketType.AgentWearablesUpdate; } }
        /// <summary>WearableData block</summary>
        public WearableDataBlock[] WearableData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentWearablesUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 464;
            Header.Reliable = true;
            Header.Zerocoded = true;
            WearableData = new WearableDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentWearablesUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentWearablesUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < WearableData.Length; j++) { length += WearableData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)WearableData.Length;
            for (int j = 0; j < WearableData.Length; j++) { WearableData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentCachedTexture packet</summary>
    public class AgentCachedTexturePacket : Packet
    {
        /// <summary>WearableData block</summary>
        public class WearableDataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>TextureIndex field</summary>
            public byte TextureIndex;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public WearableDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public WearableDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    TextureIndex = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = TextureIndex;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>SerialNum field</summary>
            public int SerialNum;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SerialNum = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SerialNum % 256);
                bytes[i++] = (byte)((SerialNum >> 8) % 256);
                bytes[i++] = (byte)((SerialNum >> 16) % 256);
                bytes[i++] = (byte)((SerialNum >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentCachedTexture</summary>
        public override PacketType Type { get { return PacketType.AgentCachedTexture; } }
        /// <summary>WearableData block</summary>
        public WearableDataBlock[] WearableData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentCachedTexturePacket()
        {
            Header = new LowHeader();
            Header.ID = 465;
            Header.Reliable = true;
            WearableData = new WearableDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentCachedTexturePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentCachedTexturePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < WearableData.Length; j++) { length += WearableData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)WearableData.Length;
            for (int j = 0; j < WearableData.Length; j++) { WearableData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentCachedTextureResponse packet</summary>
    public class AgentCachedTextureResponsePacket : Packet
    {
        /// <summary>WearableData block</summary>
        public class WearableDataBlock
        {
            /// <summary>TextureID field</summary>
            public LLUUID TextureID;
            /// <summary>TextureIndex field</summary>
            public byte TextureIndex;
            private byte[] _hostname;
            /// <summary>HostName field</summary>
            public byte[] HostName
            {
                get { return _hostname; }
                set
                {
                    if (value == null) { _hostname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _hostname = new byte[value.Length]; Array.Copy(value, _hostname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    if (HostName != null) { length += 1 + HostName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public WearableDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public WearableDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    TextureID = new LLUUID(bytes, i); i += 16;
                    TextureIndex = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _hostname = new byte[length];
                    Array.Copy(bytes, i, _hostname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TextureID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = TextureIndex;
                bytes[i++] = (byte)HostName.Length;
                Array.Copy(HostName, 0, bytes, i, HostName.Length); i += HostName.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>SerialNum field</summary>
            public int SerialNum;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    SerialNum = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SerialNum % 256);
                bytes[i++] = (byte)((SerialNum >> 8) % 256);
                bytes[i++] = (byte)((SerialNum >> 16) % 256);
                bytes[i++] = (byte)((SerialNum >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentCachedTextureResponse</summary>
        public override PacketType Type { get { return PacketType.AgentCachedTextureResponse; } }
        /// <summary>WearableData block</summary>
        public WearableDataBlock[] WearableData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentCachedTextureResponsePacket()
        {
            Header = new LowHeader();
            Header.ID = 466;
            Header.Reliable = true;
            WearableData = new WearableDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentCachedTextureResponsePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentCachedTextureResponsePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            WearableData = new WearableDataBlock[count];
            for (int j = 0; j < count; j++)
            { WearableData[j] = new WearableDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < WearableData.Length; j++) { length += WearableData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)WearableData.Length;
            for (int j = 0; j < WearableData.Length; j++) { WearableData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentDataUpdateRequest packet</summary>
    public class AgentDataUpdateRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentDataUpdateRequest</summary>
        public override PacketType Type { get { return PacketType.AgentDataUpdateRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentDataUpdateRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 467;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentDataUpdateRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentDataUpdateRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentDataUpdate packet</summary>
    public class AgentDataUpdatePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            private byte[] _grouptitle;
            /// <summary>GroupTitle field</summary>
            public byte[] GroupTitle
            {
                get { return _grouptitle; }
                set
                {
                    if (value == null) { _grouptitle = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _grouptitle = new byte[value.Length]; Array.Copy(value, _grouptitle, value.Length); }
                }
            }
            /// <summary>GroupPowers field</summary>
            public ulong GroupPowers;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _lastname;
            /// <summary>LastName field</summary>
            public byte[] LastName
            {
                get { return _lastname; }
                set
                {
                    if (value == null) { _lastname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _lastname = new byte[value.Length]; Array.Copy(value, _lastname, value.Length); }
                }
            }
            private byte[] _firstname;
            /// <summary>FirstName field</summary>
            public byte[] FirstName
            {
                get { return _firstname; }
                set
                {
                    if (value == null) { _firstname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _firstname = new byte[value.Length]; Array.Copy(value, _firstname, value.Length); }
                }
            }
            private byte[] _groupname;
            /// <summary>GroupName field</summary>
            public byte[] GroupName
            {
                get { return _groupname; }
                set
                {
                    if (value == null) { _groupname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _groupname = new byte[value.Length]; Array.Copy(value, _groupname, value.Length); }
                }
            }
            /// <summary>ActiveGroupID field</summary>
            public LLUUID ActiveGroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 40;
                    if (GroupTitle != null) { length += 1 + GroupTitle.Length; }
                    if (LastName != null) { length += 1 + LastName.Length; }
                    if (FirstName != null) { length += 1 + FirstName.Length; }
                    if (GroupName != null) { length += 1 + GroupName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _grouptitle = new byte[length];
                    Array.Copy(bytes, i, _grouptitle, 0, length); i += length;
                    GroupPowers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _lastname = new byte[length];
                    Array.Copy(bytes, i, _lastname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _firstname = new byte[length];
                    Array.Copy(bytes, i, _firstname, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _groupname = new byte[length];
                    Array.Copy(bytes, i, _groupname, 0, length); i += length;
                    ActiveGroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)GroupTitle.Length;
                Array.Copy(GroupTitle, 0, bytes, i, GroupTitle.Length); i += GroupTitle.Length;
                bytes[i++] = (byte)(GroupPowers % 256);
                bytes[i++] = (byte)((GroupPowers >> 8) % 256);
                bytes[i++] = (byte)((GroupPowers >> 16) % 256);
                bytes[i++] = (byte)((GroupPowers >> 24) % 256);
                bytes[i++] = (byte)((GroupPowers >> 32) % 256);
                bytes[i++] = (byte)((GroupPowers >> 40) % 256);
                bytes[i++] = (byte)((GroupPowers >> 48) % 256);
                bytes[i++] = (byte)((GroupPowers >> 56) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)LastName.Length;
                Array.Copy(LastName, 0, bytes, i, LastName.Length); i += LastName.Length;
                bytes[i++] = (byte)FirstName.Length;
                Array.Copy(FirstName, 0, bytes, i, FirstName.Length); i += FirstName.Length;
                bytes[i++] = (byte)GroupName.Length;
                Array.Copy(GroupName, 0, bytes, i, GroupName.Length); i += GroupName.Length;
                Array.Copy(ActiveGroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentDataUpdate</summary>
        public override PacketType Type { get { return PacketType.AgentDataUpdate; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentDataUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 468;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentDataUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentDataUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GroupDataUpdate packet</summary>
    public class GroupDataUpdatePacket : Packet
    {
        /// <summary>AgentGroupData block</summary>
        public class AgentGroupDataBlock
        {
            private byte[] _grouptitle;
            /// <summary>GroupTitle field</summary>
            public byte[] GroupTitle
            {
                get { return _grouptitle; }
                set
                {
                    if (value == null) { _grouptitle = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _grouptitle = new byte[value.Length]; Array.Copy(value, _grouptitle, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>AgentPowers field</summary>
            public ulong AgentPowers;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 41;
                    if (GroupTitle != null) { length += 1 + GroupTitle.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentGroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentGroupDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _grouptitle = new byte[length];
                    Array.Copy(bytes, i, _grouptitle, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    AgentPowers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)GroupTitle.Length;
                Array.Copy(GroupTitle, 0, bytes, i, GroupTitle.Length); i += GroupTitle.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(AgentPowers % 256);
                bytes[i++] = (byte)((AgentPowers >> 8) % 256);
                bytes[i++] = (byte)((AgentPowers >> 16) % 256);
                bytes[i++] = (byte)((AgentPowers >> 24) % 256);
                bytes[i++] = (byte)((AgentPowers >> 32) % 256);
                bytes[i++] = (byte)((AgentPowers >> 40) % 256);
                bytes[i++] = (byte)((AgentPowers >> 48) % 256);
                bytes[i++] = (byte)((AgentPowers >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GroupDataUpdate</summary>
        public override PacketType Type { get { return PacketType.GroupDataUpdate; } }
        /// <summary>AgentGroupData block</summary>
        public AgentGroupDataBlock[] AgentGroupData;

        /// <summary>Default constructor</summary>
        public GroupDataUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 469;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentGroupData = new AgentGroupDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GroupDataUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AgentGroupData = new AgentGroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentGroupData[j] = new AgentGroupDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GroupDataUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AgentGroupData = new AgentGroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { AgentGroupData[j] = new AgentGroupDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < AgentGroupData.Length; j++) { length += AgentGroupData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AgentGroupData.Length;
            for (int j = 0; j < AgentGroupData.Length; j++) { AgentGroupData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentGroupDataUpdate packet</summary>
    public class AgentGroupDataUpdatePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupPowers field</summary>
            public ulong GroupPowers;
            /// <summary>Contribution field</summary>
            public int Contribution;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>GroupInsigniaID field</summary>
            public LLUUID GroupInsigniaID;
            /// <summary>AcceptNotices field</summary>
            public bool AcceptNotices;
            private byte[] _groupname;
            /// <summary>GroupName field</summary>
            public byte[] GroupName
            {
                get { return _groupname; }
                set
                {
                    if (value == null) { _groupname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _groupname = new byte[value.Length]; Array.Copy(value, _groupname, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 46;
                    if (GroupName != null) { length += 1 + GroupName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupPowers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Contribution = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    GroupInsigniaID = new LLUUID(bytes, i); i += 16;
                    AcceptNotices = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _groupname = new byte[length];
                    Array.Copy(bytes, i, _groupname, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(GroupPowers % 256);
                bytes[i++] = (byte)((GroupPowers >> 8) % 256);
                bytes[i++] = (byte)((GroupPowers >> 16) % 256);
                bytes[i++] = (byte)((GroupPowers >> 24) % 256);
                bytes[i++] = (byte)((GroupPowers >> 32) % 256);
                bytes[i++] = (byte)((GroupPowers >> 40) % 256);
                bytes[i++] = (byte)((GroupPowers >> 48) % 256);
                bytes[i++] = (byte)((GroupPowers >> 56) % 256);
                bytes[i++] = (byte)(Contribution % 256);
                bytes[i++] = (byte)((Contribution >> 8) % 256);
                bytes[i++] = (byte)((Contribution >> 16) % 256);
                bytes[i++] = (byte)((Contribution >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupInsigniaID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AcceptNotices) ? 1 : 0);
                bytes[i++] = (byte)GroupName.Length;
                Array.Copy(GroupName, 0, bytes, i, GroupName.Length); i += GroupName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentGroupDataUpdate</summary>
        public override PacketType Type { get { return PacketType.AgentGroupDataUpdate; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock[] GroupData;

        /// <summary>Default constructor</summary>
        public AgentGroupDataUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 470;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentGroupDataUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentGroupDataUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < GroupData.Length; j++) { length += GroupData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)GroupData.Length;
            for (int j = 0; j < GroupData.Length; j++) { GroupData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentDropGroup packet</summary>
    public class AgentDropGroupPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentDropGroup</summary>
        public override PacketType Type { get { return PacketType.AgentDropGroup; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentDropGroupPacket()
        {
            Header = new LowHeader();
            Header.ID = 471;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentDropGroupPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentDropGroupPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LogTextMessage packet</summary>
    public class LogTextMessagePacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ToAgentId field</summary>
            public LLUUID ToAgentId;
            private byte[] _message;
            /// <summary>Message field</summary>
            public byte[] Message
            {
                get { return _message; }
                set
                {
                    if (value == null) { _message = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _message = new byte[value.Length]; Array.Copy(value, _message, value.Length); }
                }
            }
            /// <summary>GlobalX field</summary>
            public double GlobalX;
            /// <summary>GlobalY field</summary>
            public double GlobalY;
            /// <summary>Time field</summary>
            public uint Time;
            /// <summary>FromAgentId field</summary>
            public LLUUID FromAgentId;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 53;
                    if (Message != null) { length += 2 + Message.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ToAgentId = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _message = new byte[length];
                    Array.Copy(bytes, i, _message, 0, length); i += length;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    GlobalX = BitConverter.ToDouble(bytes, i); i += 8;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 8);
                    GlobalY = BitConverter.ToDouble(bytes, i); i += 8;
                    Time = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    FromAgentId = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ToAgentId.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Message.Length % 256);
                bytes[i++] = (byte)((Message.Length >> 8) % 256);
                Array.Copy(Message, 0, bytes, i, Message.Length); i += Message.Length;
                ba = BitConverter.GetBytes(GlobalX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                ba = BitConverter.GetBytes(GlobalY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 8); }
                Array.Copy(ba, 0, bytes, i, 8); i += 8;
                bytes[i++] = (byte)(Time % 256);
                bytes[i++] = (byte)((Time >> 8) % 256);
                bytes[i++] = (byte)((Time >> 16) % 256);
                bytes[i++] = (byte)((Time >> 24) % 256);
                Array.Copy(FromAgentId.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LogTextMessage</summary>
        public override PacketType Type { get { return PacketType.LogTextMessage; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock[] DataBlock;

        /// <summary>Default constructor</summary>
        public LogTextMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 472;
            Header.Reliable = true;
            Header.Zerocoded = true;
            DataBlock = new DataBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LogTextMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LogTextMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < DataBlock.Length; j++) { length += DataBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)DataBlock.Length;
            for (int j = 0; j < DataBlock.Length; j++) { DataBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CreateTrustedCircuit packet</summary>
    public class CreateTrustedCircuitPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>Digest field</summary>
            public byte[] Digest;
            /// <summary>EndPointID field</summary>
            public LLUUID EndPointID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Digest = new byte[32];
                    Array.Copy(bytes, i, Digest, 0, 32); i += 32;
                    EndPointID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Digest, 0, bytes, i, 32);i += 32;
                Array.Copy(EndPointID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CreateTrustedCircuit</summary>
        public override PacketType Type { get { return PacketType.CreateTrustedCircuit; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public CreateTrustedCircuitPacket()
        {
            Header = new LowHeader();
            Header.ID = 473;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CreateTrustedCircuitPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CreateTrustedCircuitPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DenyTrustedCircuit packet</summary>
    public class DenyTrustedCircuitPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>EndPointID field</summary>
            public LLUUID EndPointID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    EndPointID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(EndPointID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DenyTrustedCircuit</summary>
        public override PacketType Type { get { return PacketType.DenyTrustedCircuit; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public DenyTrustedCircuitPacket()
        {
            Header = new LowHeader();
            Header.ID = 474;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DenyTrustedCircuitPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DenyTrustedCircuitPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RezSingleAttachmentFromInv packet</summary>
    public class RezSingleAttachmentFromInvPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>ItemFlags field</summary>
            public uint ItemFlags;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>AttachmentPt field</summary>
            public byte AttachmentPt;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 65;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    AssetID = new LLUUID(bytes, i); i += 16;
                    ItemFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ItemID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    AttachmentPt = (byte)bytes[i++];
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ItemFlags % 256);
                bytes[i++] = (byte)((ItemFlags >> 8) % 256);
                bytes[i++] = (byte)((ItemFlags >> 16) % 256);
                bytes[i++] = (byte)((ItemFlags >> 24) % 256);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = AttachmentPt;
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RezSingleAttachmentFromInv</summary>
        public override PacketType Type { get { return PacketType.RezSingleAttachmentFromInv; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;

        /// <summary>Default constructor</summary>
        public RezSingleAttachmentFromInvPacket()
        {
            Header = new LowHeader();
            Header.ID = 475;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RezSingleAttachmentFromInvPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RezSingleAttachmentFromInvPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RezMultipleAttachmentsFromInv packet</summary>
    public class RezMultipleAttachmentsFromInvPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>ItemFlags field</summary>
            public uint ItemFlags;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>AttachmentPt field</summary>
            public byte AttachmentPt;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 50;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    AssetID = new LLUUID(bytes, i); i += 16;
                    ItemFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ItemID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    AttachmentPt = (byte)bytes[i++];
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ItemFlags % 256);
                bytes[i++] = (byte)((ItemFlags >> 8) % 256);
                bytes[i++] = (byte)((ItemFlags >> 16) % 256);
                bytes[i++] = (byte)((ItemFlags >> 24) % 256);
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = AttachmentPt;
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
            }
        }

        /// <summary>HeaderData block</summary>
        public class HeaderDataBlock
        {
            /// <summary>CompoundMsgID field</summary>
            public LLUUID CompoundMsgID;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>FirstDetachAll field</summary>
            public byte FirstDetachAll;
            /// <summary>TotalObjects field</summary>
            public byte TotalObjects;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 34;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HeaderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HeaderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    CompoundMsgID = new LLUUID(bytes, i); i += 16;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    FirstDetachAll = (byte)bytes[i++];
                    TotalObjects = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(CompoundMsgID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = FirstDetachAll;
                bytes[i++] = TotalObjects;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RezMultipleAttachmentsFromInv</summary>
        public override PacketType Type { get { return PacketType.RezMultipleAttachmentsFromInv; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>HeaderData block</summary>
        public HeaderDataBlock HeaderData;

        /// <summary>Default constructor</summary>
        public RezMultipleAttachmentsFromInvPacket()
        {
            Header = new LowHeader();
            Header.ID = 476;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            HeaderData = new HeaderDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RezMultipleAttachmentsFromInvPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RezMultipleAttachmentsFromInvPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += HeaderData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            HeaderData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>DetachAttachmentIntoInv packet</summary>
    public class DetachAttachmentIntoInvPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.DetachAttachmentIntoInv</summary>
        public override PacketType Type { get { return PacketType.DetachAttachmentIntoInv; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;

        /// <summary>Default constructor</summary>
        public DetachAttachmentIntoInvPacket()
        {
            Header = new LowHeader();
            Header.ID = 477;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public DetachAttachmentIntoInvPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public DetachAttachmentIntoInvPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += ObjectData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CreateNewOutfitAttachments packet</summary>
    public class CreateNewOutfitAttachmentsPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>OldFolderID field</summary>
            public LLUUID OldFolderID;
            /// <summary>OldItemID field</summary>
            public LLUUID OldItemID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    OldFolderID = new LLUUID(bytes, i); i += 16;
                    OldItemID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(OldFolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OldItemID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>HeaderData block</summary>
        public class HeaderDataBlock
        {
            /// <summary>NewFolderID field</summary>
            public LLUUID NewFolderID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public HeaderDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public HeaderDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    NewFolderID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(NewFolderID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CreateNewOutfitAttachments</summary>
        public override PacketType Type { get { return PacketType.CreateNewOutfitAttachments; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>HeaderData block</summary>
        public HeaderDataBlock HeaderData;

        /// <summary>Default constructor</summary>
        public CreateNewOutfitAttachmentsPacket()
        {
            Header = new LowHeader();
            Header.ID = 478;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
            HeaderData = new HeaderDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CreateNewOutfitAttachmentsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CreateNewOutfitAttachmentsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            HeaderData = new HeaderDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;            length += HeaderData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            HeaderData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserInfoRequest packet</summary>
    public class UserInfoRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserInfoRequest</summary>
        public override PacketType Type { get { return PacketType.UserInfoRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UserInfoRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 479;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserInfoRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserInfoRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UserInfoReply packet</summary>
    public class UserInfoReplyPacket : Packet
    {
        /// <summary>UserData block</summary>
        public class UserDataBlock
        {
            private byte[] _email;
            /// <summary>EMail field</summary>
            public byte[] EMail
            {
                get { return _email; }
                set
                {
                    if (value == null) { _email = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _email = new byte[value.Length]; Array.Copy(value, _email, value.Length); }
                }
            }
            /// <summary>IMViaEMail field</summary>
            public bool IMViaEMail;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (EMail != null) { length += 2 + EMail.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _email = new byte[length];
                    Array.Copy(bytes, i, _email, 0, length); i += length;
                    IMViaEMail = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(EMail.Length % 256);
                bytes[i++] = (byte)((EMail.Length >> 8) % 256);
                Array.Copy(EMail, 0, bytes, i, EMail.Length); i += EMail.Length;
                bytes[i++] = (byte)((IMViaEMail) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UserInfoReply</summary>
        public override PacketType Type { get { return PacketType.UserInfoReply; } }
        /// <summary>UserData block</summary>
        public UserDataBlock UserData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UserInfoReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 480;
            Header.Reliable = true;
            UserData = new UserDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UserInfoReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            UserData = new UserDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UserInfoReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            UserData = new UserDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += UserData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            UserData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>UpdateUserInfo packet</summary>
    public class UpdateUserInfoPacket : Packet
    {
        /// <summary>UserData block</summary>
        public class UserDataBlock
        {
            /// <summary>IMViaEMail field</summary>
            public bool IMViaEMail;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public UserDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public UserDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IMViaEMail = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((IMViaEMail) ? 1 : 0);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.UpdateUserInfo</summary>
        public override PacketType Type { get { return PacketType.UpdateUserInfo; } }
        /// <summary>UserData block</summary>
        public UserDataBlock UserData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public UpdateUserInfoPacket()
        {
            Header = new LowHeader();
            Header.ID = 481;
            Header.Reliable = true;
            UserData = new UserDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public UpdateUserInfoPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            UserData = new UserDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public UpdateUserInfoPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            UserData = new UserDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += UserData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            UserData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GodExpungeUser packet</summary>
    public class GodExpungeUserPacket : Packet
    {
        /// <summary>ExpungeData block</summary>
        public class ExpungeDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ExpungeDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ExpungeDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GodExpungeUser</summary>
        public override PacketType Type { get { return PacketType.GodExpungeUser; } }
        /// <summary>ExpungeData block</summary>
        public ExpungeDataBlock[] ExpungeData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public GodExpungeUserPacket()
        {
            Header = new LowHeader();
            Header.ID = 482;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ExpungeData = new ExpungeDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GodExpungeUserPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ExpungeData = new ExpungeDataBlock[count];
            for (int j = 0; j < count; j++)
            { ExpungeData[j] = new ExpungeDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GodExpungeUserPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ExpungeData = new ExpungeDataBlock[count];
            for (int j = 0; j < count; j++)
            { ExpungeData[j] = new ExpungeDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < ExpungeData.Length; j++) { length += ExpungeData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ExpungeData.Length;
            for (int j = 0; j < ExpungeData.Length; j++) { ExpungeData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartExpungeProcess packet</summary>
    public class StartExpungeProcessPacket : Packet
    {
        /// <summary>ExpungeData block</summary>
        public class ExpungeDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ExpungeDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ExpungeDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartExpungeProcess</summary>
        public override PacketType Type { get { return PacketType.StartExpungeProcess; } }
        /// <summary>ExpungeData block</summary>
        public ExpungeDataBlock[] ExpungeData;

        /// <summary>Default constructor</summary>
        public StartExpungeProcessPacket()
        {
            Header = new LowHeader();
            Header.ID = 483;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ExpungeData = new ExpungeDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartExpungeProcessPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ExpungeData = new ExpungeDataBlock[count];
            for (int j = 0; j < count; j++)
            { ExpungeData[j] = new ExpungeDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartExpungeProcessPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ExpungeData = new ExpungeDataBlock[count];
            for (int j = 0; j < count; j++)
            { ExpungeData[j] = new ExpungeDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ExpungeData.Length; j++) { length += ExpungeData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ExpungeData.Length;
            for (int j = 0; j < ExpungeData.Length; j++) { ExpungeData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartExpungeProcessAck packet</summary>
    public class StartExpungeProcessAckPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartExpungeProcessAck</summary>
        public override PacketType Type { get { return PacketType.StartExpungeProcessAck; } }

        /// <summary>Default constructor</summary>
        public StartExpungeProcessAckPacket()
        {
            Header = new LowHeader();
            Header.ID = 484;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartExpungeProcessAckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartExpungeProcessAckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartParcelRename packet</summary>
    public class StartParcelRenamePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            private byte[] _newname;
            /// <summary>NewName field</summary>
            public byte[] NewName
            {
                get { return _newname; }
                set
                {
                    if (value == null) { _newname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _newname = new byte[value.Length]; Array.Copy(value, _newname, value.Length); }
                }
            }
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (NewName != null) { length += 1 + NewName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _newname = new byte[length];
                    Array.Copy(bytes, i, _newname, 0, length); i += length;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)NewName.Length;
                Array.Copy(NewName, 0, bytes, i, NewName.Length); i += NewName.Length;
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartParcelRename</summary>
        public override PacketType Type { get { return PacketType.StartParcelRename; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public StartParcelRenamePacket()
        {
            Header = new LowHeader();
            Header.ID = 485;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartParcelRenamePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartParcelRenamePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartParcelRenameAck packet</summary>
    public class StartParcelRenameAckPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartParcelRenameAck</summary>
        public override PacketType Type { get { return PacketType.StartParcelRenameAck; } }

        /// <summary>Default constructor</summary>
        public StartParcelRenameAckPacket()
        {
            Header = new LowHeader();
            Header.ID = 486;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartParcelRenameAckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartParcelRenameAckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>BulkParcelRename packet</summary>
    public class BulkParcelRenamePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            private byte[] _newname;
            /// <summary>NewName field</summary>
            public byte[] NewName
            {
                get { return _newname; }
                set
                {
                    if (value == null) { _newname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _newname = new byte[value.Length]; Array.Copy(value, _newname, value.Length); }
                }
            }
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    if (NewName != null) { length += 1 + NewName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _newname = new byte[length];
                    Array.Copy(bytes, i, _newname, 0, length); i += length;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)NewName.Length;
                Array.Copy(NewName, 0, bytes, i, NewName.Length); i += NewName.Length;
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.BulkParcelRename</summary>
        public override PacketType Type { get { return PacketType.BulkParcelRename; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public BulkParcelRenamePacket()
        {
            Header = new LowHeader();
            Header.ID = 487;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public BulkParcelRenamePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public BulkParcelRenamePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelRename packet</summary>
    public class ParcelRenamePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            private byte[] _newname;
            /// <summary>NewName field</summary>
            public byte[] NewName
            {
                get { return _newname; }
                set
                {
                    if (value == null) { _newname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _newname = new byte[value.Length]; Array.Copy(value, _newname, value.Length); }
                }
            }
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (NewName != null) { length += 1 + NewName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _newname = new byte[length];
                    Array.Copy(bytes, i, _newname, 0, length); i += length;
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)NewName.Length;
                Array.Copy(NewName, 0, bytes, i, NewName.Length); i += NewName.Length;
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelRename</summary>
        public override PacketType Type { get { return PacketType.ParcelRename; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public ParcelRenamePacket()
        {
            Header = new LowHeader();
            Header.ID = 488;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelRenamePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelRenamePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartParcelRemove packet</summary>
    public class StartParcelRemovePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartParcelRemove</summary>
        public override PacketType Type { get { return PacketType.StartParcelRemove; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public StartParcelRemovePacket()
        {
            Header = new LowHeader();
            Header.ID = 489;
            Header.Reliable = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartParcelRemovePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartParcelRemovePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartParcelRemoveAck packet</summary>
    public class StartParcelRemoveAckPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartParcelRemoveAck</summary>
        public override PacketType Type { get { return PacketType.StartParcelRemoveAck; } }

        /// <summary>Default constructor</summary>
        public StartParcelRemoveAckPacket()
        {
            Header = new LowHeader();
            Header.ID = 490;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartParcelRemoveAckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartParcelRemoveAckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>BulkParcelRemove packet</summary>
    public class BulkParcelRemovePacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ParcelID field</summary>
            public LLUUID ParcelID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParcelID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ParcelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.BulkParcelRemove</summary>
        public override PacketType Type { get { return PacketType.BulkParcelRemove; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock[] ParcelData;

        /// <summary>Default constructor</summary>
        public BulkParcelRemovePacket()
        {
            Header = new LowHeader();
            Header.ID = 491;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public BulkParcelRemovePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public BulkParcelRemovePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ParcelData = new ParcelDataBlock[count];
            for (int j = 0; j < count; j++)
            { ParcelData[j] = new ParcelDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < ParcelData.Length; j++) { length += ParcelData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParcelData.Length;
            for (int j = 0; j < ParcelData.Length; j++) { ParcelData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InitiateUpload packet</summary>
    public class InitiateUploadPacket : Packet
    {
        /// <summary>FileData block</summary>
        public class FileDataBlock
        {
            private byte[] _sourcefilename;
            /// <summary>SourceFilename field</summary>
            public byte[] SourceFilename
            {
                get { return _sourcefilename; }
                set
                {
                    if (value == null) { _sourcefilename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _sourcefilename = new byte[value.Length]; Array.Copy(value, _sourcefilename, value.Length); }
                }
            }
            private byte[] _basefilename;
            /// <summary>BaseFilename field</summary>
            public byte[] BaseFilename
            {
                get { return _basefilename; }
                set
                {
                    if (value == null) { _basefilename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _basefilename = new byte[value.Length]; Array.Copy(value, _basefilename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (SourceFilename != null) { length += 1 + SourceFilename.Length; }
                    if (BaseFilename != null) { length += 1 + BaseFilename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FileDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FileDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _sourcefilename = new byte[length];
                    Array.Copy(bytes, i, _sourcefilename, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _basefilename = new byte[length];
                    Array.Copy(bytes, i, _basefilename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SourceFilename.Length;
                Array.Copy(SourceFilename, 0, bytes, i, SourceFilename.Length); i += SourceFilename.Length;
                bytes[i++] = (byte)BaseFilename.Length;
                Array.Copy(BaseFilename, 0, bytes, i, BaseFilename.Length); i += BaseFilename.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InitiateUpload</summary>
        public override PacketType Type { get { return PacketType.InitiateUpload; } }
        /// <summary>FileData block</summary>
        public FileDataBlock FileData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public InitiateUploadPacket()
        {
            Header = new LowHeader();
            Header.ID = 492;
            Header.Reliable = true;
            FileData = new FileDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InitiateUploadPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            FileData = new FileDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InitiateUploadPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            FileData = new FileDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += FileData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            FileData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InitiateDownload packet</summary>
    public class InitiateDownloadPacket : Packet
    {
        /// <summary>FileData block</summary>
        public class FileDataBlock
        {
            private byte[] _simfilename;
            /// <summary>SimFilename field</summary>
            public byte[] SimFilename
            {
                get { return _simfilename; }
                set
                {
                    if (value == null) { _simfilename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _simfilename = new byte[value.Length]; Array.Copy(value, _simfilename, value.Length); }
                }
            }
            private byte[] _viewerfilename;
            /// <summary>ViewerFilename field</summary>
            public byte[] ViewerFilename
            {
                get { return _viewerfilename; }
                set
                {
                    if (value == null) { _viewerfilename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _viewerfilename = new byte[value.Length]; Array.Copy(value, _viewerfilename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (SimFilename != null) { length += 1 + SimFilename.Length; }
                    if (ViewerFilename != null) { length += 1 + ViewerFilename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public FileDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public FileDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _simfilename = new byte[length];
                    Array.Copy(bytes, i, _simfilename, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _viewerfilename = new byte[length];
                    Array.Copy(bytes, i, _viewerfilename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)SimFilename.Length;
                Array.Copy(SimFilename, 0, bytes, i, SimFilename.Length); i += SimFilename.Length;
                bytes[i++] = (byte)ViewerFilename.Length;
                Array.Copy(ViewerFilename, 0, bytes, i, ViewerFilename.Length); i += ViewerFilename.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InitiateDownload</summary>
        public override PacketType Type { get { return PacketType.InitiateDownload; } }
        /// <summary>FileData block</summary>
        public FileDataBlock FileData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public InitiateDownloadPacket()
        {
            Header = new LowHeader();
            Header.ID = 493;
            Header.Reliable = true;
            FileData = new FileDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InitiateDownloadPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            FileData = new FileDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InitiateDownloadPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            FileData = new FileDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += FileData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            FileData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SystemMessage packet</summary>
    public class SystemMessagePacket : Packet
    {
        /// <summary>MethodData block</summary>
        public class MethodDataBlock
        {
            /// <summary>Invoice field</summary>
            public LLUUID Invoice;
            /// <summary>Digest field</summary>
            public byte[] Digest;
            private byte[] _method;
            /// <summary>Method field</summary>
            public byte[] Method
            {
                get { return _method; }
                set
                {
                    if (value == null) { _method = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _method = new byte[value.Length]; Array.Copy(value, _method, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    if (Method != null) { length += 1 + Method.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public MethodDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public MethodDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    Invoice = new LLUUID(bytes, i); i += 16;
                    Digest = new byte[32];
                    Array.Copy(bytes, i, Digest, 0, 32); i += 32;
                    length = (ushort)bytes[i++];
                    _method = new byte[length];
                    Array.Copy(bytes, i, _method, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Invoice.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Digest, 0, bytes, i, 32);i += 32;
                bytes[i++] = (byte)Method.Length;
                Array.Copy(Method, 0, bytes, i, Method.Length); i += Method.Length;
            }
        }

        /// <summary>ParamList block</summary>
        public class ParamListBlock
        {
            private byte[] _parameter;
            /// <summary>Parameter field</summary>
            public byte[] Parameter
            {
                get { return _parameter; }
                set
                {
                    if (value == null) { _parameter = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _parameter = new byte[value.Length]; Array.Copy(value, _parameter, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Parameter != null) { length += 1 + Parameter.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParamListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParamListBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _parameter = new byte[length];
                    Array.Copy(bytes, i, _parameter, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Parameter.Length;
                Array.Copy(Parameter, 0, bytes, i, Parameter.Length); i += Parameter.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SystemMessage</summary>
        public override PacketType Type { get { return PacketType.SystemMessage; } }
        /// <summary>MethodData block</summary>
        public MethodDataBlock MethodData;
        /// <summary>ParamList block</summary>
        public ParamListBlock[] ParamList;

        /// <summary>Default constructor</summary>
        public SystemMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 494;
            Header.Reliable = true;
            Header.Zerocoded = true;
            MethodData = new MethodDataBlock();
            ParamList = new ParamListBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SystemMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SystemMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            MethodData = new MethodDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ParamList = new ParamListBlock[count];
            for (int j = 0; j < count; j++)
            { ParamList[j] = new ParamListBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += MethodData.Length;;
            for (int j = 0; j < ParamList.Length; j++) { length += ParamList[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            MethodData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ParamList.Length;
            for (int j = 0; j < ParamList.Length; j++) { ParamList[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MapLayerRequest packet</summary>
    public class MapLayerRequestPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MapLayerRequest</summary>
        public override PacketType Type { get { return PacketType.MapLayerRequest; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MapLayerRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 495;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MapLayerRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MapLayerRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MapLayerReply packet</summary>
    public class MapLayerReplyPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        /// <summary>LayerData block</summary>
        public class LayerDataBlock
        {
            /// <summary>Top field</summary>
            public uint Top;
            /// <summary>ImageID field</summary>
            public LLUUID ImageID;
            /// <summary>Left field</summary>
            public uint Left;
            /// <summary>Bottom field</summary>
            public uint Bottom;
            /// <summary>Right field</summary>
            public uint Right;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public LayerDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public LayerDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Top = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ImageID = new LLUUID(bytes, i); i += 16;
                    Left = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Bottom = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Right = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Top % 256);
                bytes[i++] = (byte)((Top >> 8) % 256);
                bytes[i++] = (byte)((Top >> 16) % 256);
                bytes[i++] = (byte)((Top >> 24) % 256);
                Array.Copy(ImageID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Left % 256);
                bytes[i++] = (byte)((Left >> 8) % 256);
                bytes[i++] = (byte)((Left >> 16) % 256);
                bytes[i++] = (byte)((Left >> 24) % 256);
                bytes[i++] = (byte)(Bottom % 256);
                bytes[i++] = (byte)((Bottom >> 8) % 256);
                bytes[i++] = (byte)((Bottom >> 16) % 256);
                bytes[i++] = (byte)((Bottom >> 24) % 256);
                bytes[i++] = (byte)(Right % 256);
                bytes[i++] = (byte)((Right >> 8) % 256);
                bytes[i++] = (byte)((Right >> 16) % 256);
                bytes[i++] = (byte)((Right >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MapLayerReply</summary>
        public override PacketType Type { get { return PacketType.MapLayerReply; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>LayerData block</summary>
        public LayerDataBlock[] LayerData;

        /// <summary>Default constructor</summary>
        public MapLayerReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 496;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
            LayerData = new LayerDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MapLayerReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            LayerData = new LayerDataBlock[count];
            for (int j = 0; j < count; j++)
            { LayerData[j] = new LayerDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MapLayerReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            LayerData = new LayerDataBlock[count];
            for (int j = 0; j < count; j++)
            { LayerData[j] = new LayerDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < LayerData.Length; j++) { length += LayerData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)LayerData.Length;
            for (int j = 0; j < LayerData.Length; j++) { LayerData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MapBlockRequest packet</summary>
    public class MapBlockRequestPacket : Packet
    {
        /// <summary>PositionData block</summary>
        public class PositionDataBlock
        {
            /// <summary>MaxX field</summary>
            public ushort MaxX;
            /// <summary>MaxY field</summary>
            public ushort MaxY;
            /// <summary>MinX field</summary>
            public ushort MinX;
            /// <summary>MinY field</summary>
            public ushort MinY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PositionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PositionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    MaxX = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    MaxY = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    MinX = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    MinY = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(MaxX % 256);
                bytes[i++] = (byte)((MaxX >> 8) % 256);
                bytes[i++] = (byte)(MaxY % 256);
                bytes[i++] = (byte)((MaxY >> 8) % 256);
                bytes[i++] = (byte)(MinX % 256);
                bytes[i++] = (byte)((MinX >> 8) % 256);
                bytes[i++] = (byte)(MinY % 256);
                bytes[i++] = (byte)((MinY >> 8) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MapBlockRequest</summary>
        public override PacketType Type { get { return PacketType.MapBlockRequest; } }
        /// <summary>PositionData block</summary>
        public PositionDataBlock PositionData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MapBlockRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 497;
            Header.Reliable = true;
            PositionData = new PositionDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MapBlockRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            PositionData = new PositionDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MapBlockRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PositionData = new PositionDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += PositionData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PositionData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MapNameRequest packet</summary>
    public class MapNameRequestPacket : Packet
    {
        /// <summary>NameData block</summary>
        public class NameDataBlock
        {
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NameDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NameDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MapNameRequest</summary>
        public override PacketType Type { get { return PacketType.MapNameRequest; } }
        /// <summary>NameData block</summary>
        public NameDataBlock NameData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MapNameRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 498;
            Header.Reliable = true;
            NameData = new NameDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MapNameRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            NameData = new NameDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MapNameRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            NameData = new NameDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += NameData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            NameData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MapBlockReply packet</summary>
    public class MapBlockReplyPacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>X field</summary>
            public ushort X;
            /// <summary>Y field</summary>
            public ushort Y;
            /// <summary>RegionFlags field</summary>
            public uint RegionFlags;
            /// <summary>WaterHeight field</summary>
            public byte WaterHeight;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Access field</summary>
            public byte Access;
            /// <summary>MapImageID field</summary>
            public LLUUID MapImageID;
            /// <summary>Agents field</summary>
            public byte Agents;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    X = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Y = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    WaterHeight = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Access = (byte)bytes[i++];
                    MapImageID = new LLUUID(bytes, i); i += 16;
                    Agents = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(X % 256);
                bytes[i++] = (byte)((X >> 8) % 256);
                bytes[i++] = (byte)(Y % 256);
                bytes[i++] = (byte)((Y >> 8) % 256);
                bytes[i++] = (byte)(RegionFlags % 256);
                bytes[i++] = (byte)((RegionFlags >> 8) % 256);
                bytes[i++] = (byte)((RegionFlags >> 16) % 256);
                bytes[i++] = (byte)((RegionFlags >> 24) % 256);
                bytes[i++] = WaterHeight;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = Access;
                Array.Copy(MapImageID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Agents;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MapBlockReply</summary>
        public override PacketType Type { get { return PacketType.MapBlockReply; } }
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MapBlockReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 499;
            Header.Reliable = true;
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MapBlockReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MapBlockReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MapItemRequest packet</summary>
    public class MapItemRequestPacket : Packet
    {
        /// <summary>RequestData block</summary>
        public class RequestDataBlock
        {
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>ItemType field</summary>
            public uint ItemType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    ItemType = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(ItemType % 256);
                bytes[i++] = (byte)((ItemType >> 8) % 256);
                bytes[i++] = (byte)((ItemType >> 16) % 256);
                bytes[i++] = (byte)((ItemType >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Godlike field</summary>
            public bool Godlike;
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>EstateID field</summary>
            public uint EstateID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 25;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Godlike = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    EstateID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((Godlike) ? 1 : 0);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(EstateID % 256);
                bytes[i++] = (byte)((EstateID >> 8) % 256);
                bytes[i++] = (byte)((EstateID >> 16) % 256);
                bytes[i++] = (byte)((EstateID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MapItemRequest</summary>
        public override PacketType Type { get { return PacketType.MapItemRequest; } }
        /// <summary>RequestData block</summary>
        public RequestDataBlock RequestData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MapItemRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 500;
            Header.Reliable = true;
            RequestData = new RequestDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MapItemRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestData = new RequestDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MapItemRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestData = new RequestDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MapItemReply packet</summary>
    public class MapItemReplyPacket : Packet
    {
        /// <summary>RequestData block</summary>
        public class RequestDataBlock
        {
            /// <summary>ItemType field</summary>
            public uint ItemType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ItemType = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ItemType % 256);
                bytes[i++] = (byte)((ItemType >> 8) % 256);
                bytes[i++] = (byte)((ItemType >> 16) % 256);
                bytes[i++] = (byte)((ItemType >> 24) % 256);
            }
        }

        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>X field</summary>
            public uint X;
            /// <summary>Y field</summary>
            public uint Y;
            /// <summary>ID field</summary>
            public LLUUID ID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Extra2 field</summary>
            public int Extra2;
            /// <summary>Extra field</summary>
            public int Extra;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    X = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Y = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Extra2 = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Extra = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(X % 256);
                bytes[i++] = (byte)((X >> 8) % 256);
                bytes[i++] = (byte)((X >> 16) % 256);
                bytes[i++] = (byte)((X >> 24) % 256);
                bytes[i++] = (byte)(Y % 256);
                bytes[i++] = (byte)((Y >> 8) % 256);
                bytes[i++] = (byte)((Y >> 16) % 256);
                bytes[i++] = (byte)((Y >> 24) % 256);
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Extra2 % 256);
                bytes[i++] = (byte)((Extra2 >> 8) % 256);
                bytes[i++] = (byte)((Extra2 >> 16) % 256);
                bytes[i++] = (byte)((Extra2 >> 24) % 256);
                bytes[i++] = (byte)(Extra % 256);
                bytes[i++] = (byte)((Extra >> 8) % 256);
                bytes[i++] = (byte)((Extra >> 16) % 256);
                bytes[i++] = (byte)((Extra >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MapItemReply</summary>
        public override PacketType Type { get { return PacketType.MapItemReply; } }
        /// <summary>RequestData block</summary>
        public RequestDataBlock RequestData;
        /// <summary>Data block</summary>
        public DataBlock[] Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MapItemReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 501;
            Header.Reliable = true;
            RequestData = new RequestDataBlock();
            Data = new DataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MapItemReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestData = new RequestDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MapItemReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestData = new RequestDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            Data = new DataBlock[count];
            for (int j = 0; j < count; j++)
            { Data[j] = new DataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestData.Length;            length += AgentData.Length;;
            for (int j = 0; j < Data.Length; j++) { length += Data[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Data.Length;
            for (int j = 0; j < Data.Length; j++) { Data[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SendPostcard packet</summary>
    public class SendPostcardPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            private byte[] _to;
            /// <summary>To field</summary>
            public byte[] To
            {
                get { return _to; }
                set
                {
                    if (value == null) { _to = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _to = new byte[value.Length]; Array.Copy(value, _to, value.Length); }
                }
            }
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            private byte[] _msg;
            /// <summary>Msg field</summary>
            public byte[] Msg
            {
                get { return _msg; }
                set
                {
                    if (value == null) { _msg = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _msg = new byte[value.Length]; Array.Copy(value, _msg, value.Length); }
                }
            }
            /// <summary>AllowPublish field</summary>
            public bool AllowPublish;
            /// <summary>PosGlobal field</summary>
            public LLVector3d PosGlobal;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            private byte[] _subject;
            /// <summary>Subject field</summary>
            public byte[] Subject
            {
                get { return _subject; }
                set
                {
                    if (value == null) { _subject = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _subject = new byte[value.Length]; Array.Copy(value, _subject, value.Length); }
                }
            }
            private byte[] _from;
            /// <summary>From field</summary>
            public byte[] From
            {
                get { return _from; }
                set
                {
                    if (value == null) { _from = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _from = new byte[value.Length]; Array.Copy(value, _from, value.Length); }
                }
            }
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>MaturePublish field</summary>
            public bool MaturePublish;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 58;
                    if (To != null) { length += 1 + To.Length; }
                    if (Msg != null) { length += 2 + Msg.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Subject != null) { length += 1 + Subject.Length; }
                    if (From != null) { length += 1 + From.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _to = new byte[length];
                    Array.Copy(bytes, i, _to, 0, length); i += length;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _msg = new byte[length];
                    Array.Copy(bytes, i, _msg, 0, length); i += length;
                    AllowPublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    PosGlobal = new LLVector3d(bytes, i); i += 24;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _subject = new byte[length];
                    Array.Copy(bytes, i, _subject, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _from = new byte[length];
                    Array.Copy(bytes, i, _from, 0, length); i += length;
                    AssetID = new LLUUID(bytes, i); i += 16;
                    MaturePublish = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)To.Length;
                Array.Copy(To, 0, bytes, i, To.Length); i += To.Length;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Msg.Length % 256);
                bytes[i++] = (byte)((Msg.Length >> 8) % 256);
                Array.Copy(Msg, 0, bytes, i, Msg.Length); i += Msg.Length;
                bytes[i++] = (byte)((AllowPublish) ? 1 : 0);
                Array.Copy(PosGlobal.GetBytes(), 0, bytes, i, 24); i += 24;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)Subject.Length;
                Array.Copy(Subject, 0, bytes, i, Subject.Length); i += Subject.Length;
                bytes[i++] = (byte)From.Length;
                Array.Copy(From, 0, bytes, i, From.Length); i += From.Length;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((MaturePublish) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SendPostcard</summary>
        public override PacketType Type { get { return PacketType.SendPostcard; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public SendPostcardPacket()
        {
            Header = new LowHeader();
            Header.ID = 502;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SendPostcardPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SendPostcardPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RpcChannelRequest packet</summary>
    public class RpcChannelRequestPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>GridX field</summary>
            public uint GridX;
            /// <summary>GridY field</summary>
            public uint GridY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 40;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TaskID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    GridX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(GridX % 256);
                bytes[i++] = (byte)((GridX >> 8) % 256);
                bytes[i++] = (byte)((GridX >> 16) % 256);
                bytes[i++] = (byte)((GridX >> 24) % 256);
                bytes[i++] = (byte)(GridY % 256);
                bytes[i++] = (byte)((GridY >> 8) % 256);
                bytes[i++] = (byte)((GridY >> 16) % 256);
                bytes[i++] = (byte)((GridY >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RpcChannelRequest</summary>
        public override PacketType Type { get { return PacketType.RpcChannelRequest; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public RpcChannelRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 503;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RpcChannelRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RpcChannelRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RpcChannelReply packet</summary>
    public class RpcChannelReplyPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>ChannelID field</summary>
            public LLUUID ChannelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TaskID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    ChannelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ChannelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RpcChannelReply</summary>
        public override PacketType Type { get { return PacketType.RpcChannelReply; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public RpcChannelReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 504;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RpcChannelReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RpcChannelReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RpcScriptRequestInbound packet</summary>
    public class RpcScriptRequestInboundPacket : Packet
    {
        /// <summary>TargetBlock block</summary>
        public class TargetBlockBlock
        {
            /// <summary>GridX field</summary>
            public uint GridX;
            /// <summary>GridY field</summary>
            public uint GridY;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 8;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TargetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TargetBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GridX = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GridY = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(GridX % 256);
                bytes[i++] = (byte)((GridX >> 8) % 256);
                bytes[i++] = (byte)((GridX >> 16) % 256);
                bytes[i++] = (byte)((GridX >> 24) % 256);
                bytes[i++] = (byte)(GridY % 256);
                bytes[i++] = (byte)((GridY >> 8) % 256);
                bytes[i++] = (byte)((GridY >> 16) % 256);
                bytes[i++] = (byte)((GridY >> 24) % 256);
            }
        }

        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            private byte[] _stringvalue;
            /// <summary>StringValue field</summary>
            public byte[] StringValue
            {
                get { return _stringvalue; }
                set
                {
                    if (value == null) { _stringvalue = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _stringvalue = new byte[value.Length]; Array.Copy(value, _stringvalue, value.Length); }
                }
            }
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>IntValue field</summary>
            public uint IntValue;
            /// <summary>ChannelID field</summary>
            public LLUUID ChannelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 52;
                    if (StringValue != null) { length += 2 + StringValue.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _stringvalue = new byte[length];
                    Array.Copy(bytes, i, _stringvalue, 0, length); i += length;
                    TaskID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    IntValue = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ChannelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(StringValue.Length % 256);
                bytes[i++] = (byte)((StringValue.Length >> 8) % 256);
                Array.Copy(StringValue, 0, bytes, i, StringValue.Length); i += StringValue.Length;
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntValue % 256);
                bytes[i++] = (byte)((IntValue >> 8) % 256);
                bytes[i++] = (byte)((IntValue >> 16) % 256);
                bytes[i++] = (byte)((IntValue >> 24) % 256);
                Array.Copy(ChannelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RpcScriptRequestInbound</summary>
        public override PacketType Type { get { return PacketType.RpcScriptRequestInbound; } }
        /// <summary>TargetBlock block</summary>
        public TargetBlockBlock TargetBlock;
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public RpcScriptRequestInboundPacket()
        {
            Header = new LowHeader();
            Header.ID = 505;
            Header.Reliable = true;
            TargetBlock = new TargetBlockBlock();
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RpcScriptRequestInboundPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RpcScriptRequestInboundPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TargetBlock.Length;            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TargetBlock.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RpcScriptRequestInboundForward packet</summary>
    public class RpcScriptRequestInboundForwardPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>RPCServerIP field</summary>
            public uint RPCServerIP;
            private byte[] _stringvalue;
            /// <summary>StringValue field</summary>
            public byte[] StringValue
            {
                get { return _stringvalue; }
                set
                {
                    if (value == null) { _stringvalue = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _stringvalue = new byte[value.Length]; Array.Copy(value, _stringvalue, value.Length); }
                }
            }
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>IntValue field</summary>
            public uint IntValue;
            /// <summary>ChannelID field</summary>
            public LLUUID ChannelID;
            /// <summary>RPCServerPort field</summary>
            public ushort RPCServerPort;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 58;
                    if (StringValue != null) { length += 2 + StringValue.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RPCServerIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _stringvalue = new byte[length];
                    Array.Copy(bytes, i, _stringvalue, 0, length); i += length;
                    TaskID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    IntValue = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ChannelID = new LLUUID(bytes, i); i += 16;
                    RPCServerPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RPCServerIP % 256);
                bytes[i++] = (byte)((RPCServerIP >> 8) % 256);
                bytes[i++] = (byte)((RPCServerIP >> 16) % 256);
                bytes[i++] = (byte)((RPCServerIP >> 24) % 256);
                bytes[i++] = (byte)(StringValue.Length % 256);
                bytes[i++] = (byte)((StringValue.Length >> 8) % 256);
                Array.Copy(StringValue, 0, bytes, i, StringValue.Length); i += StringValue.Length;
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntValue % 256);
                bytes[i++] = (byte)((IntValue >> 8) % 256);
                bytes[i++] = (byte)((IntValue >> 16) % 256);
                bytes[i++] = (byte)((IntValue >> 24) % 256);
                Array.Copy(ChannelID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RPCServerPort % 256);
                bytes[i++] = (byte)((RPCServerPort >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RpcScriptRequestInboundForward</summary>
        public override PacketType Type { get { return PacketType.RpcScriptRequestInboundForward; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public RpcScriptRequestInboundForwardPacket()
        {
            Header = new LowHeader();
            Header.ID = 506;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RpcScriptRequestInboundForwardPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RpcScriptRequestInboundForwardPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RpcScriptReplyInbound packet</summary>
    public class RpcScriptReplyInboundPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            private byte[] _stringvalue;
            /// <summary>StringValue field</summary>
            public byte[] StringValue
            {
                get { return _stringvalue; }
                set
                {
                    if (value == null) { _stringvalue = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _stringvalue = new byte[value.Length]; Array.Copy(value, _stringvalue, value.Length); }
                }
            }
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>IntValue field</summary>
            public uint IntValue;
            /// <summary>ChannelID field</summary>
            public LLUUID ChannelID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 52;
                    if (StringValue != null) { length += 2 + StringValue.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _stringvalue = new byte[length];
                    Array.Copy(bytes, i, _stringvalue, 0, length); i += length;
                    TaskID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    IntValue = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ChannelID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(StringValue.Length % 256);
                bytes[i++] = (byte)((StringValue.Length >> 8) % 256);
                Array.Copy(StringValue, 0, bytes, i, StringValue.Length); i += StringValue.Length;
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(IntValue % 256);
                bytes[i++] = (byte)((IntValue >> 8) % 256);
                bytes[i++] = (byte)((IntValue >> 16) % 256);
                bytes[i++] = (byte)((IntValue >> 24) % 256);
                Array.Copy(ChannelID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RpcScriptReplyInbound</summary>
        public override PacketType Type { get { return PacketType.RpcScriptReplyInbound; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public RpcScriptReplyInboundPacket()
        {
            Header = new LowHeader();
            Header.ID = 507;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RpcScriptReplyInboundPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RpcScriptReplyInboundPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MailTaskSimRequest packet</summary>
    public class MailTaskSimRequestPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TaskID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MailTaskSimRequest</summary>
        public override PacketType Type { get { return PacketType.MailTaskSimRequest; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public MailTaskSimRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 508;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MailTaskSimRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MailTaskSimRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MailTaskSimReply packet</summary>
    public class MailTaskSimReplyPacket : Packet
    {
        /// <summary>TargetBlock block</summary>
        public class TargetBlockBlock
        {
            private byte[] _targetip;
            /// <summary>TargetIP field</summary>
            public byte[] TargetIP
            {
                get { return _targetip; }
                set
                {
                    if (value == null) { _targetip = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _targetip = new byte[value.Length]; Array.Copy(value, _targetip, value.Length); }
                }
            }
            /// <summary>TargetPort field</summary>
            public ushort TargetPort;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    if (TargetIP != null) { length += 1 + TargetIP.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TargetBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TargetBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _targetip = new byte[length];
                    Array.Copy(bytes, i, _targetip, 0, length); i += length;
                    TargetPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)TargetIP.Length;
                Array.Copy(TargetIP, 0, bytes, i, TargetIP.Length); i += TargetIP.Length;
                bytes[i++] = (byte)(TargetPort % 256);
                bytes[i++] = (byte)((TargetPort >> 8) % 256);
            }
        }

        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TaskID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MailTaskSimReply</summary>
        public override PacketType Type { get { return PacketType.MailTaskSimReply; } }
        /// <summary>TargetBlock block</summary>
        public TargetBlockBlock TargetBlock;
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public MailTaskSimReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 509;
            Header.Reliable = true;
            TargetBlock = new TargetBlockBlock();
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MailTaskSimReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MailTaskSimReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TargetBlock = new TargetBlockBlock(bytes, ref i);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TargetBlock.Length;            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TargetBlock.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ScriptMailRegistration packet</summary>
    public class ScriptMailRegistrationPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            private byte[] _targetip;
            /// <summary>TargetIP field</summary>
            public byte[] TargetIP
            {
                get { return _targetip; }
                set
                {
                    if (value == null) { _targetip = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _targetip = new byte[value.Length]; Array.Copy(value, _targetip, value.Length); }
                }
            }
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>TargetPort field</summary>
            public ushort TargetPort;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 22;
                    if (TargetIP != null) { length += 1 + TargetIP.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _targetip = new byte[length];
                    Array.Copy(bytes, i, _targetip, 0, length); i += length;
                    TaskID = new LLUUID(bytes, i); i += 16;
                    TargetPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)TargetIP.Length;
                Array.Copy(TargetIP, 0, bytes, i, TargetIP.Length); i += TargetIP.Length;
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TargetPort % 256);
                bytes[i++] = (byte)((TargetPort >> 8) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ScriptMailRegistration</summary>
        public override PacketType Type { get { return PacketType.ScriptMailRegistration; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public ScriptMailRegistrationPacket()
        {
            Header = new LowHeader();
            Header.ID = 510;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ScriptMailRegistrationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ScriptMailRegistrationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MailPingBounce packet</summary>
    public class MailPingBouncePacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>TargetIP field</summary>
            public uint TargetIP;
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>TargetPort field</summary>
            public ushort TargetPort;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TaskID = new LLUUID(bytes, i); i += 16;
                    TargetPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TargetIP % 256);
                bytes[i++] = (byte)((TargetIP >> 8) % 256);
                bytes[i++] = (byte)((TargetIP >> 16) % 256);
                bytes[i++] = (byte)((TargetIP >> 24) % 256);
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TargetPort % 256);
                bytes[i++] = (byte)((TargetPort >> 8) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MailPingBounce</summary>
        public override PacketType Type { get { return PacketType.MailPingBounce; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public MailPingBouncePacket()
        {
            Header = new LowHeader();
            Header.ID = 511;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MailPingBouncePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MailPingBouncePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelMediaCommandMessage packet</summary>
    public class ParcelMediaCommandMessagePacket : Packet
    {
        /// <summary>CommandBlock block</summary>
        public class CommandBlockBlock
        {
            /// <summary>Command field</summary>
            public uint Command;
            /// <summary>Time field</summary>
            public float Time;
            /// <summary>Flags field</summary>
            public uint Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public CommandBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public CommandBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Command = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Time = BitConverter.ToSingle(bytes, i); i += 4;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(Command % 256);
                bytes[i++] = (byte)((Command >> 8) % 256);
                bytes[i++] = (byte)((Command >> 16) % 256);
                bytes[i++] = (byte)((Command >> 24) % 256);
                ba = BitConverter.GetBytes(Time);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelMediaCommandMessage</summary>
        public override PacketType Type { get { return PacketType.ParcelMediaCommandMessage; } }
        /// <summary>CommandBlock block</summary>
        public CommandBlockBlock CommandBlock;

        /// <summary>Default constructor</summary>
        public ParcelMediaCommandMessagePacket()
        {
            Header = new LowHeader();
            Header.ID = 512;
            Header.Reliable = true;
            CommandBlock = new CommandBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelMediaCommandMessagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            CommandBlock = new CommandBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelMediaCommandMessagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            CommandBlock = new CommandBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += CommandBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            CommandBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelMediaUpdate packet</summary>
    public class ParcelMediaUpdatePacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>MediaID field</summary>
            public LLUUID MediaID;
            private byte[] _mediaurl;
            /// <summary>MediaURL field</summary>
            public byte[] MediaURL
            {
                get { return _mediaurl; }
                set
                {
                    if (value == null) { _mediaurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mediaurl = new byte[value.Length]; Array.Copy(value, _mediaurl, value.Length); }
                }
            }
            /// <summary>MediaAutoScale field</summary>
            public byte MediaAutoScale;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (MediaURL != null) { length += 1 + MediaURL.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    MediaID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _mediaurl = new byte[length];
                    Array.Copy(bytes, i, _mediaurl, 0, length); i += length;
                    MediaAutoScale = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(MediaID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)MediaURL.Length;
                Array.Copy(MediaURL, 0, bytes, i, MediaURL.Length); i += MediaURL.Length;
                bytes[i++] = MediaAutoScale;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelMediaUpdate</summary>
        public override PacketType Type { get { return PacketType.ParcelMediaUpdate; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public ParcelMediaUpdatePacket()
        {
            Header = new LowHeader();
            Header.ID = 513;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelMediaUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelMediaUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LandStatRequest packet</summary>
    public class LandStatRequestPacket : Packet
    {
        /// <summary>RequestData block</summary>
        public class RequestDataBlock
        {
            /// <summary>RequestFlags field</summary>
            public uint RequestFlags;
            /// <summary>ReportType field</summary>
            public uint ReportType;
            /// <summary>ParcelLocalID field</summary>
            public int ParcelLocalID;
            private byte[] _filter;
            /// <summary>Filter field</summary>
            public byte[] Filter
            {
                get { return _filter; }
                set
                {
                    if (value == null) { _filter = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filter = new byte[value.Length]; Array.Copy(value, _filter, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    if (Filter != null) { length += 1 + Filter.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    RequestFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ReportType = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ParcelLocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _filter = new byte[length];
                    Array.Copy(bytes, i, _filter, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RequestFlags % 256);
                bytes[i++] = (byte)((RequestFlags >> 8) % 256);
                bytes[i++] = (byte)((RequestFlags >> 16) % 256);
                bytes[i++] = (byte)((RequestFlags >> 24) % 256);
                bytes[i++] = (byte)(ReportType % 256);
                bytes[i++] = (byte)((ReportType >> 8) % 256);
                bytes[i++] = (byte)((ReportType >> 16) % 256);
                bytes[i++] = (byte)((ReportType >> 24) % 256);
                bytes[i++] = (byte)(ParcelLocalID % 256);
                bytes[i++] = (byte)((ParcelLocalID >> 8) % 256);
                bytes[i++] = (byte)((ParcelLocalID >> 16) % 256);
                bytes[i++] = (byte)((ParcelLocalID >> 24) % 256);
                bytes[i++] = (byte)Filter.Length;
                Array.Copy(Filter, 0, bytes, i, Filter.Length); i += Filter.Length;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LandStatRequest</summary>
        public override PacketType Type { get { return PacketType.LandStatRequest; } }
        /// <summary>RequestData block</summary>
        public RequestDataBlock RequestData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public LandStatRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 514;
            Header.Reliable = true;
            RequestData = new RequestDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LandStatRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestData = new RequestDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LandStatRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestData = new RequestDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LandStatReply packet</summary>
    public class LandStatReplyPacket : Packet
    {
        /// <summary>RequestData block</summary>
        public class RequestDataBlock
        {
            /// <summary>RequestFlags field</summary>
            public uint RequestFlags;
            /// <summary>ReportType field</summary>
            public uint ReportType;
            /// <summary>TotalObjectCount field</summary>
            public uint TotalObjectCount;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    RequestFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ReportType = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TotalObjectCount = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(RequestFlags % 256);
                bytes[i++] = (byte)((RequestFlags >> 8) % 256);
                bytes[i++] = (byte)((RequestFlags >> 16) % 256);
                bytes[i++] = (byte)((RequestFlags >> 24) % 256);
                bytes[i++] = (byte)(ReportType % 256);
                bytes[i++] = (byte)((ReportType >> 8) % 256);
                bytes[i++] = (byte)((ReportType >> 16) % 256);
                bytes[i++] = (byte)((ReportType >> 24) % 256);
                bytes[i++] = (byte)(TotalObjectCount % 256);
                bytes[i++] = (byte)((TotalObjectCount >> 8) % 256);
                bytes[i++] = (byte)((TotalObjectCount >> 16) % 256);
                bytes[i++] = (byte)((TotalObjectCount >> 24) % 256);
            }
        }

        /// <summary>ReportData block</summary>
        public class ReportDataBlock
        {
            /// <summary>LocationX field</summary>
            public float LocationX;
            /// <summary>LocationY field</summary>
            public float LocationY;
            /// <summary>LocationZ field</summary>
            public float LocationZ;
            private byte[] _taskname;
            /// <summary>TaskName field</summary>
            public byte[] TaskName
            {
                get { return _taskname; }
                set
                {
                    if (value == null) { _taskname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _taskname = new byte[value.Length]; Array.Copy(value, _taskname, value.Length); }
                }
            }
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;
            /// <summary>Score field</summary>
            public float Score;
            /// <summary>TaskLocalID field</summary>
            public uint TaskLocalID;
            private byte[] _ownername;
            /// <summary>OwnerName field</summary>
            public byte[] OwnerName
            {
                get { return _ownername; }
                set
                {
                    if (value == null) { _ownername = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _ownername = new byte[value.Length]; Array.Copy(value, _ownername, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 37;
                    if (TaskName != null) { length += 1 + TaskName.Length; }
                    if (OwnerName != null) { length += 1 + OwnerName.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ReportDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ReportDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    LocationX = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    LocationY = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    LocationZ = BitConverter.ToSingle(bytes, i); i += 4;
                    length = (ushort)bytes[i++];
                    _taskname = new byte[length];
                    Array.Copy(bytes, i, _taskname, 0, length); i += length;
                    TaskID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Score = BitConverter.ToSingle(bytes, i); i += 4;
                    TaskLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _ownername = new byte[length];
                    Array.Copy(bytes, i, _ownername, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(LocationX);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(LocationY);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(LocationZ);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)TaskName.Length;
                Array.Copy(TaskName, 0, bytes, i, TaskName.Length); i += TaskName.Length;
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Score);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(TaskLocalID % 256);
                bytes[i++] = (byte)((TaskLocalID >> 8) % 256);
                bytes[i++] = (byte)((TaskLocalID >> 16) % 256);
                bytes[i++] = (byte)((TaskLocalID >> 24) % 256);
                bytes[i++] = (byte)OwnerName.Length;
                Array.Copy(OwnerName, 0, bytes, i, OwnerName.Length); i += OwnerName.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LandStatReply</summary>
        public override PacketType Type { get { return PacketType.LandStatReply; } }
        /// <summary>RequestData block</summary>
        public RequestDataBlock RequestData;
        /// <summary>ReportData block</summary>
        public ReportDataBlock[] ReportData;

        /// <summary>Default constructor</summary>
        public LandStatReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 515;
            Header.Reliable = true;
            RequestData = new RequestDataBlock();
            ReportData = new ReportDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LandStatReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            RequestData = new RequestDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ReportData = new ReportDataBlock[count];
            for (int j = 0; j < count; j++)
            { ReportData[j] = new ReportDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LandStatReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RequestData = new RequestDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            ReportData = new ReportDataBlock[count];
            for (int j = 0; j < count; j++)
            { ReportData[j] = new ReportDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += RequestData.Length;;
            for (int j = 0; j < ReportData.Length; j++) { length += ReportData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RequestData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ReportData.Length;
            for (int j = 0; j < ReportData.Length; j++) { ReportData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SecuredTemplateChecksumRequest packet</summary>
    public class SecuredTemplateChecksumRequestPacket : Packet
    {
        /// <summary>TokenBlock block</summary>
        public class TokenBlockBlock
        {
            /// <summary>Token field</summary>
            public LLUUID Token;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TokenBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TokenBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Token = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Token.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SecuredTemplateChecksumRequest</summary>
        public override PacketType Type { get { return PacketType.SecuredTemplateChecksumRequest; } }
        /// <summary>TokenBlock block</summary>
        public TokenBlockBlock TokenBlock;

        /// <summary>Default constructor</summary>
        public SecuredTemplateChecksumRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 65530;
            Header.Reliable = true;
            TokenBlock = new TokenBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SecuredTemplateChecksumRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            TokenBlock = new TokenBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SecuredTemplateChecksumRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TokenBlock = new TokenBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += TokenBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TokenBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PacketAck packet</summary>
    public class PacketAckPacket : Packet
    {
        /// <summary>Packets block</summary>
        public class PacketsBlock
        {
            /// <summary>ID field</summary>
            public uint ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PacketsBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PacketsBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PacketAck</summary>
        public override PacketType Type { get { return PacketType.PacketAck; } }
        /// <summary>Packets block</summary>
        public PacketsBlock[] Packets;

        /// <summary>Default constructor</summary>
        public PacketAckPacket()
        {
            Header = new LowHeader();
            Header.ID = 65531;
            Header.Reliable = true;
            Packets = new PacketsBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PacketAckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Packets = new PacketsBlock[count];
            for (int j = 0; j < count; j++)
            { Packets[j] = new PacketsBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PacketAckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Packets = new PacketsBlock[count];
            for (int j = 0; j < count; j++)
            { Packets[j] = new PacketsBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            for (int j = 0; j < Packets.Length; j++) { length += Packets[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Packets.Length;
            for (int j = 0; j < Packets.Length; j++) { Packets[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>OpenCircuit packet</summary>
    public class OpenCircuitPacket : Packet
    {
        /// <summary>CircuitInfo block</summary>
        public class CircuitInfoBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>Port field</summary>
            public ushort Port;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public CircuitInfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public CircuitInfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.OpenCircuit</summary>
        public override PacketType Type { get { return PacketType.OpenCircuit; } }
        /// <summary>CircuitInfo block</summary>
        public CircuitInfoBlock CircuitInfo;

        /// <summary>Default constructor</summary>
        public OpenCircuitPacket()
        {
            Header = new LowHeader();
            Header.ID = 65532;
            Header.Reliable = true;
            CircuitInfo = new CircuitInfoBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public OpenCircuitPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            CircuitInfo = new CircuitInfoBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public OpenCircuitPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            CircuitInfo = new CircuitInfoBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += CircuitInfo.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            CircuitInfo.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CloseCircuit packet</summary>
    public class CloseCircuitPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CloseCircuit</summary>
        public override PacketType Type { get { return PacketType.CloseCircuit; } }

        /// <summary>Default constructor</summary>
        public CloseCircuitPacket()
        {
            Header = new LowHeader();
            Header.ID = 65533;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CloseCircuitPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CloseCircuitPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TemplateChecksumRequest packet</summary>
    public class TemplateChecksumRequestPacket : Packet
    {
        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TemplateChecksumRequest</summary>
        public override PacketType Type { get { return PacketType.TemplateChecksumRequest; } }

        /// <summary>Default constructor</summary>
        public TemplateChecksumRequestPacket()
        {
            Header = new LowHeader();
            Header.ID = 65534;
            Header.Reliable = true;
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TemplateChecksumRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TemplateChecksumRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TemplateChecksumReply packet</summary>
    public class TemplateChecksumReplyPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ServerVersion field</summary>
            public byte ServerVersion;
            /// <summary>PatchVersion field</summary>
            public byte PatchVersion;
            /// <summary>Checksum field</summary>
            public uint Checksum;
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>MajorVersion field</summary>
            public byte MajorVersion;
            /// <summary>MinorVersion field</summary>
            public byte MinorVersion;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ServerVersion = (byte)bytes[i++];
                    PatchVersion = (byte)bytes[i++];
                    Checksum = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MajorVersion = (byte)bytes[i++];
                    MinorVersion = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ServerVersion;
                bytes[i++] = PatchVersion;
                bytes[i++] = (byte)(Checksum % 256);
                bytes[i++] = (byte)((Checksum >> 8) % 256);
                bytes[i++] = (byte)((Checksum >> 16) % 256);
                bytes[i++] = (byte)((Checksum >> 24) % 256);
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = MajorVersion;
                bytes[i++] = MinorVersion;
            }
        }

        /// <summary>TokenBlock block</summary>
        public class TokenBlockBlock
        {
            /// <summary>Token field</summary>
            public LLUUID Token;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TokenBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TokenBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Token = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Token.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TemplateChecksumReply</summary>
        public override PacketType Type { get { return PacketType.TemplateChecksumReply; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;
        /// <summary>TokenBlock block</summary>
        public TokenBlockBlock TokenBlock;

        /// <summary>Default constructor</summary>
        public TemplateChecksumReplyPacket()
        {
            Header = new LowHeader();
            Header.ID = 65535;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
            TokenBlock = new TokenBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TemplateChecksumReplyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new LowHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
            TokenBlock = new TokenBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TemplateChecksumReplyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
            TokenBlock = new TokenBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 8;
            length += DataBlock.Length;            length += TokenBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            TokenBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ClosestSimulator packet</summary>
    public class ClosestSimulatorPacket : Packet
    {
        /// <summary>SimulatorBlock block</summary>
        public class SimulatorBlockBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>Handle field</summary>
            public ulong Handle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 14;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimulatorBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimulatorBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Handle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = (byte)(Handle % 256);
                bytes[i++] = (byte)((Handle >> 8) % 256);
                bytes[i++] = (byte)((Handle >> 16) % 256);
                bytes[i++] = (byte)((Handle >> 24) % 256);
                bytes[i++] = (byte)((Handle >> 32) % 256);
                bytes[i++] = (byte)((Handle >> 40) % 256);
                bytes[i++] = (byte)((Handle >> 48) % 256);
                bytes[i++] = (byte)((Handle >> 56) % 256);
            }
        }

        /// <summary>Viewer block</summary>
        public class ViewerBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ViewerBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ViewerBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ClosestSimulator</summary>
        public override PacketType Type { get { return PacketType.ClosestSimulator; } }
        /// <summary>SimulatorBlock block</summary>
        public SimulatorBlockBlock SimulatorBlock;
        /// <summary>Viewer block</summary>
        public ViewerBlock Viewer;

        /// <summary>Default constructor</summary>
        public ClosestSimulatorPacket()
        {
            Header = new MediumHeader();
            Header.ID = 1;
            Header.Reliable = true;
            SimulatorBlock = new SimulatorBlockBlock();
            Viewer = new ViewerBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ClosestSimulatorPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            Viewer = new ViewerBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ClosestSimulatorPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimulatorBlock = new SimulatorBlockBlock(bytes, ref i);
            Viewer = new ViewerBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += SimulatorBlock.Length;            length += Viewer.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimulatorBlock.ToBytes(bytes, ref i);
            Viewer.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectAdd packet</summary>
    public class ObjectAddPacket : Packet
    {
        /// <summary>InventoryData block</summary>
        public class InventoryDataBlock
        {
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>CreationDate field</summary>
            public int CreationDate;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>InvType field</summary>
            public sbyte InvType;
            /// <summary>Type field</summary>
            public sbyte Type;
            /// <summary>AssetID field</summary>
            public LLUUID AssetID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>Flags field</summary>
            public uint Flags;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 137;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CreationDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    InvType = (sbyte)bytes[i++];
                    Type = (sbyte)bytes[i++];
                    AssetID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    FolderID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    Flags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                bytes[i++] = (byte)(CreationDate % 256);
                bytes[i++] = (byte)((CreationDate >> 8) % 256);
                bytes[i++] = (byte)((CreationDate >> 16) % 256);
                bytes[i++] = (byte)((CreationDate >> 24) % 256);
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)InvType;
                bytes[i++] = (byte)Type;
                Array.Copy(AssetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                bytes[i++] = (byte)(Flags % 256);
                bytes[i++] = (byte)((Flags >> 8) % 256);
                bytes[i++] = (byte)((Flags >> 16) % 256);
                bytes[i++] = (byte)((Flags >> 24) % 256);
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>InventoryFile block</summary>
        public class InventoryFileBlock
        {
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InventoryFileBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InventoryFileBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
            }
        }

        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>AddFlags field</summary>
            public uint AddFlags;
            /// <summary>PathTwistBegin field</summary>
            public sbyte PathTwistBegin;
            /// <summary>PathEnd field</summary>
            public byte PathEnd;
            /// <summary>ProfileBegin field</summary>
            public byte ProfileBegin;
            /// <summary>PathRadiusOffset field</summary>
            public sbyte PathRadiusOffset;
            /// <summary>PathSkew field</summary>
            public sbyte PathSkew;
            /// <summary>RayStart field</summary>
            public LLVector3 RayStart;
            /// <summary>ProfileCurve field</summary>
            public byte ProfileCurve;
            /// <summary>PathScaleX field</summary>
            public byte PathScaleX;
            /// <summary>PathScaleY field</summary>
            public byte PathScaleY;
            /// <summary>Material field</summary>
            public byte Material;
            private byte[] _namevalue;
            /// <summary>NameValue field</summary>
            public byte[] NameValue
            {
                get { return _namevalue; }
                set
                {
                    if (value == null) { _namevalue = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _namevalue = new byte[value.Length]; Array.Copy(value, _namevalue, value.Length); }
                }
            }
            /// <summary>PathShearX field</summary>
            public byte PathShearX;
            /// <summary>PathShearY field</summary>
            public byte PathShearY;
            /// <summary>PathTaperX field</summary>
            public sbyte PathTaperX;
            /// <summary>PathTaperY field</summary>
            public sbyte PathTaperY;
            /// <summary>RayEndIsIntersection field</summary>
            public byte RayEndIsIntersection;
            /// <summary>RayEnd field</summary>
            public LLVector3 RayEnd;
            /// <summary>ProfileEnd field</summary>
            public byte ProfileEnd;
            /// <summary>PathBegin field</summary>
            public byte PathBegin;
            /// <summary>BypassRaycast field</summary>
            public byte BypassRaycast;
            /// <summary>PCode field</summary>
            public byte PCode;
            /// <summary>PathCurve field</summary>
            public byte PathCurve;
            /// <summary>Scale field</summary>
            public LLVector3 Scale;
            /// <summary>State field</summary>
            public byte State;
            /// <summary>PathTwist field</summary>
            public sbyte PathTwist;
            private byte[] _textureentry;
            /// <summary>TextureEntry field</summary>
            public byte[] TextureEntry
            {
                get { return _textureentry; }
                set
                {
                    if (value == null) { _textureentry = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _textureentry = new byte[value.Length]; Array.Copy(value, _textureentry, value.Length); }
                }
            }
            /// <summary>ProfileHollow field</summary>
            public byte ProfileHollow;
            /// <summary>PathRevolutions field</summary>
            public byte PathRevolutions;
            /// <summary>Rotation field</summary>
            public LLQuaternion Rotation;
            /// <summary>RayTargetID field</summary>
            public LLUUID RayTargetID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 95;
                    if (NameValue != null) { length += 2 + NameValue.Length; }
                    if (TextureEntry != null) { length += 2 + TextureEntry.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AddFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PathTwistBegin = (sbyte)bytes[i++];
                    PathEnd = (byte)bytes[i++];
                    ProfileBegin = (byte)bytes[i++];
                    PathRadiusOffset = (sbyte)bytes[i++];
                    PathSkew = (sbyte)bytes[i++];
                    RayStart = new LLVector3(bytes, i); i += 12;
                    ProfileCurve = (byte)bytes[i++];
                    PathScaleX = (byte)bytes[i++];
                    PathScaleY = (byte)bytes[i++];
                    Material = (byte)bytes[i++];
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _namevalue = new byte[length];
                    Array.Copy(bytes, i, _namevalue, 0, length); i += length;
                    PathShearX = (byte)bytes[i++];
                    PathShearY = (byte)bytes[i++];
                    PathTaperX = (sbyte)bytes[i++];
                    PathTaperY = (sbyte)bytes[i++];
                    RayEndIsIntersection = (byte)bytes[i++];
                    RayEnd = new LLVector3(bytes, i); i += 12;
                    ProfileEnd = (byte)bytes[i++];
                    PathBegin = (byte)bytes[i++];
                    BypassRaycast = (byte)bytes[i++];
                    PCode = (byte)bytes[i++];
                    PathCurve = (byte)bytes[i++];
                    Scale = new LLVector3(bytes, i); i += 12;
                    State = (byte)bytes[i++];
                    PathTwist = (sbyte)bytes[i++];
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _textureentry = new byte[length];
                    Array.Copy(bytes, i, _textureentry, 0, length); i += length;
                    ProfileHollow = (byte)bytes[i++];
                    PathRevolutions = (byte)bytes[i++];
                    Rotation = new LLQuaternion(bytes, i); i += 16;
                    RayTargetID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(AddFlags % 256);
                bytes[i++] = (byte)((AddFlags >> 8) % 256);
                bytes[i++] = (byte)((AddFlags >> 16) % 256);
                bytes[i++] = (byte)((AddFlags >> 24) % 256);
                bytes[i++] = (byte)PathTwistBegin;
                bytes[i++] = PathEnd;
                bytes[i++] = ProfileBegin;
                bytes[i++] = (byte)PathRadiusOffset;
                bytes[i++] = (byte)PathSkew;
                Array.Copy(RayStart.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = ProfileCurve;
                bytes[i++] = PathScaleX;
                bytes[i++] = PathScaleY;
                bytes[i++] = Material;
                bytes[i++] = (byte)(NameValue.Length % 256);
                bytes[i++] = (byte)((NameValue.Length >> 8) % 256);
                Array.Copy(NameValue, 0, bytes, i, NameValue.Length); i += NameValue.Length;
                bytes[i++] = PathShearX;
                bytes[i++] = PathShearY;
                bytes[i++] = (byte)PathTaperX;
                bytes[i++] = (byte)PathTaperY;
                bytes[i++] = RayEndIsIntersection;
                Array.Copy(RayEnd.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = ProfileEnd;
                bytes[i++] = PathBegin;
                bytes[i++] = BypassRaycast;
                bytes[i++] = PCode;
                bytes[i++] = PathCurve;
                Array.Copy(Scale.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = State;
                bytes[i++] = (byte)PathTwist;
                bytes[i++] = (byte)(TextureEntry.Length % 256);
                bytes[i++] = (byte)((TextureEntry.Length >> 8) % 256);
                Array.Copy(TextureEntry, 0, bytes, i, TextureEntry.Length); i += TextureEntry.Length;
                bytes[i++] = ProfileHollow;
                bytes[i++] = PathRevolutions;
                Array.Copy(Rotation.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(RayTargetID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 48;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectAdd</summary>
        public override PacketType Type { get { return PacketType.ObjectAdd; } }
        /// <summary>InventoryData block</summary>
        public InventoryDataBlock[] InventoryData;
        /// <summary>InventoryFile block</summary>
        public InventoryFileBlock InventoryFile;
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectAddPacket()
        {
            Header = new MediumHeader();
            Header.ID = 2;
            Header.Reliable = true;
            Header.Zerocoded = true;
            InventoryData = new InventoryDataBlock[0];
            InventoryFile = new InventoryFileBlock();
            ObjectData = new ObjectDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectAddPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            InventoryFile = new InventoryFileBlock(bytes, ref i);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectAddPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            InventoryData = new InventoryDataBlock[count];
            for (int j = 0; j < count; j++)
            { InventoryData[j] = new InventoryDataBlock(bytes, ref i); }
            InventoryFile = new InventoryFileBlock(bytes, ref i);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += InventoryFile.Length;            length += ObjectData.Length;            length += AgentData.Length;;
            for (int j = 0; j < InventoryData.Length; j++) { length += InventoryData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)InventoryData.Length;
            for (int j = 0; j < InventoryData.Length; j++) { InventoryData[j].ToBytes(bytes, ref i); }
            InventoryFile.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MultipleObjectUpdate packet</summary>
    public class MultipleObjectUpdatePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }
            /// <summary>Type field</summary>
            public byte Type;
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    if (Data != null) { length += 1 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                    Type = (byte)bytes[i++];
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Data.Length;
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
                bytes[i++] = Type;
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MultipleObjectUpdate</summary>
        public override PacketType Type { get { return PacketType.MultipleObjectUpdate; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public MultipleObjectUpdatePacket()
        {
            Header = new MediumHeader();
            Header.ID = 3;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MultipleObjectUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MultipleObjectUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestMultipleObjects packet</summary>
    public class RequestMultipleObjectsPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ID field</summary>
            public uint ID;
            /// <summary>CacheMissType field</summary>
            public byte CacheMissType;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 6;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CacheMissType = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
                bytes[i++] = CacheMissType;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestMultipleObjects</summary>
        public override PacketType Type { get { return PacketType.RequestMultipleObjects; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public RequestMultipleObjectsPacket()
        {
            Header = new MediumHeader();
            Header.ID = 4;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestMultipleObjectsPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestMultipleObjectsPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectPosition packet</summary>
    public class ObjectPositionPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ObjectLocalID field</summary>
            public uint ObjectLocalID;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectLocalID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ObjectLocalID % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 8) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 16) % 256);
                bytes[i++] = (byte)((ObjectLocalID >> 24) % 256);
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectPosition</summary>
        public override PacketType Type { get { return PacketType.ObjectPosition; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ObjectPositionPacket()
        {
            Header = new MediumHeader();
            Header.ID = 5;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectPositionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectPositionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += AgentData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestObjectPropertiesFamily packet</summary>
    public class RequestObjectPropertiesFamilyPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>RequestFlags field</summary>
            public uint RequestFlags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    RequestFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RequestFlags % 256);
                bytes[i++] = (byte)((RequestFlags >> 8) % 256);
                bytes[i++] = (byte)((RequestFlags >> 16) % 256);
                bytes[i++] = (byte)((RequestFlags >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestObjectPropertiesFamily</summary>
        public override PacketType Type { get { return PacketType.RequestObjectPropertiesFamily; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;

        /// <summary>Default constructor</summary>
        public RequestObjectPropertiesFamilyPacket()
        {
            Header = new MediumHeader();
            Header.ID = 6;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestObjectPropertiesFamilyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestObjectPropertiesFamilyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += ObjectData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CoarseLocationUpdate packet</summary>
    public class CoarseLocationUpdatePacket : Packet
    {
        /// <summary>Location block</summary>
        public class LocationBlock
        {
            /// <summary>X field</summary>
            public byte X;
            /// <summary>Y field</summary>
            public byte Y;
            /// <summary>Z field</summary>
            public byte Z;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public LocationBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public LocationBlock(byte[] bytes, ref int i)
            {
                try
                {
                    X = (byte)bytes[i++];
                    Y = (byte)bytes[i++];
                    Z = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = X;
                bytes[i++] = Y;
                bytes[i++] = Z;
            }
        }

        /// <summary>Index block</summary>
        public class IndexBlock
        {
            /// <summary>You field</summary>
            public short You;
            /// <summary>Prey field</summary>
            public short Prey;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public IndexBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public IndexBlock(byte[] bytes, ref int i)
            {
                try
                {
                    You = (short)(bytes[i++] + (bytes[i++] << 8));
                    Prey = (short)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(You % 256);
                bytes[i++] = (byte)((You >> 8) % 256);
                bytes[i++] = (byte)(Prey % 256);
                bytes[i++] = (byte)((Prey >> 8) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CoarseLocationUpdate</summary>
        public override PacketType Type { get { return PacketType.CoarseLocationUpdate; } }
        /// <summary>Location block</summary>
        public LocationBlock[] Location;
        /// <summary>Index block</summary>
        public IndexBlock Index;

        /// <summary>Default constructor</summary>
        public CoarseLocationUpdatePacket()
        {
            Header = new MediumHeader();
            Header.ID = 7;
            Header.Reliable = true;
            Location = new LocationBlock[0];
            Index = new IndexBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CoarseLocationUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Location = new LocationBlock[count];
            for (int j = 0; j < count; j++)
            { Location[j] = new LocationBlock(bytes, ref i); }
            Index = new IndexBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CoarseLocationUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Location = new LocationBlock[count];
            for (int j = 0; j < count; j++)
            { Location[j] = new LocationBlock(bytes, ref i); }
            Index = new IndexBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += Index.Length;;
            for (int j = 0; j < Location.Length; j++) { length += Location[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Location.Length;
            for (int j = 0; j < Location.Length; j++) { Location[j].ToBytes(bytes, ref i); }
            Index.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CrossedRegion packet</summary>
    public class CrossedRegionPacket : Packet
    {
        /// <summary>Info block</summary>
        public class InfoBlock
        {
            /// <summary>LookAt field</summary>
            public LLVector3 LookAt;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 24;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public InfoBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public InfoBlock(byte[] bytes, ref int i)
            {
                try
                {
                    LookAt = new LLVector3(bytes, i); i += 12;
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(LookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            private byte[] _seedcapability;
            /// <summary>SeedCapability field</summary>
            public byte[] SeedCapability
            {
                get { return _seedcapability; }
                set
                {
                    if (value == null) { _seedcapability = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _seedcapability = new byte[value.Length]; Array.Copy(value, _seedcapability, value.Length); }
                }
            }
            /// <summary>SimPort field</summary>
            public ushort SimPort;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>SimIP field</summary>
            public uint SimIP;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 14;
                    if (SeedCapability != null) { length += 2 + SeedCapability.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _seedcapability = new byte[length];
                    Array.Copy(bytes, i, _seedcapability, 0, length); i += length;
                    SimPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    SimIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(SeedCapability.Length % 256);
                bytes[i++] = (byte)((SeedCapability.Length >> 8) % 256);
                Array.Copy(SeedCapability, 0, bytes, i, SeedCapability.Length); i += SeedCapability.Length;
                bytes[i++] = (byte)(SimPort % 256);
                bytes[i++] = (byte)((SimPort >> 8) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = (byte)(SimIP % 256);
                bytes[i++] = (byte)((SimIP >> 8) % 256);
                bytes[i++] = (byte)((SimIP >> 16) % 256);
                bytes[i++] = (byte)((SimIP >> 24) % 256);
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CrossedRegion</summary>
        public override PacketType Type { get { return PacketType.CrossedRegion; } }
        /// <summary>Info block</summary>
        public InfoBlock Info;
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public CrossedRegionPacket()
        {
            Header = new MediumHeader();
            Header.ID = 8;
            Header.Reliable = true;
            Info = new InfoBlock();
            RegionData = new RegionDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CrossedRegionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            Info = new InfoBlock(bytes, ref i);
            RegionData = new RegionDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CrossedRegionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Info = new InfoBlock(bytes, ref i);
            RegionData = new RegionDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += Info.Length;            length += RegionData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Info.ToBytes(bytes, ref i);
            RegionData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ConfirmEnableSimulator packet</summary>
    public class ConfirmEnableSimulatorPacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ConfirmEnableSimulator</summary>
        public override PacketType Type { get { return PacketType.ConfirmEnableSimulator; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ConfirmEnableSimulatorPacket()
        {
            Header = new MediumHeader();
            Header.ID = 9;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ConfirmEnableSimulatorPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ConfirmEnableSimulatorPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectProperties packet</summary>
    public class ObjectPropertiesPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>OwnershipCost field</summary>
            public int OwnershipCost;
            /// <summary>AggregatePermTexturesOwner field</summary>
            public byte AggregatePermTexturesOwner;
            private byte[] _sitname;
            /// <summary>SitName field</summary>
            public byte[] SitName
            {
                get { return _sitname; }
                set
                {
                    if (value == null) { _sitname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _sitname = new byte[value.Length]; Array.Copy(value, _sitname, value.Length); }
                }
            }
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Category field</summary>
            public uint Category;
            /// <summary>FromTaskID field</summary>
            public LLUUID FromTaskID;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            private byte[] _textureid;
            /// <summary>TextureID field</summary>
            public byte[] TextureID
            {
                get { return _textureid; }
                set
                {
                    if (value == null) { _textureid = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _textureid = new byte[value.Length]; Array.Copy(value, _textureid, value.Length); }
                }
            }
            private byte[] _touchname;
            /// <summary>TouchName field</summary>
            public byte[] TouchName
            {
                get { return _touchname; }
                set
                {
                    if (value == null) { _touchname = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _touchname = new byte[value.Length]; Array.Copy(value, _touchname, value.Length); }
                }
            }
            /// <summary>ItemID field</summary>
            public LLUUID ItemID;
            /// <summary>AggregatePermTextures field</summary>
            public byte AggregatePermTextures;
            /// <summary>FolderID field</summary>
            public LLUUID FolderID;
            /// <summary>InventorySerial field</summary>
            public short InventorySerial;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>LastOwnerID field</summary>
            public LLUUID LastOwnerID;
            /// <summary>AggregatePerms field</summary>
            public byte AggregatePerms;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 167;
                    if (SitName != null) { length += 1 + SitName.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (TextureID != null) { length += 1 + TextureID.Length; }
                    if (TouchName != null) { length += 1 + TouchName.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    OwnershipCost = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AggregatePermTexturesOwner = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _sitname = new byte[length];
                    Array.Copy(bytes, i, _sitname, 0, length); i += length;
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Category = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    FromTaskID = new LLUUID(bytes, i); i += 16;
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _textureid = new byte[length];
                    Array.Copy(bytes, i, _textureid, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _touchname = new byte[length];
                    Array.Copy(bytes, i, _touchname, 0, length); i += length;
                    ItemID = new LLUUID(bytes, i); i += 16;
                    AggregatePermTextures = (byte)bytes[i++];
                    FolderID = new LLUUID(bytes, i); i += 16;
                    InventorySerial = (short)(bytes[i++] + (bytes[i++] << 8));
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    LastOwnerID = new LLUUID(bytes, i); i += 16;
                    AggregatePerms = (byte)bytes[i++];
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(OwnershipCost % 256);
                bytes[i++] = (byte)((OwnershipCost >> 8) % 256);
                bytes[i++] = (byte)((OwnershipCost >> 16) % 256);
                bytes[i++] = (byte)((OwnershipCost >> 24) % 256);
                bytes[i++] = AggregatePermTexturesOwner;
                bytes[i++] = (byte)SitName.Length;
                Array.Copy(SitName, 0, bytes, i, SitName.Length); i += SitName.Length;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Category % 256);
                bytes[i++] = (byte)((Category >> 8) % 256);
                bytes[i++] = (byte)((Category >> 16) % 256);
                bytes[i++] = (byte)((Category >> 24) % 256);
                Array.Copy(FromTaskID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)TextureID.Length;
                Array.Copy(TextureID, 0, bytes, i, TextureID.Length); i += TextureID.Length;
                bytes[i++] = (byte)TouchName.Length;
                Array.Copy(TouchName, 0, bytes, i, TouchName.Length); i += TouchName.Length;
                Array.Copy(ItemID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = AggregatePermTextures;
                Array.Copy(FolderID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(InventorySerial % 256);
                bytes[i++] = (byte)((InventorySerial >> 8) % 256);
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                Array.Copy(LastOwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = AggregatePerms;
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectProperties</summary>
        public override PacketType Type { get { return PacketType.ObjectProperties; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;

        /// <summary>Default constructor</summary>
        public ObjectPropertiesPacket()
        {
            Header = new MediumHeader();
            Header.ID = 10;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectPropertiesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectPropertiesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectPropertiesFamily packet</summary>
    public class ObjectPropertiesFamilyPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>OwnershipCost field</summary>
            public int OwnershipCost;
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>SaleType field</summary>
            public byte SaleType;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>RequestFlags field</summary>
            public uint RequestFlags;
            /// <summary>Category field</summary>
            public uint Category;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            private byte[] _description;
            /// <summary>Description field</summary>
            public byte[] Description
            {
                get { return _description; }
                set
                {
                    if (value == null) { _description = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _description = new byte[value.Length]; Array.Copy(value, _description, value.Length); }
                }
            }
            /// <summary>LastOwnerID field</summary>
            public LLUUID LastOwnerID;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 101;
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Description != null) { length += 1 + Description.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    OwnershipCost = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    SaleType = (byte)bytes[i++];
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    RequestFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Category = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _description = new byte[length];
                    Array.Copy(bytes, i, _description, 0, length); i += length;
                    LastOwnerID = new LLUUID(bytes, i); i += 16;
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(OwnershipCost % 256);
                bytes[i++] = (byte)((OwnershipCost >> 8) % 256);
                bytes[i++] = (byte)((OwnershipCost >> 16) % 256);
                bytes[i++] = (byte)((OwnershipCost >> 24) % 256);
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = SaleType;
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(RequestFlags % 256);
                bytes[i++] = (byte)((RequestFlags >> 8) % 256);
                bytes[i++] = (byte)((RequestFlags >> 16) % 256);
                bytes[i++] = (byte)((RequestFlags >> 24) % 256);
                bytes[i++] = (byte)(Category % 256);
                bytes[i++] = (byte)((Category >> 8) % 256);
                bytes[i++] = (byte)((Category >> 16) % 256);
                bytes[i++] = (byte)((Category >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                bytes[i++] = (byte)Description.Length;
                Array.Copy(Description, 0, bytes, i, Description.Length); i += Description.Length;
                Array.Copy(LastOwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectPropertiesFamily</summary>
        public override PacketType Type { get { return PacketType.ObjectPropertiesFamily; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;

        /// <summary>Default constructor</summary>
        public ObjectPropertiesFamilyPacket()
        {
            Header = new MediumHeader();
            Header.ID = 11;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectPropertiesFamilyPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectPropertiesFamilyPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += ObjectData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelPropertiesRequest packet</summary>
    public class ParcelPropertiesRequestPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>East field</summary>
            public float East;
            /// <summary>West field</summary>
            public float West;
            /// <summary>SequenceID field</summary>
            public int SequenceID;
            /// <summary>SnapSelection field</summary>
            public bool SnapSelection;
            /// <summary>North field</summary>
            public float North;
            /// <summary>South field</summary>
            public float South;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    East = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    West = BitConverter.ToSingle(bytes, i); i += 4;
                    SequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SnapSelection = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    North = BitConverter.ToSingle(bytes, i); i += 4;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    South = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(East);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(West);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(SequenceID % 256);
                bytes[i++] = (byte)((SequenceID >> 8) % 256);
                bytes[i++] = (byte)((SequenceID >> 16) % 256);
                bytes[i++] = (byte)((SequenceID >> 24) % 256);
                bytes[i++] = (byte)((SnapSelection) ? 1 : 0);
                ba = BitConverter.GetBytes(North);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                ba = BitConverter.GetBytes(South);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelPropertiesRequest</summary>
        public override PacketType Type { get { return PacketType.ParcelPropertiesRequest; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ParcelPropertiesRequestPacket()
        {
            Header = new MediumHeader();
            Header.ID = 12;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelPropertiesRequestPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelPropertiesRequestPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += ParcelData.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SimStatus packet</summary>
    public class SimStatusPacket : Packet
    {
        /// <summary>SimStatus block</summary>
        public class SimStatusBlock
        {
            /// <summary>CanAcceptAgents field</summary>
            public bool CanAcceptAgents;
            /// <summary>CanAcceptTasks field</summary>
            public bool CanAcceptTasks;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SimStatusBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SimStatusBlock(byte[] bytes, ref int i)
            {
                try
                {
                    CanAcceptAgents = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CanAcceptTasks = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((CanAcceptAgents) ? 1 : 0);
                bytes[i++] = (byte)((CanAcceptTasks) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SimStatus</summary>
        public override PacketType Type { get { return PacketType.SimStatus; } }
        /// <summary>SimStatus block</summary>
        public SimStatusBlock SimStatus;

        /// <summary>Default constructor</summary>
        public SimStatusPacket()
        {
            Header = new MediumHeader();
            Header.ID = 13;
            Header.Reliable = true;
            SimStatus = new SimStatusBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SimStatusPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            SimStatus = new SimStatusBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SimStatusPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SimStatus = new SimStatusBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += SimStatus.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SimStatus.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>GestureUpdate packet</summary>
    public class GestureUpdatePacket : Packet
    {
        /// <summary>AgentBlock block</summary>
        public class AgentBlockBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ToViewer field</summary>
            public bool ToViewer;
            private byte[] _filename;
            /// <summary>Filename field</summary>
            public byte[] Filename
            {
                get { return _filename; }
                set
                {
                    if (value == null) { _filename = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _filename = new byte[value.Length]; Array.Copy(value, _filename, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    if (Filename != null) { length += 1 + Filename.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    ToViewer = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _filename = new byte[length];
                    Array.Copy(bytes, i, _filename, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((ToViewer) ? 1 : 0);
                bytes[i++] = (byte)Filename.Length;
                Array.Copy(Filename, 0, bytes, i, Filename.Length); i += Filename.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.GestureUpdate</summary>
        public override PacketType Type { get { return PacketType.GestureUpdate; } }
        /// <summary>AgentBlock block</summary>
        public AgentBlockBlock AgentBlock;

        /// <summary>Default constructor</summary>
        public GestureUpdatePacket()
        {
            Header = new MediumHeader();
            Header.ID = 14;
            Header.Reliable = true;
            AgentBlock = new AgentBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public GestureUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public GestureUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentBlock = new AgentBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += AgentBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AttachedSound packet</summary>
    public class AttachedSoundPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Gain field</summary>
            public float Gain;
            /// <summary>SoundID field</summary>
            public LLUUID SoundID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>Flags field</summary>
            public byte Flags;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 53;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Gain = BitConverter.ToSingle(bytes, i); i += 4;
                    SoundID = new LLUUID(bytes, i); i += 16;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    Flags = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Gain);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(SoundID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Flags;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AttachedSound</summary>
        public override PacketType Type { get { return PacketType.AttachedSound; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public AttachedSoundPacket()
        {
            Header = new MediumHeader();
            Header.ID = 15;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AttachedSoundPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AttachedSoundPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AttachedSoundGainChange packet</summary>
    public class AttachedSoundGainChangePacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Gain field</summary>
            public float Gain;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Gain = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Gain);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AttachedSoundGainChange</summary>
        public override PacketType Type { get { return PacketType.AttachedSoundGainChange; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public AttachedSoundGainChangePacket()
        {
            Header = new MediumHeader();
            Header.ID = 16;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AttachedSoundGainChangePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AttachedSoundGainChangePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AttachedSoundCutoffRadius packet</summary>
    public class AttachedSoundCutoffRadiusPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Radius field</summary>
            public float Radius;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 20;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Radius = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Radius);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AttachedSoundCutoffRadius</summary>
        public override PacketType Type { get { return PacketType.AttachedSoundCutoffRadius; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public AttachedSoundCutoffRadiusPacket()
        {
            Header = new MediumHeader();
            Header.ID = 17;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AttachedSoundCutoffRadiusPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AttachedSoundCutoffRadiusPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PreloadSound packet</summary>
    public class PreloadSoundPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>SoundID field</summary>
            public LLUUID SoundID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 49;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    SoundID = new LLUUID(bytes, i); i += 16;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SoundID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PreloadSound</summary>
        public override PacketType Type { get { return PacketType.PreloadSound; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock[] DataBlock;

        /// <summary>Default constructor</summary>
        public PreloadSoundPacket()
        {
            Header = new MediumHeader();
            Header.ID = 18;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PreloadSoundPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PreloadSoundPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            DataBlock = new DataBlockBlock[count];
            for (int j = 0; j < count; j++)
            { DataBlock[j] = new DataBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
;
            for (int j = 0; j < DataBlock.Length; j++) { length += DataBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)DataBlock.Length;
            for (int j = 0; j < DataBlock.Length; j++) { DataBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>InternalScriptMail packet</summary>
    public class InternalScriptMailPacket : Packet
    {
        /// <summary>DataBlock block</summary>
        public class DataBlockBlock
        {
            /// <summary>To field</summary>
            public LLUUID To;
            private byte[] _subject;
            /// <summary>Subject field</summary>
            public byte[] Subject
            {
                get { return _subject; }
                set
                {
                    if (value == null) { _subject = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _subject = new byte[value.Length]; Array.Copy(value, _subject, value.Length); }
                }
            }
            private byte[] _body;
            /// <summary>Body field</summary>
            public byte[] Body
            {
                get { return _body; }
                set
                {
                    if (value == null) { _body = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _body = new byte[value.Length]; Array.Copy(value, _body, value.Length); }
                }
            }
            private byte[] _from;
            /// <summary>From field</summary>
            public byte[] From
            {
                get { return _from; }
                set
                {
                    if (value == null) { _from = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _from = new byte[value.Length]; Array.Copy(value, _from, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    if (Subject != null) { length += 1 + Subject.Length; }
                    if (Body != null) { length += 2 + Body.Length; }
                    if (From != null) { length += 1 + From.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    To = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _subject = new byte[length];
                    Array.Copy(bytes, i, _subject, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _body = new byte[length];
                    Array.Copy(bytes, i, _body, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _from = new byte[length];
                    Array.Copy(bytes, i, _from, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(To.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Subject.Length;
                Array.Copy(Subject, 0, bytes, i, Subject.Length); i += Subject.Length;
                bytes[i++] = (byte)(Body.Length % 256);
                bytes[i++] = (byte)((Body.Length >> 8) % 256);
                Array.Copy(Body, 0, bytes, i, Body.Length); i += Body.Length;
                bytes[i++] = (byte)From.Length;
                Array.Copy(From, 0, bytes, i, From.Length); i += From.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.InternalScriptMail</summary>
        public override PacketType Type { get { return PacketType.InternalScriptMail; } }
        /// <summary>DataBlock block</summary>
        public DataBlockBlock DataBlock;

        /// <summary>Default constructor</summary>
        public InternalScriptMailPacket()
        {
            Header = new MediumHeader();
            Header.ID = 19;
            Header.Reliable = true;
            DataBlock = new DataBlockBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public InternalScriptMailPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public InternalScriptMailPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataBlock = new DataBlockBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += DataBlock.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataBlock.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ViewerEffect packet</summary>
    public class ViewerEffectPacket : Packet
    {
        /// <summary>Effect block</summary>
        public class EffectBlock
        {
            /// <summary>Duration field</summary>
            public float Duration;
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Type field</summary>
            public byte Type;
            /// <summary>Color field</summary>
            public byte[] Color;
            private byte[] _typedata;
            /// <summary>TypeData field</summary>
            public byte[] TypeData
            {
                get { return _typedata; }
                set
                {
                    if (value == null) { _typedata = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _typedata = new byte[value.Length]; Array.Copy(value, _typedata, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    if (TypeData != null) { length += 1 + TypeData.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EffectBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EffectBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Duration = BitConverter.ToSingle(bytes, i); i += 4;
                    ID = new LLUUID(bytes, i); i += 16;
                    Type = (byte)bytes[i++];
                    Color = new byte[4];
                    Array.Copy(bytes, i, Color, 0, 4); i += 4;
                    length = (ushort)bytes[i++];
                    _typedata = new byte[length];
                    Array.Copy(bytes, i, _typedata, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Duration);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Type;
                Array.Copy(Color, 0, bytes, i, 4);i += 4;
                bytes[i++] = (byte)TypeData.Length;
                Array.Copy(TypeData, 0, bytes, i, TypeData.Length); i += TypeData.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ViewerEffect</summary>
        public override PacketType Type { get { return PacketType.ViewerEffect; } }
        /// <summary>Effect block</summary>
        public EffectBlock[] Effect;

        /// <summary>Default constructor</summary>
        public ViewerEffectPacket()
        {
            Header = new MediumHeader();
            Header.ID = 20;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Effect = new EffectBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ViewerEffectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            Effect = new EffectBlock[count];
            for (int j = 0; j < count; j++)
            { Effect[j] = new EffectBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ViewerEffectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            Effect = new EffectBlock[count];
            for (int j = 0; j < count; j++)
            { Effect[j] = new EffectBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
;
            for (int j = 0; j < Effect.Length; j++) { length += Effect[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)Effect.Length;
            for (int j = 0; j < Effect.Length; j++) { Effect[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SetSunPhase packet</summary>
    public class SetSunPhasePacket : Packet
    {
        /// <summary>Data block</summary>
        public class DataBlock
        {
            /// <summary>Phase field</summary>
            public float Phase;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 4;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Phase = BitConverter.ToSingle(bytes, i); i += 4;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(Phase);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 32;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SetSunPhase</summary>
        public override PacketType Type { get { return PacketType.SetSunPhase; } }
        /// <summary>Data block</summary>
        public DataBlock Data;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public SetSunPhasePacket()
        {
            Header = new MediumHeader();
            Header.ID = 21;
            Header.Reliable = true;
            Data = new DataBlock();
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SetSunPhasePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new MediumHeader(bytes, ref i, ref packetEnd);
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SetSunPhasePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Data = new DataBlock(bytes, ref i);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 6;
            length += Data.Length;            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Data.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>StartPingCheck packet</summary>
    public class StartPingCheckPacket : Packet
    {
        /// <summary>PingID block</summary>
        public class PingIDBlock
        {
            /// <summary>PingID field</summary>
            public byte PingID;
            /// <summary>OldestUnacked field</summary>
            public uint OldestUnacked;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PingIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PingIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PingID = (byte)bytes[i++];
                    OldestUnacked = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = PingID;
                bytes[i++] = (byte)(OldestUnacked % 256);
                bytes[i++] = (byte)((OldestUnacked >> 8) % 256);
                bytes[i++] = (byte)((OldestUnacked >> 16) % 256);
                bytes[i++] = (byte)((OldestUnacked >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.StartPingCheck</summary>
        public override PacketType Type { get { return PacketType.StartPingCheck; } }
        /// <summary>PingID block</summary>
        public PingIDBlock PingID;

        /// <summary>Default constructor</summary>
        public StartPingCheckPacket()
        {
            Header = new HighHeader();
            Header.ID = 1;
            Header.Reliable = true;
            PingID = new PingIDBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public StartPingCheckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            PingID = new PingIDBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public StartPingCheckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PingID = new PingIDBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += PingID.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PingID.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CompletePingCheck packet</summary>
    public class CompletePingCheckPacket : Packet
    {
        /// <summary>PingID block</summary>
        public class PingIDBlock
        {
            /// <summary>PingID field</summary>
            public byte PingID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public PingIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public PingIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    PingID = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = PingID;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CompletePingCheck</summary>
        public override PacketType Type { get { return PacketType.CompletePingCheck; } }
        /// <summary>PingID block</summary>
        public PingIDBlock PingID;

        /// <summary>Default constructor</summary>
        public CompletePingCheckPacket()
        {
            Header = new HighHeader();
            Header.ID = 2;
            Header.Reliable = true;
            PingID = new PingIDBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CompletePingCheckPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            PingID = new PingIDBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CompletePingCheckPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            PingID = new PingIDBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += PingID.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            PingID.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>NeighborList packet</summary>
    public class NeighborListPacket : Packet
    {
        /// <summary>NeighborBlock block</summary>
        public class NeighborBlockBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>PublicPort field</summary>
            public ushort PublicPort;
            /// <summary>RegionID field</summary>
            public LLUUID RegionID;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>SimAccess field</summary>
            public byte SimAccess;
            /// <summary>PublicIP field</summary>
            public uint PublicIP;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    if (Name != null) { length += 1 + Name.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NeighborBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NeighborBlockBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PublicPort = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    SimAccess = (byte)bytes[i++];
                    PublicIP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                bytes[i++] = (byte)(PublicPort % 256);
                bytes[i++] = (byte)((PublicPort >> 8) % 256);
                Array.Copy(RegionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = SimAccess;
                bytes[i++] = (byte)(PublicIP % 256);
                bytes[i++] = (byte)((PublicIP >> 8) % 256);
                bytes[i++] = (byte)((PublicIP >> 16) % 256);
                bytes[i++] = (byte)((PublicIP >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.NeighborList</summary>
        public override PacketType Type { get { return PacketType.NeighborList; } }
        /// <summary>NeighborBlock block</summary>
        public NeighborBlockBlock[] NeighborBlock;

        /// <summary>Default constructor</summary>
        public NeighborListPacket()
        {
            Header = new HighHeader();
            Header.ID = 3;
            Header.Reliable = true;
            NeighborBlock = new NeighborBlockBlock[4];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public NeighborListPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public NeighborListPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            NeighborBlock = new NeighborBlockBlock[4];
            for (int j = 0; j < 4; j++)
            { NeighborBlock[j] = new NeighborBlockBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
;
            for (int j = 0; j < 4; j++) { length += NeighborBlock[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            for (int j = 0; j < 4; j++) { NeighborBlock[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>MovedIntoSimulator packet</summary>
    public class MovedIntoSimulatorPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>CircuitCode field</summary>
            public uint CircuitCode;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 36;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    CircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(CircuitCode % 256);
                bytes[i++] = (byte)((CircuitCode >> 8) % 256);
                bytes[i++] = (byte)((CircuitCode >> 16) % 256);
                bytes[i++] = (byte)((CircuitCode >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.MovedIntoSimulator</summary>
        public override PacketType Type { get { return PacketType.MovedIntoSimulator; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public MovedIntoSimulatorPacket()
        {
            Header = new HighHeader();
            Header.ID = 4;
            Header.Reliable = true;
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public MovedIntoSimulatorPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public MovedIntoSimulatorPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentUpdate packet</summary>
    public class AgentUpdatePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>ControlFlags field</summary>
            public uint ControlFlags;
            /// <summary>CameraAtAxis field</summary>
            public LLVector3 CameraAtAxis;
            /// <summary>Far field</summary>
            public float Far;
            /// <summary>CameraCenter field</summary>
            public LLVector3 CameraCenter;
            /// <summary>CameraLeftAxis field</summary>
            public LLVector3 CameraLeftAxis;
            /// <summary>HeadRotation field</summary>
            public LLQuaternion HeadRotation;
            /// <summary>CameraUpAxis field</summary>
            public LLVector3 CameraUpAxis;
            /// <summary>BodyRotation field</summary>
            public LLQuaternion BodyRotation;
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>State field</summary>
            public byte State;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 106;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    ControlFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CameraAtAxis = new LLVector3(bytes, i); i += 12;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Far = BitConverter.ToSingle(bytes, i); i += 4;
                    CameraCenter = new LLVector3(bytes, i); i += 12;
                    CameraLeftAxis = new LLVector3(bytes, i); i += 12;
                    HeadRotation = new LLQuaternion(bytes, i); i += 16;
                    CameraUpAxis = new LLVector3(bytes, i); i += 12;
                    BodyRotation = new LLQuaternion(bytes, i); i += 16;
                    Flags = (byte)bytes[i++];
                    State = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(ControlFlags % 256);
                bytes[i++] = (byte)((ControlFlags >> 8) % 256);
                bytes[i++] = (byte)((ControlFlags >> 16) % 256);
                bytes[i++] = (byte)((ControlFlags >> 24) % 256);
                Array.Copy(CameraAtAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                ba = BitConverter.GetBytes(Far);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(CameraCenter.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(CameraLeftAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(HeadRotation.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CameraUpAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(BodyRotation.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Flags;
                bytes[i++] = State;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentUpdate</summary>
        public override PacketType Type { get { return PacketType.AgentUpdate; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public AgentUpdatePacket()
        {
            Header = new HighHeader();
            Header.ID = 5;
            Header.Reliable = true;
            Header.Zerocoded = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentAnimation packet</summary>
    public class AgentAnimationPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AnimationList block</summary>
        public class AnimationListBlock
        {
            /// <summary>AnimID field</summary>
            public LLUUID AnimID;
            /// <summary>StartAnim field</summary>
            public bool StartAnim;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AnimationListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AnimationListBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AnimID = new LLUUID(bytes, i); i += 16;
                    StartAnim = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AnimID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((StartAnim) ? 1 : 0);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentAnimation</summary>
        public override PacketType Type { get { return PacketType.AgentAnimation; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;
        /// <summary>AnimationList block</summary>
        public AnimationListBlock[] AnimationList;

        /// <summary>Default constructor</summary>
        public AgentAnimationPacket()
        {
            Header = new HighHeader();
            Header.ID = 6;
            Header.Reliable = true;
            Sender = new SenderBlock();
            AnimationList = new AnimationListBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentAnimationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
            int count = (int)bytes[i++];
            AnimationList = new AnimationListBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationList[j] = new AnimationListBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentAnimationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
            int count = (int)bytes[i++];
            AnimationList = new AnimationListBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationList[j] = new AnimationListBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += Sender.Length;;
            for (int j = 0; j < AnimationList.Length; j++) { length += AnimationList[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AnimationList.Length;
            for (int j = 0; j < AnimationList.Length; j++) { AnimationList[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentRequestSit packet</summary>
    public class AgentRequestSitPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>TargetObject block</summary>
        public class TargetObjectBlock
        {
            /// <summary>TargetID field</summary>
            public LLUUID TargetID;
            /// <summary>Offset field</summary>
            public LLVector3 Offset;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TargetObjectBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TargetObjectBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TargetID = new LLUUID(bytes, i); i += 16;
                    Offset = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TargetID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Offset.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentRequestSit</summary>
        public override PacketType Type { get { return PacketType.AgentRequestSit; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;
        /// <summary>TargetObject block</summary>
        public TargetObjectBlock TargetObject;

        /// <summary>Default constructor</summary>
        public AgentRequestSitPacket()
        {
            Header = new HighHeader();
            Header.ID = 7;
            Header.Reliable = true;
            Header.Zerocoded = true;
            Sender = new SenderBlock();
            TargetObject = new TargetObjectBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentRequestSitPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
            TargetObject = new TargetObjectBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentRequestSitPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
            TargetObject = new TargetObjectBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += Sender.Length;            length += TargetObject.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            TargetObject.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentSit packet</summary>
    public class AgentSitPacket : Packet
    {
        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentSit</summary>
        public override PacketType Type { get { return PacketType.AgentSit; } }
        /// <summary>Sender block</summary>
        public SenderBlock Sender;

        /// <summary>Default constructor</summary>
        public AgentSitPacket()
        {
            Header = new HighHeader();
            Header.ID = 8;
            Header.Reliable = true;
            Sender = new SenderBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentSitPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentSitPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            Sender = new SenderBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += Sender.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            Sender.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>RequestImage packet</summary>
    public class RequestImagePacket : Packet
    {
        /// <summary>RequestImage block</summary>
        public class RequestImageBlock
        {
            /// <summary>DownloadPriority field</summary>
            public float DownloadPriority;
            /// <summary>DiscardLevel field</summary>
            public int DiscardLevel;
            /// <summary>Packet field</summary>
            public uint Packet;
            /// <summary>Image field</summary>
            public LLUUID Image;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 29;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RequestImageBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RequestImageBlock(byte[] bytes, ref int i)
            {
                try
                {
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    DownloadPriority = BitConverter.ToSingle(bytes, i); i += 4;
                    DiscardLevel = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Packet = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Image = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                ba = BitConverter.GetBytes(DownloadPriority);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(DiscardLevel % 256);
                bytes[i++] = (byte)((DiscardLevel >> 8) % 256);
                bytes[i++] = (byte)((DiscardLevel >> 16) % 256);
                bytes[i++] = (byte)((DiscardLevel >> 24) % 256);
                bytes[i++] = (byte)(Packet % 256);
                bytes[i++] = (byte)((Packet >> 8) % 256);
                bytes[i++] = (byte)((Packet >> 16) % 256);
                bytes[i++] = (byte)((Packet >> 24) % 256);
                Array.Copy(Image.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.RequestImage</summary>
        public override PacketType Type { get { return PacketType.RequestImage; } }
        /// <summary>RequestImage block</summary>
        public RequestImageBlock[] RequestImage;

        /// <summary>Default constructor</summary>
        public RequestImagePacket()
        {
            Header = new HighHeader();
            Header.ID = 9;
            Header.Reliable = true;
            RequestImage = new RequestImageBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public RequestImagePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            RequestImage = new RequestImageBlock[count];
            for (int j = 0; j < count; j++)
            { RequestImage[j] = new RequestImageBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public RequestImagePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            RequestImage = new RequestImageBlock[count];
            for (int j = 0; j < count; j++)
            { RequestImage[j] = new RequestImageBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
;
            for (int j = 0; j < RequestImage.Length; j++) { length += RequestImage[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)RequestImage.Length;
            for (int j = 0; j < RequestImage.Length; j++) { RequestImage[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ImageData packet</summary>
    public class ImageDataPacket : Packet
    {
        /// <summary>ImageID block</summary>
        public class ImageIDBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Packets field</summary>
            public ushort Packets;
            /// <summary>Size field</summary>
            public uint Size;
            /// <summary>Codec field</summary>
            public byte Codec;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 23;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ImageIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ImageIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    Packets = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Size = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Codec = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Packets % 256);
                bytes[i++] = (byte)((Packets >> 8) % 256);
                bytes[i++] = (byte)(Size % 256);
                bytes[i++] = (byte)((Size >> 8) % 256);
                bytes[i++] = (byte)((Size >> 16) % 256);
                bytes[i++] = (byte)((Size >> 24) % 256);
                bytes[i++] = Codec;
            }
        }

        /// <summary>ImageData block</summary>
        public class ImageDataBlock
        {
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Data != null) { length += 2 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ImageDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ImageDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ImageData</summary>
        public override PacketType Type { get { return PacketType.ImageData; } }
        /// <summary>ImageID block</summary>
        public ImageIDBlock ImageID;
        /// <summary>ImageData block</summary>
        public ImageDataBlock ImageData;

        /// <summary>Default constructor</summary>
        public ImageDataPacket()
        {
            Header = new HighHeader();
            Header.ID = 10;
            Header.Reliable = true;
            ImageID = new ImageIDBlock();
            ImageData = new ImageDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ImageDataPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            ImageID = new ImageIDBlock(bytes, ref i);
            ImageData = new ImageDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ImageDataPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ImageID = new ImageIDBlock(bytes, ref i);
            ImageData = new ImageDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += ImageID.Length;            length += ImageData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ImageID.ToBytes(bytes, ref i);
            ImageData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ImagePacket packet</summary>
    public class ImagePacketPacket : Packet
    {
        /// <summary>ImageID block</summary>
        public class ImageIDBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>Packet field</summary>
            public ushort Packet;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 18;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ImageIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ImageIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    Packet = (ushort)(bytes[i++] + (bytes[i++] << 8));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Packet % 256);
                bytes[i++] = (byte)((Packet >> 8) % 256);
            }
        }

        /// <summary>ImageData block</summary>
        public class ImageDataBlock
        {
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Data != null) { length += 2 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ImageDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ImageDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ImagePacket</summary>
        public override PacketType Type { get { return PacketType.ImagePacket; } }
        /// <summary>ImageID block</summary>
        public ImageIDBlock ImageID;
        /// <summary>ImageData block</summary>
        public ImageDataBlock ImageData;

        /// <summary>Default constructor</summary>
        public ImagePacketPacket()
        {
            Header = new HighHeader();
            Header.ID = 11;
            Header.Reliable = true;
            ImageID = new ImageIDBlock();
            ImageData = new ImageDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ImagePacketPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            ImageID = new ImageIDBlock(bytes, ref i);
            ImageData = new ImageDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ImagePacketPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ImageID = new ImageIDBlock(bytes, ref i);
            ImageData = new ImageDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += ImageID.Length;            length += ImageData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ImageID.ToBytes(bytes, ref i);
            ImageData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>LayerData packet</summary>
    public class LayerDataPacket : Packet
    {
        /// <summary>LayerID block</summary>
        public class LayerIDBlock
        {
            /// <summary>Type field</summary>
            public byte Type;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public LayerIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public LayerIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Type = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = Type;
            }
        }

        /// <summary>LayerData block</summary>
        public class LayerDataBlock
        {
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Data != null) { length += 2 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public LayerDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public LayerDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.LayerData</summary>
        public override PacketType Type { get { return PacketType.LayerData; } }
        /// <summary>LayerID block</summary>
        public LayerIDBlock LayerID;
        /// <summary>LayerData block</summary>
        public LayerDataBlock LayerData;

        /// <summary>Default constructor</summary>
        public LayerDataPacket()
        {
            Header = new HighHeader();
            Header.ID = 12;
            Header.Reliable = true;
            LayerID = new LayerIDBlock();
            LayerData = new LayerDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public LayerDataPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            LayerID = new LayerIDBlock(bytes, ref i);
            LayerData = new LayerDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public LayerDataPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            LayerID = new LayerIDBlock(bytes, ref i);
            LayerData = new LayerDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += LayerID.Length;            length += LayerData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            LayerID.ToBytes(bytes, ref i);
            LayerData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectUpdate packet</summary>
    public class ObjectUpdatePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ID field</summary>
            public uint ID;
            /// <summary>UpdateFlags field</summary>
            public uint UpdateFlags;
            private byte[] _objectdata;
            /// <summary>ObjectData field</summary>
            public byte[] ObjectData
            {
                get { return _objectdata; }
                set
                {
                    if (value == null) { _objectdata = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _objectdata = new byte[value.Length]; Array.Copy(value, _objectdata, value.Length); }
                }
            }
            /// <summary>PathTwistBegin field</summary>
            public sbyte PathTwistBegin;
            /// <summary>CRC field</summary>
            public uint CRC;
            /// <summary>JointPivot field</summary>
            public LLVector3 JointPivot;
            /// <summary>PathEnd field</summary>
            public byte PathEnd;
            private byte[] _mediaurl;
            /// <summary>MediaURL field</summary>
            public byte[] MediaURL
            {
                get { return _mediaurl; }
                set
                {
                    if (value == null) { _mediaurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mediaurl = new byte[value.Length]; Array.Copy(value, _mediaurl, value.Length); }
                }
            }
            /// <summary>TextColor field</summary>
            public byte[] TextColor;
            /// <summary>ClickAction field</summary>
            public byte ClickAction;
            /// <summary>ProfileBegin field</summary>
            public byte ProfileBegin;
            /// <summary>PathRadiusOffset field</summary>
            public sbyte PathRadiusOffset;
            /// <summary>Gain field</summary>
            public float Gain;
            /// <summary>PathSkew field</summary>
            public sbyte PathSkew;
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }
            private byte[] _textureanim;
            /// <summary>TextureAnim field</summary>
            public byte[] TextureAnim
            {
                get { return _textureanim; }
                set
                {
                    if (value == null) { _textureanim = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _textureanim = new byte[value.Length]; Array.Copy(value, _textureanim, value.Length); }
                }
            }
            /// <summary>ParentID field</summary>
            public uint ParentID;
            private byte[] _text;
            /// <summary>Text field</summary>
            public byte[] Text
            {
                get { return _text; }
                set
                {
                    if (value == null) { _text = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _text = new byte[value.Length]; Array.Copy(value, _text, value.Length); }
                }
            }
            /// <summary>ProfileCurve field</summary>
            public byte ProfileCurve;
            /// <summary>PathScaleX field</summary>
            public byte PathScaleX;
            /// <summary>PathScaleY field</summary>
            public byte PathScaleY;
            /// <summary>Material field</summary>
            public byte Material;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            private byte[] _extraparams;
            /// <summary>ExtraParams field</summary>
            public byte[] ExtraParams
            {
                get { return _extraparams; }
                set
                {
                    if (value == null) { _extraparams = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _extraparams = new byte[value.Length]; Array.Copy(value, _extraparams, value.Length); }
                }
            }
            private byte[] _namevalue;
            /// <summary>NameValue field</summary>
            public byte[] NameValue
            {
                get { return _namevalue; }
                set
                {
                    if (value == null) { _namevalue = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _namevalue = new byte[value.Length]; Array.Copy(value, _namevalue, value.Length); }
                }
            }
            /// <summary>PathShearX field</summary>
            public byte PathShearX;
            /// <summary>PathShearY field</summary>
            public byte PathShearY;
            /// <summary>PathTaperX field</summary>
            public sbyte PathTaperX;
            /// <summary>PathTaperY field</summary>
            public sbyte PathTaperY;
            /// <summary>Radius field</summary>
            public float Radius;
            /// <summary>ProfileEnd field</summary>
            public byte ProfileEnd;
            /// <summary>JointType field</summary>
            public byte JointType;
            /// <summary>PathBegin field</summary>
            public byte PathBegin;
            private byte[] _psblock;
            /// <summary>PSBlock field</summary>
            public byte[] PSBlock
            {
                get { return _psblock; }
                set
                {
                    if (value == null) { _psblock = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _psblock = new byte[value.Length]; Array.Copy(value, _psblock, value.Length); }
                }
            }
            /// <summary>PCode field</summary>
            public byte PCode;
            /// <summary>FullID field</summary>
            public LLUUID FullID;
            /// <summary>PathCurve field</summary>
            public byte PathCurve;
            /// <summary>Scale field</summary>
            public LLVector3 Scale;
            /// <summary>JointAxisOrAnchor field</summary>
            public LLVector3 JointAxisOrAnchor;
            /// <summary>Flags field</summary>
            public byte Flags;
            /// <summary>State field</summary>
            public byte State;
            /// <summary>PathTwist field</summary>
            public sbyte PathTwist;
            /// <summary>Sound field</summary>
            public LLUUID Sound;
            private byte[] _textureentry;
            /// <summary>TextureEntry field</summary>
            public byte[] TextureEntry
            {
                get { return _textureentry; }
                set
                {
                    if (value == null) { _textureentry = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _textureentry = new byte[value.Length]; Array.Copy(value, _textureentry, value.Length); }
                }
            }
            /// <summary>ProfileHollow field</summary>
            public byte ProfileHollow;
            /// <summary>PathRevolutions field</summary>
            public byte PathRevolutions;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 137;
                    if (ObjectData != null) { length += 1 + ObjectData.Length; }
                    if (MediaURL != null) { length += 1 + MediaURL.Length; }
                    if (Data != null) { length += 2 + Data.Length; }
                    if (TextureAnim != null) { length += 1 + TextureAnim.Length; }
                    if (Text != null) { length += 1 + Text.Length; }
                    if (ExtraParams != null) { length += 1 + ExtraParams.Length; }
                    if (NameValue != null) { length += 2 + NameValue.Length; }
                    if (PSBlock != null) { length += 1 + PSBlock.Length; }
                    if (TextureEntry != null) { length += 2 + TextureEntry.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    UpdateFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _objectdata = new byte[length];
                    Array.Copy(bytes, i, _objectdata, 0, length); i += length;
                    PathTwistBegin = (sbyte)bytes[i++];
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    JointPivot = new LLVector3(bytes, i); i += 12;
                    PathEnd = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _mediaurl = new byte[length];
                    Array.Copy(bytes, i, _mediaurl, 0, length); i += length;
                    TextColor = new byte[4];
                    Array.Copy(bytes, i, TextColor, 0, 4); i += 4;
                    ClickAction = (byte)bytes[i++];
                    ProfileBegin = (byte)bytes[i++];
                    PathRadiusOffset = (sbyte)bytes[i++];
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Gain = BitConverter.ToSingle(bytes, i); i += 4;
                    PathSkew = (sbyte)bytes[i++];
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                    length = (ushort)bytes[i++];
                    _textureanim = new byte[length];
                    Array.Copy(bytes, i, _textureanim, 0, length); i += length;
                    ParentID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _text = new byte[length];
                    Array.Copy(bytes, i, _text, 0, length); i += length;
                    ProfileCurve = (byte)bytes[i++];
                    PathScaleX = (byte)bytes[i++];
                    PathScaleY = (byte)bytes[i++];
                    Material = (byte)bytes[i++];
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _extraparams = new byte[length];
                    Array.Copy(bytes, i, _extraparams, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _namevalue = new byte[length];
                    Array.Copy(bytes, i, _namevalue, 0, length); i += length;
                    PathShearX = (byte)bytes[i++];
                    PathShearY = (byte)bytes[i++];
                    PathTaperX = (sbyte)bytes[i++];
                    PathTaperY = (sbyte)bytes[i++];
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Radius = BitConverter.ToSingle(bytes, i); i += 4;
                    ProfileEnd = (byte)bytes[i++];
                    JointType = (byte)bytes[i++];
                    PathBegin = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _psblock = new byte[length];
                    Array.Copy(bytes, i, _psblock, 0, length); i += length;
                    PCode = (byte)bytes[i++];
                    FullID = new LLUUID(bytes, i); i += 16;
                    PathCurve = (byte)bytes[i++];
                    Scale = new LLVector3(bytes, i); i += 12;
                    JointAxisOrAnchor = new LLVector3(bytes, i); i += 12;
                    Flags = (byte)bytes[i++];
                    State = (byte)bytes[i++];
                    PathTwist = (sbyte)bytes[i++];
                    Sound = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _textureentry = new byte[length];
                    Array.Copy(bytes, i, _textureentry, 0, length); i += length;
                    ProfileHollow = (byte)bytes[i++];
                    PathRevolutions = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
                bytes[i++] = (byte)(UpdateFlags % 256);
                bytes[i++] = (byte)((UpdateFlags >> 8) % 256);
                bytes[i++] = (byte)((UpdateFlags >> 16) % 256);
                bytes[i++] = (byte)((UpdateFlags >> 24) % 256);
                bytes[i++] = (byte)ObjectData.Length;
                Array.Copy(ObjectData, 0, bytes, i, ObjectData.Length); i += ObjectData.Length;
                bytes[i++] = (byte)PathTwistBegin;
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
                Array.Copy(JointPivot.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = PathEnd;
                bytes[i++] = (byte)MediaURL.Length;
                Array.Copy(MediaURL, 0, bytes, i, MediaURL.Length); i += MediaURL.Length;
                Array.Copy(TextColor, 0, bytes, i, 4);i += 4;
                bytes[i++] = ClickAction;
                bytes[i++] = ProfileBegin;
                bytes[i++] = (byte)PathRadiusOffset;
                ba = BitConverter.GetBytes(Gain);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)PathSkew;
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
                bytes[i++] = (byte)TextureAnim.Length;
                Array.Copy(TextureAnim, 0, bytes, i, TextureAnim.Length); i += TextureAnim.Length;
                bytes[i++] = (byte)(ParentID % 256);
                bytes[i++] = (byte)((ParentID >> 8) % 256);
                bytes[i++] = (byte)((ParentID >> 16) % 256);
                bytes[i++] = (byte)((ParentID >> 24) % 256);
                bytes[i++] = (byte)Text.Length;
                Array.Copy(Text, 0, bytes, i, Text.Length); i += Text.Length;
                bytes[i++] = ProfileCurve;
                bytes[i++] = PathScaleX;
                bytes[i++] = PathScaleY;
                bytes[i++] = Material;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)ExtraParams.Length;
                Array.Copy(ExtraParams, 0, bytes, i, ExtraParams.Length); i += ExtraParams.Length;
                bytes[i++] = (byte)(NameValue.Length % 256);
                bytes[i++] = (byte)((NameValue.Length >> 8) % 256);
                Array.Copy(NameValue, 0, bytes, i, NameValue.Length); i += NameValue.Length;
                bytes[i++] = PathShearX;
                bytes[i++] = PathShearY;
                bytes[i++] = (byte)PathTaperX;
                bytes[i++] = (byte)PathTaperY;
                ba = BitConverter.GetBytes(Radius);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = ProfileEnd;
                bytes[i++] = JointType;
                bytes[i++] = PathBegin;
                bytes[i++] = (byte)PSBlock.Length;
                Array.Copy(PSBlock, 0, bytes, i, PSBlock.Length); i += PSBlock.Length;
                bytes[i++] = PCode;
                Array.Copy(FullID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = PathCurve;
                Array.Copy(Scale.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(JointAxisOrAnchor.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = Flags;
                bytes[i++] = State;
                bytes[i++] = (byte)PathTwist;
                Array.Copy(Sound.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(TextureEntry.Length % 256);
                bytes[i++] = (byte)((TextureEntry.Length >> 8) % 256);
                Array.Copy(TextureEntry, 0, bytes, i, TextureEntry.Length); i += TextureEntry.Length;
                bytes[i++] = ProfileHollow;
                bytes[i++] = PathRevolutions;
            }
        }

        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>TimeDilation field</summary>
            public ushort TimeDilation;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 10;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TimeDilation = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TimeDilation % 256);
                bytes[i++] = (byte)((TimeDilation >> 8) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectUpdate</summary>
        public override PacketType Type { get { return PacketType.ObjectUpdate; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public ObjectUpdatePacket()
        {
            Header = new HighHeader();
            Header.ID = 13;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock[0];
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += RegionData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectUpdateCompressed packet</summary>
    public class ObjectUpdateCompressedPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>UpdateFlags field</summary>
            public uint UpdateFlags;
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    if (Data != null) { length += 2 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    UpdateFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(UpdateFlags % 256);
                bytes[i++] = (byte)((UpdateFlags >> 8) % 256);
                bytes[i++] = (byte)((UpdateFlags >> 16) % 256);
                bytes[i++] = (byte)((UpdateFlags >> 24) % 256);
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
            }
        }

        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>TimeDilation field</summary>
            public ushort TimeDilation;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 10;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TimeDilation = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TimeDilation % 256);
                bytes[i++] = (byte)((TimeDilation >> 8) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectUpdateCompressed</summary>
        public override PacketType Type { get { return PacketType.ObjectUpdateCompressed; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public ObjectUpdateCompressedPacket()
        {
            Header = new HighHeader();
            Header.ID = 14;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectUpdateCompressedPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectUpdateCompressedPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += RegionData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ObjectUpdateCached packet</summary>
    public class ObjectUpdateCachedPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ID field</summary>
            public uint ID;
            /// <summary>UpdateFlags field</summary>
            public uint UpdateFlags;
            /// <summary>CRC field</summary>
            public uint CRC;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 13;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    UpdateFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    CRC = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
                bytes[i++] = (byte)(UpdateFlags % 256);
                bytes[i++] = (byte)((UpdateFlags >> 8) % 256);
                bytes[i++] = (byte)((UpdateFlags >> 16) % 256);
                bytes[i++] = (byte)((UpdateFlags >> 24) % 256);
                bytes[i++] = (byte)(CRC % 256);
                bytes[i++] = (byte)((CRC >> 8) % 256);
                bytes[i++] = (byte)((CRC >> 16) % 256);
                bytes[i++] = (byte)((CRC >> 24) % 256);
            }
        }

        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>TimeDilation field</summary>
            public ushort TimeDilation;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 10;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TimeDilation = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TimeDilation % 256);
                bytes[i++] = (byte)((TimeDilation >> 8) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ObjectUpdateCached</summary>
        public override PacketType Type { get { return PacketType.ObjectUpdateCached; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public ObjectUpdateCachedPacket()
        {
            Header = new HighHeader();
            Header.ID = 15;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ObjectUpdateCachedPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ObjectUpdateCachedPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += RegionData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ImprovedTerseObjectUpdate packet</summary>
    public class ImprovedTerseObjectUpdatePacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }
            private byte[] _textureentry;
            /// <summary>TextureEntry field</summary>
            public byte[] TextureEntry
            {
                get { return _textureentry; }
                set
                {
                    if (value == null) { _textureentry = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _textureentry = new byte[value.Length]; Array.Copy(value, _textureentry, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (Data != null) { length += 1 + Data.Length; }
                    if (TextureEntry != null) { length += 2 + TextureEntry.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)bytes[i++];
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _textureentry = new byte[length];
                    Array.Copy(bytes, i, _textureentry, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)Data.Length;
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
                bytes[i++] = (byte)(TextureEntry.Length % 256);
                bytes[i++] = (byte)((TextureEntry.Length >> 8) % 256);
                Array.Copy(TextureEntry, 0, bytes, i, TextureEntry.Length); i += TextureEntry.Length;
            }
        }

        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>TimeDilation field</summary>
            public ushort TimeDilation;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 10;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    TimeDilation = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(TimeDilation % 256);
                bytes[i++] = (byte)((TimeDilation >> 8) % 256);
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ImprovedTerseObjectUpdate</summary>
        public override PacketType Type { get { return PacketType.ImprovedTerseObjectUpdate; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public ImprovedTerseObjectUpdatePacket()
        {
            Header = new HighHeader();
            Header.ID = 16;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ImprovedTerseObjectUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ImprovedTerseObjectUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += RegionData.Length;;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>KillObject packet</summary>
    public class KillObjectPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ID field</summary>
            public uint ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 5;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.KillObject</summary>
        public override PacketType Type { get { return PacketType.KillObject; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock[] ObjectData;

        /// <summary>Default constructor</summary>
        public KillObjectPacket()
        {
            Header = new HighHeader();
            Header.ID = 17;
            Header.Reliable = true;
            ObjectData = new ObjectDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public KillObjectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public KillObjectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            ObjectData = new ObjectDataBlock[count];
            for (int j = 0; j < count; j++)
            { ObjectData[j] = new ObjectDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
;
            for (int j = 0; j < ObjectData.Length; j++) { length += ObjectData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)ObjectData.Length;
            for (int j = 0; j < ObjectData.Length; j++) { ObjectData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AgentToNewRegion packet</summary>
    public class AgentToNewRegionPacket : Packet
    {
        /// <summary>RegionData block</summary>
        public class RegionDataBlock
        {
            /// <summary>IP field</summary>
            public uint IP;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>Port field</summary>
            public ushort Port;
            /// <summary>Handle field</summary>
            public ulong Handle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 30;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public RegionDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public RegionDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    IP = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SessionID = new LLUUID(bytes, i); i += 16;
                    Port = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    Handle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(IP % 256);
                bytes[i++] = (byte)((IP >> 8) % 256);
                bytes[i++] = (byte)((IP >> 16) % 256);
                bytes[i++] = (byte)((IP >> 24) % 256);
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Port % 256);
                bytes[i++] = (byte)((Port >> 8) % 256);
                bytes[i++] = (byte)(Handle % 256);
                bytes[i++] = (byte)((Handle >> 8) % 256);
                bytes[i++] = (byte)((Handle >> 16) % 256);
                bytes[i++] = (byte)((Handle >> 24) % 256);
                bytes[i++] = (byte)((Handle >> 32) % 256);
                bytes[i++] = (byte)((Handle >> 40) % 256);
                bytes[i++] = (byte)((Handle >> 48) % 256);
                bytes[i++] = (byte)((Handle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AgentToNewRegion</summary>
        public override PacketType Type { get { return PacketType.AgentToNewRegion; } }
        /// <summary>RegionData block</summary>
        public RegionDataBlock RegionData;

        /// <summary>Default constructor</summary>
        public AgentToNewRegionPacket()
        {
            Header = new HighHeader();
            Header.ID = 18;
            Header.Reliable = true;
            RegionData = new RegionDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AgentToNewRegionPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AgentToNewRegionPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            RegionData = new RegionDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += RegionData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            RegionData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>TransferPacket packet</summary>
    public class TransferPacketPacket : Packet
    {
        /// <summary>TransferData block</summary>
        public class TransferDataBlock
        {
            /// <summary>TransferID field</summary>
            public LLUUID TransferID;
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }
            /// <summary>Packet field</summary>
            public int Packet;
            /// <summary>ChannelType field</summary>
            public int ChannelType;
            /// <summary>Status field</summary>
            public int Status;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 28;
                    if (Data != null) { length += 2 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TransferDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TransferDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    TransferID = new LLUUID(bytes, i); i += 16;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                    Packet = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ChannelType = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Status = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(TransferID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
                bytes[i++] = (byte)(Packet % 256);
                bytes[i++] = (byte)((Packet >> 8) % 256);
                bytes[i++] = (byte)((Packet >> 16) % 256);
                bytes[i++] = (byte)((Packet >> 24) % 256);
                bytes[i++] = (byte)(ChannelType % 256);
                bytes[i++] = (byte)((ChannelType >> 8) % 256);
                bytes[i++] = (byte)((ChannelType >> 16) % 256);
                bytes[i++] = (byte)((ChannelType >> 24) % 256);
                bytes[i++] = (byte)(Status % 256);
                bytes[i++] = (byte)((Status >> 8) % 256);
                bytes[i++] = (byte)((Status >> 16) % 256);
                bytes[i++] = (byte)((Status >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.TransferPacket</summary>
        public override PacketType Type { get { return PacketType.TransferPacket; } }
        /// <summary>TransferData block</summary>
        public TransferDataBlock TransferData;

        /// <summary>Default constructor</summary>
        public TransferPacketPacket()
        {
            Header = new HighHeader();
            Header.ID = 19;
            Header.Reliable = true;
            TransferData = new TransferDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public TransferPacketPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            TransferData = new TransferDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public TransferPacketPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TransferData = new TransferDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += TransferData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TransferData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SendXferPacket packet</summary>
    public class SendXferPacketPacket : Packet
    {
        /// <summary>DataPacket block</summary>
        public class DataPacketBlock
        {
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 0;
                    if (Data != null) { length += 2 + Data.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public DataPacketBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public DataPacketBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
            }
        }

        /// <summary>XferID block</summary>
        public class XferIDBlock
        {
            /// <summary>ID field</summary>
            public ulong ID;
            /// <summary>Packet field</summary>
            public uint Packet;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public XferIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public XferIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Packet = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
                bytes[i++] = (byte)((ID >> 32) % 256);
                bytes[i++] = (byte)((ID >> 40) % 256);
                bytes[i++] = (byte)((ID >> 48) % 256);
                bytes[i++] = (byte)((ID >> 56) % 256);
                bytes[i++] = (byte)(Packet % 256);
                bytes[i++] = (byte)((Packet >> 8) % 256);
                bytes[i++] = (byte)((Packet >> 16) % 256);
                bytes[i++] = (byte)((Packet >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SendXferPacket</summary>
        public override PacketType Type { get { return PacketType.SendXferPacket; } }
        /// <summary>DataPacket block</summary>
        public DataPacketBlock DataPacket;
        /// <summary>XferID block</summary>
        public XferIDBlock XferID;

        /// <summary>Default constructor</summary>
        public SendXferPacketPacket()
        {
            Header = new HighHeader();
            Header.ID = 20;
            Header.Reliable = true;
            DataPacket = new DataPacketBlock();
            XferID = new XferIDBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SendXferPacketPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            DataPacket = new DataPacketBlock(bytes, ref i);
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SendXferPacketPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            DataPacket = new DataPacketBlock(bytes, ref i);
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += DataPacket.Length;            length += XferID.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            DataPacket.ToBytes(bytes, ref i);
            XferID.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ConfirmXferPacket packet</summary>
    public class ConfirmXferPacketPacket : Packet
    {
        /// <summary>XferID block</summary>
        public class XferIDBlock
        {
            /// <summary>ID field</summary>
            public ulong ID;
            /// <summary>Packet field</summary>
            public uint Packet;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 12;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public XferIDBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public XferIDBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Packet = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ID % 256);
                bytes[i++] = (byte)((ID >> 8) % 256);
                bytes[i++] = (byte)((ID >> 16) % 256);
                bytes[i++] = (byte)((ID >> 24) % 256);
                bytes[i++] = (byte)((ID >> 32) % 256);
                bytes[i++] = (byte)((ID >> 40) % 256);
                bytes[i++] = (byte)((ID >> 48) % 256);
                bytes[i++] = (byte)((ID >> 56) % 256);
                bytes[i++] = (byte)(Packet % 256);
                bytes[i++] = (byte)((Packet >> 8) % 256);
                bytes[i++] = (byte)((Packet >> 16) % 256);
                bytes[i++] = (byte)((Packet >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ConfirmXferPacket</summary>
        public override PacketType Type { get { return PacketType.ConfirmXferPacket; } }
        /// <summary>XferID block</summary>
        public XferIDBlock XferID;

        /// <summary>Default constructor</summary>
        public ConfirmXferPacketPacket()
        {
            Header = new HighHeader();
            Header.ID = 21;
            Header.Reliable = true;
            XferID = new XferIDBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ConfirmXferPacketPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ConfirmXferPacketPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            XferID = new XferIDBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += XferID.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            XferID.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarAnimation packet</summary>
    public class AvatarAnimationPacket : Packet
    {
        /// <summary>AnimationSourceList block</summary>
        public class AnimationSourceListBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AnimationSourceListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AnimationSourceListBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>Sender block</summary>
        public class SenderBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SenderBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SenderBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AnimationList block</summary>
        public class AnimationListBlock
        {
            /// <summary>AnimID field</summary>
            public LLUUID AnimID;
            /// <summary>AnimSequenceID field</summary>
            public int AnimSequenceID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 21;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AnimationListBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AnimationListBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AnimID = new LLUUID(bytes, i); i += 16;
                    AnimSequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(AnimID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(AnimSequenceID % 256);
                bytes[i++] = (byte)((AnimSequenceID >> 8) % 256);
                bytes[i++] = (byte)((AnimSequenceID >> 16) % 256);
                bytes[i++] = (byte)((AnimSequenceID >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarAnimation</summary>
        public override PacketType Type { get { return PacketType.AvatarAnimation; } }
        /// <summary>AnimationSourceList block</summary>
        public AnimationSourceListBlock[] AnimationSourceList;
        /// <summary>Sender block</summary>
        public SenderBlock Sender;
        /// <summary>AnimationList block</summary>
        public AnimationListBlock[] AnimationList;

        /// <summary>Default constructor</summary>
        public AvatarAnimationPacket()
        {
            Header = new HighHeader();
            Header.ID = 22;
            Header.Reliable = true;
            AnimationSourceList = new AnimationSourceListBlock[0];
            Sender = new SenderBlock();
            AnimationList = new AnimationListBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarAnimationPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            AnimationSourceList = new AnimationSourceListBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationSourceList[j] = new AnimationSourceListBlock(bytes, ref i); }
            Sender = new SenderBlock(bytes, ref i);
            count = (int)bytes[i++];
            AnimationList = new AnimationListBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationList[j] = new AnimationListBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarAnimationPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            AnimationSourceList = new AnimationSourceListBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationSourceList[j] = new AnimationSourceListBlock(bytes, ref i); }
            Sender = new SenderBlock(bytes, ref i);
            count = (int)bytes[i++];
            AnimationList = new AnimationListBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationList[j] = new AnimationListBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += Sender.Length;;
            for (int j = 0; j < AnimationSourceList.Length; j++) { length += AnimationSourceList[j].Length; }
            for (int j = 0; j < AnimationList.Length; j++) { length += AnimationList[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AnimationSourceList.Length;
            for (int j = 0; j < AnimationSourceList.Length; j++) { AnimationSourceList[j].ToBytes(bytes, ref i); }
            Sender.ToBytes(bytes, ref i);
            bytes[i++] = (byte)AnimationList.Length;
            for (int j = 0; j < AnimationList.Length; j++) { AnimationList[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AvatarSitResponse packet</summary>
    public class AvatarSitResponsePacket : Packet
    {
        /// <summary>SitTransform block</summary>
        public class SitTransformBlock
        {
            /// <summary>AutoPilot field</summary>
            public bool AutoPilot;
            /// <summary>ForceMouselook field</summary>
            public bool ForceMouselook;
            /// <summary>CameraEyeOffset field</summary>
            public LLVector3 CameraEyeOffset;
            /// <summary>CameraAtOffset field</summary>
            public LLVector3 CameraAtOffset;
            /// <summary>SitPosition field</summary>
            public LLVector3 SitPosition;
            /// <summary>SitRotation field</summary>
            public LLQuaternion SitRotation;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 54;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SitTransformBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SitTransformBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AutoPilot = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    ForceMouselook = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    CameraEyeOffset = new LLVector3(bytes, i); i += 12;
                    CameraAtOffset = new LLVector3(bytes, i); i += 12;
                    SitPosition = new LLVector3(bytes, i); i += 12;
                    SitRotation = new LLQuaternion(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((AutoPilot) ? 1 : 0);
                bytes[i++] = (byte)((ForceMouselook) ? 1 : 0);
                Array.Copy(CameraEyeOffset.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(CameraAtOffset.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(SitPosition.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(SitRotation.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>SitObject block</summary>
        public class SitObjectBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SitObjectBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SitObjectBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AvatarSitResponse</summary>
        public override PacketType Type { get { return PacketType.AvatarSitResponse; } }
        /// <summary>SitTransform block</summary>
        public SitTransformBlock SitTransform;
        /// <summary>SitObject block</summary>
        public SitObjectBlock SitObject;

        /// <summary>Default constructor</summary>
        public AvatarSitResponsePacket()
        {
            Header = new HighHeader();
            Header.ID = 23;
            Header.Reliable = true;
            Header.Zerocoded = true;
            SitTransform = new SitTransformBlock();
            SitObject = new SitObjectBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AvatarSitResponsePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            SitTransform = new SitTransformBlock(bytes, ref i);
            SitObject = new SitObjectBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AvatarSitResponsePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SitTransform = new SitTransformBlock(bytes, ref i);
            SitObject = new SitObjectBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += SitTransform.Length;            length += SitObject.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SitTransform.ToBytes(bytes, ref i);
            SitObject.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>CameraConstraint packet</summary>
    public class CameraConstraintPacket : Packet
    {
        /// <summary>CameraCollidePlane block</summary>
        public class CameraCollidePlaneBlock
        {
            /// <summary>Plane field</summary>
            public LLVector4 Plane;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 16;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public CameraCollidePlaneBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public CameraCollidePlaneBlock(byte[] bytes, ref int i)
            {
                try
                {
                    Plane = new LLVector4(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(Plane.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.CameraConstraint</summary>
        public override PacketType Type { get { return PacketType.CameraConstraint; } }
        /// <summary>CameraCollidePlane block</summary>
        public CameraCollidePlaneBlock CameraCollidePlane;

        /// <summary>Default constructor</summary>
        public CameraConstraintPacket()
        {
            Header = new HighHeader();
            Header.ID = 24;
            Header.Reliable = true;
            Header.Zerocoded = true;
            CameraCollidePlane = new CameraCollidePlaneBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public CameraConstraintPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            CameraCollidePlane = new CameraCollidePlaneBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public CameraConstraintPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            CameraCollidePlane = new CameraCollidePlaneBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += CameraCollidePlane.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            CameraCollidePlane.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ParcelProperties packet</summary>
    public class ParcelPropertiesPacket : Packet
    {
        /// <summary>ParcelData block</summary>
        public class ParcelDataBlock
        {
            /// <summary>ReservedNewbie field</summary>
            public bool ReservedNewbie;
            /// <summary>GroupPrims field</summary>
            public int GroupPrims;
            /// <summary>SelectedPrims field</summary>
            public int SelectedPrims;
            /// <summary>MediaID field</summary>
            public LLUUID MediaID;
            /// <summary>UserLookAt field</summary>
            public LLVector3 UserLookAt;
            /// <summary>AABBMax field</summary>
            public LLVector3 AABBMax;
            /// <summary>AABBMin field</summary>
            public LLVector3 AABBMin;
            /// <summary>RequestResult field</summary>
            public int RequestResult;
            /// <summary>OwnerPrims field</summary>
            public int OwnerPrims;
            /// <summary>RegionPushOverride field</summary>
            public bool RegionPushOverride;
            /// <summary>RegionDenyAnonymous field</summary>
            public bool RegionDenyAnonymous;
            private byte[] _mediaurl;
            /// <summary>MediaURL field</summary>
            public byte[] MediaURL
            {
                get { return _mediaurl; }
                set
                {
                    if (value == null) { _mediaurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _mediaurl = new byte[value.Length]; Array.Copy(value, _mediaurl, value.Length); }
                }
            }
            /// <summary>LocalID field</summary>
            public int LocalID;
            /// <summary>SimWideMaxPrims field</summary>
            public int SimWideMaxPrims;
            /// <summary>TotalPrims field</summary>
            public int TotalPrims;
            /// <summary>OtherCount field</summary>
            public int OtherCount;
            /// <summary>IsGroupOwned field</summary>
            public bool IsGroupOwned;
            /// <summary>UserLocation field</summary>
            public LLVector3 UserLocation;
            /// <summary>MaxPrims field</summary>
            public int MaxPrims;
            private byte[] _name;
            /// <summary>Name field</summary>
            public byte[] Name
            {
                get { return _name; }
                set
                {
                    if (value == null) { _name = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _name = new byte[value.Length]; Array.Copy(value, _name, value.Length); }
                }
            }
            /// <summary>OtherCleanTime field</summary>
            public int OtherCleanTime;
            private byte[] _desc;
            /// <summary>Desc field</summary>
            public byte[] Desc
            {
                get { return _desc; }
                set
                {
                    if (value == null) { _desc = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _desc = new byte[value.Length]; Array.Copy(value, _desc, value.Length); }
                }
            }
            /// <summary>Area field</summary>
            public int Area;
            /// <summary>OtherPrims field</summary>
            public int OtherPrims;
            /// <summary>RegionDenyIdentified field</summary>
            public bool RegionDenyIdentified;
            /// <summary>Category field</summary>
            public byte Category;
            /// <summary>PublicCount field</summary>
            public int PublicCount;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>SalePrice field</summary>
            public int SalePrice;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>SequenceID field</summary>
            public int SequenceID;
            /// <summary>RegionDenyTransacted field</summary>
            public bool RegionDenyTransacted;
            /// <summary>SelfCount field</summary>
            public int SelfCount;
            private byte[] _bitmap;
            /// <summary>Bitmap field</summary>
            public byte[] Bitmap
            {
                get { return _bitmap; }
                set
                {
                    if (value == null) { _bitmap = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _bitmap = new byte[value.Length]; Array.Copy(value, _bitmap, value.Length); }
                }
            }
            /// <summary>Status field</summary>
            public byte Status;
            /// <summary>SnapshotID field</summary>
            public LLUUID SnapshotID;
            /// <summary>SnapSelection field</summary>
            public bool SnapSelection;
            /// <summary>LandingType field</summary>
            public byte LandingType;
            /// <summary>SimWideTotalPrims field</summary>
            public int SimWideTotalPrims;
            /// <summary>AuctionID field</summary>
            public uint AuctionID;
            /// <summary>AuthBuyerID field</summary>
            public LLUUID AuthBuyerID;
            /// <summary>PassHours field</summary>
            public float PassHours;
            /// <summary>ParcelFlags field</summary>
            public uint ParcelFlags;
            /// <summary>PassPrice field</summary>
            public int PassPrice;
            /// <summary>ClaimDate field</summary>
            public int ClaimDate;
            /// <summary>MediaAutoScale field</summary>
            public byte MediaAutoScale;
            private byte[] _musicurl;
            /// <summary>MusicURL field</summary>
            public byte[] MusicURL
            {
                get { return _musicurl; }
                set
                {
                    if (value == null) { _musicurl = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _musicurl = new byte[value.Length]; Array.Copy(value, _musicurl, value.Length); }
                }
            }
            /// <summary>ParcelPrimBonus field</summary>
            public float ParcelPrimBonus;
            /// <summary>ClaimPrice field</summary>
            public int ClaimPrice;
            /// <summary>RentPrice field</summary>
            public int RentPrice;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 239;
                    if (MediaURL != null) { length += 1 + MediaURL.Length; }
                    if (Name != null) { length += 1 + Name.Length; }
                    if (Desc != null) { length += 1 + Desc.Length; }
                    if (Bitmap != null) { length += 2 + Bitmap.Length; }
                    if (MusicURL != null) { length += 1 + MusicURL.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ParcelDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ParcelDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ReservedNewbie = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    GroupPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SelectedPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MediaID = new LLUUID(bytes, i); i += 16;
                    UserLookAt = new LLVector3(bytes, i); i += 12;
                    AABBMax = new LLVector3(bytes, i); i += 12;
                    AABBMin = new LLVector3(bytes, i); i += 12;
                    RequestResult = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionPushOverride = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    RegionDenyAnonymous = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    length = (ushort)bytes[i++];
                    _mediaurl = new byte[length];
                    Array.Copy(bytes, i, _mediaurl, 0, length); i += length;
                    LocalID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    SimWideMaxPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    TotalPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OtherCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    IsGroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    UserLocation = new LLVector3(bytes, i); i += 12;
                    MaxPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _name = new byte[length];
                    Array.Copy(bytes, i, _name, 0, length); i += length;
                    OtherCleanTime = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)bytes[i++];
                    _desc = new byte[length];
                    Array.Copy(bytes, i, _desc, 0, length); i += length;
                    Area = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OtherPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionDenyIdentified = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    Category = (byte)bytes[i++];
                    PublicCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    SalePrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    SequenceID = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RegionDenyTransacted = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    SelfCount = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _bitmap = new byte[length];
                    Array.Copy(bytes, i, _bitmap, 0, length); i += length;
                    Status = (byte)bytes[i++];
                    SnapshotID = new LLUUID(bytes, i); i += 16;
                    SnapSelection = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    LandingType = (byte)bytes[i++];
                    SimWideTotalPrims = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AuctionID = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AuthBuyerID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    PassHours = BitConverter.ToSingle(bytes, i); i += 4;
                    ParcelFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    PassPrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ClaimDate = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    MediaAutoScale = (byte)bytes[i++];
                    length = (ushort)bytes[i++];
                    _musicurl = new byte[length];
                    Array.Copy(bytes, i, _musicurl, 0, length); i += length;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    ParcelPrimBonus = BitConverter.ToSingle(bytes, i); i += 4;
                    ClaimPrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    RentPrice = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)((ReservedNewbie) ? 1 : 0);
                bytes[i++] = (byte)(GroupPrims % 256);
                bytes[i++] = (byte)((GroupPrims >> 8) % 256);
                bytes[i++] = (byte)((GroupPrims >> 16) % 256);
                bytes[i++] = (byte)((GroupPrims >> 24) % 256);
                bytes[i++] = (byte)(SelectedPrims % 256);
                bytes[i++] = (byte)((SelectedPrims >> 8) % 256);
                bytes[i++] = (byte)((SelectedPrims >> 16) % 256);
                bytes[i++] = (byte)((SelectedPrims >> 24) % 256);
                Array.Copy(MediaID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(UserLookAt.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(AABBMax.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(AABBMin.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(RequestResult % 256);
                bytes[i++] = (byte)((RequestResult >> 8) % 256);
                bytes[i++] = (byte)((RequestResult >> 16) % 256);
                bytes[i++] = (byte)((RequestResult >> 24) % 256);
                bytes[i++] = (byte)(OwnerPrims % 256);
                bytes[i++] = (byte)((OwnerPrims >> 8) % 256);
                bytes[i++] = (byte)((OwnerPrims >> 16) % 256);
                bytes[i++] = (byte)((OwnerPrims >> 24) % 256);
                bytes[i++] = (byte)((RegionPushOverride) ? 1 : 0);
                bytes[i++] = (byte)((RegionDenyAnonymous) ? 1 : 0);
                bytes[i++] = (byte)MediaURL.Length;
                Array.Copy(MediaURL, 0, bytes, i, MediaURL.Length); i += MediaURL.Length;
                bytes[i++] = (byte)(LocalID % 256);
                bytes[i++] = (byte)((LocalID >> 8) % 256);
                bytes[i++] = (byte)((LocalID >> 16) % 256);
                bytes[i++] = (byte)((LocalID >> 24) % 256);
                bytes[i++] = (byte)(SimWideMaxPrims % 256);
                bytes[i++] = (byte)((SimWideMaxPrims >> 8) % 256);
                bytes[i++] = (byte)((SimWideMaxPrims >> 16) % 256);
                bytes[i++] = (byte)((SimWideMaxPrims >> 24) % 256);
                bytes[i++] = (byte)(TotalPrims % 256);
                bytes[i++] = (byte)((TotalPrims >> 8) % 256);
                bytes[i++] = (byte)((TotalPrims >> 16) % 256);
                bytes[i++] = (byte)((TotalPrims >> 24) % 256);
                bytes[i++] = (byte)(OtherCount % 256);
                bytes[i++] = (byte)((OtherCount >> 8) % 256);
                bytes[i++] = (byte)((OtherCount >> 16) % 256);
                bytes[i++] = (byte)((OtherCount >> 24) % 256);
                bytes[i++] = (byte)((IsGroupOwned) ? 1 : 0);
                Array.Copy(UserLocation.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(MaxPrims % 256);
                bytes[i++] = (byte)((MaxPrims >> 8) % 256);
                bytes[i++] = (byte)((MaxPrims >> 16) % 256);
                bytes[i++] = (byte)((MaxPrims >> 24) % 256);
                bytes[i++] = (byte)Name.Length;
                Array.Copy(Name, 0, bytes, i, Name.Length); i += Name.Length;
                bytes[i++] = (byte)(OtherCleanTime % 256);
                bytes[i++] = (byte)((OtherCleanTime >> 8) % 256);
                bytes[i++] = (byte)((OtherCleanTime >> 16) % 256);
                bytes[i++] = (byte)((OtherCleanTime >> 24) % 256);
                bytes[i++] = (byte)Desc.Length;
                Array.Copy(Desc, 0, bytes, i, Desc.Length); i += Desc.Length;
                bytes[i++] = (byte)(Area % 256);
                bytes[i++] = (byte)((Area >> 8) % 256);
                bytes[i++] = (byte)((Area >> 16) % 256);
                bytes[i++] = (byte)((Area >> 24) % 256);
                bytes[i++] = (byte)(OtherPrims % 256);
                bytes[i++] = (byte)((OtherPrims >> 8) % 256);
                bytes[i++] = (byte)((OtherPrims >> 16) % 256);
                bytes[i++] = (byte)((OtherPrims >> 24) % 256);
                bytes[i++] = (byte)((RegionDenyIdentified) ? 1 : 0);
                bytes[i++] = Category;
                bytes[i++] = (byte)(PublicCount % 256);
                bytes[i++] = (byte)((PublicCount >> 8) % 256);
                bytes[i++] = (byte)((PublicCount >> 16) % 256);
                bytes[i++] = (byte)((PublicCount >> 24) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SalePrice % 256);
                bytes[i++] = (byte)((SalePrice >> 8) % 256);
                bytes[i++] = (byte)((SalePrice >> 16) % 256);
                bytes[i++] = (byte)((SalePrice >> 24) % 256);
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(SequenceID % 256);
                bytes[i++] = (byte)((SequenceID >> 8) % 256);
                bytes[i++] = (byte)((SequenceID >> 16) % 256);
                bytes[i++] = (byte)((SequenceID >> 24) % 256);
                bytes[i++] = (byte)((RegionDenyTransacted) ? 1 : 0);
                bytes[i++] = (byte)(SelfCount % 256);
                bytes[i++] = (byte)((SelfCount >> 8) % 256);
                bytes[i++] = (byte)((SelfCount >> 16) % 256);
                bytes[i++] = (byte)((SelfCount >> 24) % 256);
                bytes[i++] = (byte)(Bitmap.Length % 256);
                bytes[i++] = (byte)((Bitmap.Length >> 8) % 256);
                Array.Copy(Bitmap, 0, bytes, i, Bitmap.Length); i += Bitmap.Length;
                bytes[i++] = Status;
                Array.Copy(SnapshotID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((SnapSelection) ? 1 : 0);
                bytes[i++] = LandingType;
                bytes[i++] = (byte)(SimWideTotalPrims % 256);
                bytes[i++] = (byte)((SimWideTotalPrims >> 8) % 256);
                bytes[i++] = (byte)((SimWideTotalPrims >> 16) % 256);
                bytes[i++] = (byte)((SimWideTotalPrims >> 24) % 256);
                bytes[i++] = (byte)(AuctionID % 256);
                bytes[i++] = (byte)((AuctionID >> 8) % 256);
                bytes[i++] = (byte)((AuctionID >> 16) % 256);
                bytes[i++] = (byte)((AuctionID >> 24) % 256);
                Array.Copy(AuthBuyerID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(PassHours);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(ParcelFlags % 256);
                bytes[i++] = (byte)((ParcelFlags >> 8) % 256);
                bytes[i++] = (byte)((ParcelFlags >> 16) % 256);
                bytes[i++] = (byte)((ParcelFlags >> 24) % 256);
                bytes[i++] = (byte)(PassPrice % 256);
                bytes[i++] = (byte)((PassPrice >> 8) % 256);
                bytes[i++] = (byte)((PassPrice >> 16) % 256);
                bytes[i++] = (byte)((PassPrice >> 24) % 256);
                bytes[i++] = (byte)(ClaimDate % 256);
                bytes[i++] = (byte)((ClaimDate >> 8) % 256);
                bytes[i++] = (byte)((ClaimDate >> 16) % 256);
                bytes[i++] = (byte)((ClaimDate >> 24) % 256);
                bytes[i++] = MediaAutoScale;
                bytes[i++] = (byte)MusicURL.Length;
                Array.Copy(MusicURL, 0, bytes, i, MusicURL.Length); i += MusicURL.Length;
                ba = BitConverter.GetBytes(ParcelPrimBonus);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(ClaimPrice % 256);
                bytes[i++] = (byte)((ClaimPrice >> 8) % 256);
                bytes[i++] = (byte)((ClaimPrice >> 16) % 256);
                bytes[i++] = (byte)((ClaimPrice >> 24) % 256);
                bytes[i++] = (byte)(RentPrice % 256);
                bytes[i++] = (byte)((RentPrice >> 8) % 256);
                bytes[i++] = (byte)((RentPrice >> 16) % 256);
                bytes[i++] = (byte)((RentPrice >> 24) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ParcelProperties</summary>
        public override PacketType Type { get { return PacketType.ParcelProperties; } }
        /// <summary>ParcelData block</summary>
        public ParcelDataBlock ParcelData;

        /// <summary>Default constructor</summary>
        public ParcelPropertiesPacket()
        {
            Header = new HighHeader();
            Header.ID = 25;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ParcelData = new ParcelDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ParcelPropertiesPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            ParcelData = new ParcelDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ParcelPropertiesPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ParcelData = new ParcelDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += ParcelData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ParcelData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>EdgeDataPacket packet</summary>
    public class EdgeDataPacketPacket : Packet
    {
        /// <summary>EdgeData block</summary>
        public class EdgeDataBlock
        {
            /// <summary>LayerType field</summary>
            public byte LayerType;
            /// <summary>Direction field</summary>
            public byte Direction;
            private byte[] _layerdata;
            /// <summary>LayerData field</summary>
            public byte[] LayerData
            {
                get { return _layerdata; }
                set
                {
                    if (value == null) { _layerdata = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _layerdata = new byte[value.Length]; Array.Copy(value, _layerdata, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    if (LayerData != null) { length += 2 + LayerData.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public EdgeDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public EdgeDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    LayerType = (byte)bytes[i++];
                    Direction = (byte)bytes[i++];
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _layerdata = new byte[length];
                    Array.Copy(bytes, i, _layerdata, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = LayerType;
                bytes[i++] = Direction;
                bytes[i++] = (byte)(LayerData.Length % 256);
                bytes[i++] = (byte)((LayerData.Length >> 8) % 256);
                Array.Copy(LayerData, 0, bytes, i, LayerData.Length); i += LayerData.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.EdgeDataPacket</summary>
        public override PacketType Type { get { return PacketType.EdgeDataPacket; } }
        /// <summary>EdgeData block</summary>
        public EdgeDataBlock EdgeData;

        /// <summary>Default constructor</summary>
        public EdgeDataPacketPacket()
        {
            Header = new HighHeader();
            Header.ID = 26;
            Header.Reliable = true;
            Header.Zerocoded = true;
            EdgeData = new EdgeDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public EdgeDataPacketPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            EdgeData = new EdgeDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public EdgeDataPacketPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            EdgeData = new EdgeDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += EdgeData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            EdgeData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChildAgentUpdate packet</summary>
    public class ChildAgentUpdatePacket : Packet
    {
        /// <summary>VisualParam block</summary>
        public class VisualParamBlock
        {
            /// <summary>ParamValue field</summary>
            public byte ParamValue;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 2;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public VisualParamBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public VisualParamBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ParamValue = (byte)bytes[i++];
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = ParamValue;
            }
        }

        /// <summary>GranterBlock block</summary>
        public class GranterBlockBlock
        {
            /// <summary>GranterID field</summary>
            public LLUUID GranterID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GranterBlockBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GranterBlockBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GranterID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(GranterID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AnimationData block</summary>
        public class AnimationDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Animation field</summary>
            public LLUUID Animation;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 33;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AnimationDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AnimationDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    Animation = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(Animation.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>ViewerCircuitCode field</summary>
            public uint ViewerCircuitCode;
            /// <summary>ControlFlags field</summary>
            public uint ControlFlags;
            /// <summary>Far field</summary>
            public float Far;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ChangedGrid field</summary>
            public bool ChangedGrid;
            /// <summary>HeadRotation field</summary>
            public LLQuaternion HeadRotation;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>LeftAxis field</summary>
            public LLVector3 LeftAxis;
            /// <summary>Size field</summary>
            public LLVector3 Size;
            /// <summary>GodLevel field</summary>
            public byte GodLevel;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>AgentAccess field</summary>
            public byte AgentAccess;
            /// <summary>AgentVel field</summary>
            public LLVector3 AgentVel;
            /// <summary>AgentPos field</summary>
            public LLVector3 AgentPos;
            /// <summary>PreyAgent field</summary>
            public LLUUID PreyAgent;
            private byte[] _throttles;
            /// <summary>Throttles field</summary>
            public byte[] Throttles
            {
                get { return _throttles; }
                set
                {
                    if (value == null) { _throttles = null; return; }
                    if (value.Length > 255) { throw new OverflowException("Value exceeds 255 characters"); }
                    else { _throttles = new byte[value.Length]; Array.Copy(value, _throttles, value.Length); }
                }
            }
            /// <summary>UpAxis field</summary>
            public LLVector3 UpAxis;
            private byte[] _agenttextures;
            /// <summary>AgentTextures field</summary>
            public byte[] AgentTextures
            {
                get { return _agenttextures; }
                set
                {
                    if (value == null) { _agenttextures = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _agenttextures = new byte[value.Length]; Array.Copy(value, _agenttextures, value.Length); }
                }
            }
            /// <summary>AtAxis field</summary>
            public LLVector3 AtAxis;
            /// <summary>Center field</summary>
            public LLVector3 Center;
            /// <summary>BodyRotation field</summary>
            public LLQuaternion BodyRotation;
            /// <summary>Aspect field</summary>
            public float Aspect;
            /// <summary>AlwaysRun field</summary>
            public bool AlwaysRun;
            /// <summary>EnergyLevel field</summary>
            public float EnergyLevel;
            /// <summary>LocomotionState field</summary>
            public uint LocomotionState;
            /// <summary>ActiveGroupID field</summary>
            public LLUUID ActiveGroupID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 216;
                    if (Throttles != null) { length += 1 + Throttles.Length; }
                    if (AgentTextures != null) { length += 2 + AgentTextures.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ViewerCircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ControlFlags = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Far = BitConverter.ToSingle(bytes, i); i += 4;
                    AgentID = new LLUUID(bytes, i); i += 16;
                    ChangedGrid = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    HeadRotation = new LLQuaternion(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    LeftAxis = new LLVector3(bytes, i); i += 12;
                    Size = new LLVector3(bytes, i); i += 12;
                    GodLevel = (byte)bytes[i++];
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    AgentAccess = (byte)bytes[i++];
                    AgentVel = new LLVector3(bytes, i); i += 12;
                    AgentPos = new LLVector3(bytes, i); i += 12;
                    PreyAgent = new LLUUID(bytes, i); i += 16;
                    length = (ushort)bytes[i++];
                    _throttles = new byte[length];
                    Array.Copy(bytes, i, _throttles, 0, length); i += length;
                    UpAxis = new LLVector3(bytes, i); i += 12;
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _agenttextures = new byte[length];
                    Array.Copy(bytes, i, _agenttextures, 0, length); i += length;
                    AtAxis = new LLVector3(bytes, i); i += 12;
                    Center = new LLVector3(bytes, i); i += 12;
                    BodyRotation = new LLQuaternion(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Aspect = BitConverter.ToSingle(bytes, i); i += 4;
                    AlwaysRun = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    EnergyLevel = BitConverter.ToSingle(bytes, i); i += 4;
                    LocomotionState = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ActiveGroupID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                bytes[i++] = (byte)(ViewerCircuitCode % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 8) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 16) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 24) % 256);
                bytes[i++] = (byte)(ControlFlags % 256);
                bytes[i++] = (byte)((ControlFlags >> 8) % 256);
                bytes[i++] = (byte)((ControlFlags >> 16) % 256);
                bytes[i++] = (byte)((ControlFlags >> 24) % 256);
                ba = BitConverter.GetBytes(Far);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((ChangedGrid) ? 1 : 0);
                Array.Copy(HeadRotation.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(LeftAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Size.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = GodLevel;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                bytes[i++] = AgentAccess;
                Array.Copy(AgentVel.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(AgentPos.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(PreyAgent.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)Throttles.Length;
                Array.Copy(Throttles, 0, bytes, i, Throttles.Length); i += Throttles.Length;
                Array.Copy(UpAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(AgentTextures.Length % 256);
                bytes[i++] = (byte)((AgentTextures.Length >> 8) % 256);
                Array.Copy(AgentTextures, 0, bytes, i, AgentTextures.Length); i += AgentTextures.Length;
                Array.Copy(AtAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Center.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(BodyRotation.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Aspect);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)((AlwaysRun) ? 1 : 0);
                ba = BitConverter.GetBytes(EnergyLevel);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                bytes[i++] = (byte)(LocomotionState % 256);
                bytes[i++] = (byte)((LocomotionState >> 8) % 256);
                bytes[i++] = (byte)((LocomotionState >> 16) % 256);
                bytes[i++] = (byte)((LocomotionState >> 24) % 256);
                Array.Copy(ActiveGroupID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        /// <summary>GroupData block</summary>
        public class GroupDataBlock
        {
            /// <summary>GroupPowers field</summary>
            public ulong GroupPowers;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>AcceptNotices field</summary>
            public bool AcceptNotices;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 26;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public GroupDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public GroupDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    GroupPowers = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    GroupID = new LLUUID(bytes, i); i += 16;
                    AcceptNotices = (bytes[i++] != 0) ? (bool)true : (bool)false;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(GroupPowers % 256);
                bytes[i++] = (byte)((GroupPowers >> 8) % 256);
                bytes[i++] = (byte)((GroupPowers >> 16) % 256);
                bytes[i++] = (byte)((GroupPowers >> 24) % 256);
                bytes[i++] = (byte)((GroupPowers >> 32) % 256);
                bytes[i++] = (byte)((GroupPowers >> 40) % 256);
                bytes[i++] = (byte)((GroupPowers >> 48) % 256);
                bytes[i++] = (byte)((GroupPowers >> 56) % 256);
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((AcceptNotices) ? 1 : 0);
            }
        }

        /// <summary>NVPairData block</summary>
        public class NVPairDataBlock
        {
            private byte[] _nvpairs;
            /// <summary>NVPairs field</summary>
            public byte[] NVPairs
            {
                get { return _nvpairs; }
                set
                {
                    if (value == null) { _nvpairs = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _nvpairs = new byte[value.Length]; Array.Copy(value, _nvpairs, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (NVPairs != null) { length += 2 + NVPairs.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NVPairDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NVPairDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _nvpairs = new byte[length];
                    Array.Copy(bytes, i, _nvpairs, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(NVPairs.Length % 256);
                bytes[i++] = (byte)((NVPairs.Length >> 8) % 256);
                Array.Copy(NVPairs, 0, bytes, i, NVPairs.Length); i += NVPairs.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChildAgentUpdate</summary>
        public override PacketType Type { get { return PacketType.ChildAgentUpdate; } }
        /// <summary>VisualParam block</summary>
        public VisualParamBlock[] VisualParam;
        /// <summary>GranterBlock block</summary>
        public GranterBlockBlock[] GranterBlock;
        /// <summary>AnimationData block</summary>
        public AnimationDataBlock[] AnimationData;
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;
        /// <summary>GroupData block</summary>
        public GroupDataBlock[] GroupData;
        /// <summary>NVPairData block</summary>
        public NVPairDataBlock[] NVPairData;

        /// <summary>Default constructor</summary>
        public ChildAgentUpdatePacket()
        {
            Header = new HighHeader();
            Header.ID = 27;
            Header.Reliable = true;
            Header.Zerocoded = true;
            VisualParam = new VisualParamBlock[0];
            GranterBlock = new GranterBlockBlock[0];
            AnimationData = new AnimationDataBlock[0];
            AgentData = new AgentDataBlock();
            GroupData = new GroupDataBlock[0];
            NVPairData = new NVPairDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChildAgentUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            int count = (int)bytes[i++];
            VisualParam = new VisualParamBlock[count];
            for (int j = 0; j < count; j++)
            { VisualParam[j] = new VisualParamBlock(bytes, ref i); }
            count = (int)bytes[i++];
            GranterBlock = new GranterBlockBlock[count];
            for (int j = 0; j < count; j++)
            { GranterBlock[j] = new GranterBlockBlock(bytes, ref i); }
            count = (int)bytes[i++];
            AnimationData = new AnimationDataBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationData[j] = new AnimationDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
            count = (int)bytes[i++];
            NVPairData = new NVPairDataBlock[count];
            for (int j = 0; j < count; j++)
            { NVPairData[j] = new NVPairDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChildAgentUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            int count = (int)bytes[i++];
            VisualParam = new VisualParamBlock[count];
            for (int j = 0; j < count; j++)
            { VisualParam[j] = new VisualParamBlock(bytes, ref i); }
            count = (int)bytes[i++];
            GranterBlock = new GranterBlockBlock[count];
            for (int j = 0; j < count; j++)
            { GranterBlock[j] = new GranterBlockBlock(bytes, ref i); }
            count = (int)bytes[i++];
            AnimationData = new AnimationDataBlock[count];
            for (int j = 0; j < count; j++)
            { AnimationData[j] = new AnimationDataBlock(bytes, ref i); }
            AgentData = new AgentDataBlock(bytes, ref i);
            count = (int)bytes[i++];
            GroupData = new GroupDataBlock[count];
            for (int j = 0; j < count; j++)
            { GroupData[j] = new GroupDataBlock(bytes, ref i); }
            count = (int)bytes[i++];
            NVPairData = new NVPairDataBlock[count];
            for (int j = 0; j < count; j++)
            { NVPairData[j] = new NVPairDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += AgentData.Length;;
            for (int j = 0; j < VisualParam.Length; j++) { length += VisualParam[j].Length; }
            for (int j = 0; j < GranterBlock.Length; j++) { length += GranterBlock[j].Length; }
            for (int j = 0; j < AnimationData.Length; j++) { length += AnimationData[j].Length; }
            for (int j = 0; j < GroupData.Length; j++) { length += GroupData[j].Length; }
            for (int j = 0; j < NVPairData.Length; j++) { length += NVPairData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            bytes[i++] = (byte)VisualParam.Length;
            for (int j = 0; j < VisualParam.Length; j++) { VisualParam[j].ToBytes(bytes, ref i); }
            bytes[i++] = (byte)GranterBlock.Length;
            for (int j = 0; j < GranterBlock.Length; j++) { GranterBlock[j].ToBytes(bytes, ref i); }
            bytes[i++] = (byte)AnimationData.Length;
            for (int j = 0; j < AnimationData.Length; j++) { AnimationData[j].ToBytes(bytes, ref i); }
            AgentData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)GroupData.Length;
            for (int j = 0; j < GroupData.Length; j++) { GroupData[j].ToBytes(bytes, ref i); }
            bytes[i++] = (byte)NVPairData.Length;
            for (int j = 0; j < NVPairData.Length; j++) { NVPairData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChildAgentAlive packet</summary>
    public class ChildAgentAlivePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>ViewerCircuitCode field</summary>
            public uint ViewerCircuitCode;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 44;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ViewerCircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ViewerCircuitCode % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 8) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 16) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChildAgentAlive</summary>
        public override PacketType Type { get { return PacketType.ChildAgentAlive; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ChildAgentAlivePacket()
        {
            Header = new HighHeader();
            Header.ID = 28;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChildAgentAlivePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChildAgentAlivePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>ChildAgentPositionUpdate packet</summary>
    public class ChildAgentPositionUpdatePacket : Packet
    {
        /// <summary>AgentData block</summary>
        public class AgentDataBlock
        {
            /// <summary>ViewerCircuitCode field</summary>
            public uint ViewerCircuitCode;
            /// <summary>AgentID field</summary>
            public LLUUID AgentID;
            /// <summary>ChangedGrid field</summary>
            public bool ChangedGrid;
            /// <summary>SessionID field</summary>
            public LLUUID SessionID;
            /// <summary>LeftAxis field</summary>
            public LLVector3 LeftAxis;
            /// <summary>Size field</summary>
            public LLVector3 Size;
            /// <summary>RegionHandle field</summary>
            public ulong RegionHandle;
            /// <summary>AgentVel field</summary>
            public LLVector3 AgentVel;
            /// <summary>AgentPos field</summary>
            public LLVector3 AgentPos;
            /// <summary>UpAxis field</summary>
            public LLVector3 UpAxis;
            /// <summary>AtAxis field</summary>
            public LLVector3 AtAxis;
            /// <summary>Center field</summary>
            public LLVector3 Center;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 129;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public AgentDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public AgentDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ViewerCircuitCode = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    AgentID = new LLUUID(bytes, i); i += 16;
                    ChangedGrid = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    SessionID = new LLUUID(bytes, i); i += 16;
                    LeftAxis = new LLVector3(bytes, i); i += 12;
                    Size = new LLVector3(bytes, i); i += 12;
                    RegionHandle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    AgentVel = new LLVector3(bytes, i); i += 12;
                    AgentPos = new LLVector3(bytes, i); i += 12;
                    UpAxis = new LLVector3(bytes, i); i += 12;
                    AtAxis = new LLVector3(bytes, i); i += 12;
                    Center = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(ViewerCircuitCode % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 8) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 16) % 256);
                bytes[i++] = (byte)((ViewerCircuitCode >> 24) % 256);
                Array.Copy(AgentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((ChangedGrid) ? 1 : 0);
                Array.Copy(SessionID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(LeftAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Size.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = (byte)(RegionHandle % 256);
                bytes[i++] = (byte)((RegionHandle >> 8) % 256);
                bytes[i++] = (byte)((RegionHandle >> 16) % 256);
                bytes[i++] = (byte)((RegionHandle >> 24) % 256);
                bytes[i++] = (byte)((RegionHandle >> 32) % 256);
                bytes[i++] = (byte)((RegionHandle >> 40) % 256);
                bytes[i++] = (byte)((RegionHandle >> 48) % 256);
                bytes[i++] = (byte)((RegionHandle >> 56) % 256);
                Array.Copy(AgentVel.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(AgentPos.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(UpAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(AtAxis.GetBytes(), 0, bytes, i, 12); i += 12;
                Array.Copy(Center.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.ChildAgentPositionUpdate</summary>
        public override PacketType Type { get { return PacketType.ChildAgentPositionUpdate; } }
        /// <summary>AgentData block</summary>
        public AgentDataBlock AgentData;

        /// <summary>Default constructor</summary>
        public ChildAgentPositionUpdatePacket()
        {
            Header = new HighHeader();
            Header.ID = 29;
            Header.Reliable = true;
            AgentData = new AgentDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public ChildAgentPositionUpdatePacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public ChildAgentPositionUpdatePacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            AgentData = new AgentDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += AgentData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            AgentData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>PassObject packet</summary>
    public class PassObjectPacket : Packet
    {
        /// <summary>ObjectData block</summary>
        public class ObjectDataBlock
        {
            /// <summary>ID field</summary>
            public LLUUID ID;
            /// <summary>GroupOwned field</summary>
            public bool GroupOwned;
            /// <summary>PathTwistBegin field</summary>
            public sbyte PathTwistBegin;
            /// <summary>PathEnd field</summary>
            public byte PathEnd;
            /// <summary>AngVelX field</summary>
            public short AngVelX;
            /// <summary>AngVelY field</summary>
            public short AngVelY;
            /// <summary>AngVelZ field</summary>
            public short AngVelZ;
            /// <summary>BaseMask field</summary>
            public uint BaseMask;
            /// <summary>ProfileBegin field</summary>
            public byte ProfileBegin;
            /// <summary>SubType field</summary>
            public short SubType;
            /// <summary>PathRadiusOffset field</summary>
            public sbyte PathRadiusOffset;
            /// <summary>VelX field</summary>
            public short VelX;
            /// <summary>PathSkew field</summary>
            public sbyte PathSkew;
            /// <summary>VelY field</summary>
            public short VelY;
            /// <summary>VelZ field</summary>
            public short VelZ;
            private byte[] _data;
            /// <summary>Data field</summary>
            public byte[] Data
            {
                get { return _data; }
                set
                {
                    if (value == null) { _data = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _data = new byte[value.Length]; Array.Copy(value, _data, value.Length); }
                }
            }
            /// <summary>ParentID field</summary>
            public LLUUID ParentID;
            /// <summary>PosX field</summary>
            public short PosX;
            /// <summary>PosY field</summary>
            public short PosY;
            /// <summary>PosZ field</summary>
            public short PosZ;
            /// <summary>ProfileCurve field</summary>
            public byte ProfileCurve;
            /// <summary>PathScaleX field</summary>
            public byte PathScaleX;
            /// <summary>PathScaleY field</summary>
            public byte PathScaleY;
            /// <summary>GroupID field</summary>
            public LLUUID GroupID;
            /// <summary>Material field</summary>
            public byte Material;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>CreatorID field</summary>
            public LLUUID CreatorID;
            /// <summary>PathShearX field</summary>
            public byte PathShearX;
            /// <summary>PathShearY field</summary>
            public byte PathShearY;
            /// <summary>PathTaperX field</summary>
            public sbyte PathTaperX;
            /// <summary>PathTaperY field</summary>
            public sbyte PathTaperY;
            /// <summary>ProfileEnd field</summary>
            public byte ProfileEnd;
            /// <summary>UsePhysics field</summary>
            public byte UsePhysics;
            /// <summary>PathBegin field</summary>
            public byte PathBegin;
            /// <summary>Active field</summary>
            public byte Active;
            /// <summary>PCode field</summary>
            public byte PCode;
            /// <summary>PathCurve field</summary>
            public byte PathCurve;
            /// <summary>EveryoneMask field</summary>
            public uint EveryoneMask;
            /// <summary>Scale field</summary>
            public LLVector3 Scale;
            /// <summary>State field</summary>
            public byte State;
            /// <summary>PathTwist field</summary>
            public sbyte PathTwist;
            private byte[] _textureentry;
            /// <summary>TextureEntry field</summary>
            public byte[] TextureEntry
            {
                get { return _textureentry; }
                set
                {
                    if (value == null) { _textureentry = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _textureentry = new byte[value.Length]; Array.Copy(value, _textureentry, value.Length); }
                }
            }
            /// <summary>ProfileHollow field</summary>
            public byte ProfileHollow;
            /// <summary>PathRevolutions field</summary>
            public byte PathRevolutions;
            /// <summary>Rotation field</summary>
            public LLQuaternion Rotation;
            /// <summary>NextOwnerMask field</summary>
            public uint NextOwnerMask;
            /// <summary>GroupMask field</summary>
            public uint GroupMask;
            /// <summary>OwnerMask field</summary>
            public uint OwnerMask;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 172;
                    if (Data != null) { length += 2 + Data.Length; }
                    if (TextureEntry != null) { length += 2 + TextureEntry.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public ObjectDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public ObjectDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    ID = new LLUUID(bytes, i); i += 16;
                    GroupOwned = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    PathTwistBegin = (sbyte)bytes[i++];
                    PathEnd = (byte)bytes[i++];
                    AngVelX = (short)(bytes[i++] + (bytes[i++] << 8));
                    AngVelY = (short)(bytes[i++] + (bytes[i++] << 8));
                    AngVelZ = (short)(bytes[i++] + (bytes[i++] << 8));
                    BaseMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    ProfileBegin = (byte)bytes[i++];
                    SubType = (short)(bytes[i++] + (bytes[i++] << 8));
                    PathRadiusOffset = (sbyte)bytes[i++];
                    VelX = (short)(bytes[i++] + (bytes[i++] << 8));
                    PathSkew = (sbyte)bytes[i++];
                    VelY = (short)(bytes[i++] + (bytes[i++] << 8));
                    VelZ = (short)(bytes[i++] + (bytes[i++] << 8));
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _data = new byte[length];
                    Array.Copy(bytes, i, _data, 0, length); i += length;
                    ParentID = new LLUUID(bytes, i); i += 16;
                    PosX = (short)(bytes[i++] + (bytes[i++] << 8));
                    PosY = (short)(bytes[i++] + (bytes[i++] << 8));
                    PosZ = (short)(bytes[i++] + (bytes[i++] << 8));
                    ProfileCurve = (byte)bytes[i++];
                    PathScaleX = (byte)bytes[i++];
                    PathScaleY = (byte)bytes[i++];
                    GroupID = new LLUUID(bytes, i); i += 16;
                    Material = (byte)bytes[i++];
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    CreatorID = new LLUUID(bytes, i); i += 16;
                    PathShearX = (byte)bytes[i++];
                    PathShearY = (byte)bytes[i++];
                    PathTaperX = (sbyte)bytes[i++];
                    PathTaperY = (sbyte)bytes[i++];
                    ProfileEnd = (byte)bytes[i++];
                    UsePhysics = (byte)bytes[i++];
                    PathBegin = (byte)bytes[i++];
                    Active = (byte)bytes[i++];
                    PCode = (byte)bytes[i++];
                    PathCurve = (byte)bytes[i++];
                    EveryoneMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    Scale = new LLVector3(bytes, i); i += 12;
                    State = (byte)bytes[i++];
                    PathTwist = (sbyte)bytes[i++];
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _textureentry = new byte[length];
                    Array.Copy(bytes, i, _textureentry, 0, length); i += length;
                    ProfileHollow = (byte)bytes[i++];
                    PathRevolutions = (byte)bytes[i++];
                    Rotation = new LLQuaternion(bytes, i); i += 16;
                    NextOwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    GroupMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                    OwnerMask = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                Array.Copy(ID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)((GroupOwned) ? 1 : 0);
                bytes[i++] = (byte)PathTwistBegin;
                bytes[i++] = PathEnd;
                bytes[i++] = (byte)(AngVelX % 256);
                bytes[i++] = (byte)((AngVelX >> 8) % 256);
                bytes[i++] = (byte)(AngVelY % 256);
                bytes[i++] = (byte)((AngVelY >> 8) % 256);
                bytes[i++] = (byte)(AngVelZ % 256);
                bytes[i++] = (byte)((AngVelZ >> 8) % 256);
                bytes[i++] = (byte)(BaseMask % 256);
                bytes[i++] = (byte)((BaseMask >> 8) % 256);
                bytes[i++] = (byte)((BaseMask >> 16) % 256);
                bytes[i++] = (byte)((BaseMask >> 24) % 256);
                bytes[i++] = ProfileBegin;
                bytes[i++] = (byte)(SubType % 256);
                bytes[i++] = (byte)((SubType >> 8) % 256);
                bytes[i++] = (byte)PathRadiusOffset;
                bytes[i++] = (byte)(VelX % 256);
                bytes[i++] = (byte)((VelX >> 8) % 256);
                bytes[i++] = (byte)PathSkew;
                bytes[i++] = (byte)(VelY % 256);
                bytes[i++] = (byte)((VelY >> 8) % 256);
                bytes[i++] = (byte)(VelZ % 256);
                bytes[i++] = (byte)((VelZ >> 8) % 256);
                bytes[i++] = (byte)(Data.Length % 256);
                bytes[i++] = (byte)((Data.Length >> 8) % 256);
                Array.Copy(Data, 0, bytes, i, Data.Length); i += Data.Length;
                Array.Copy(ParentID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(PosX % 256);
                bytes[i++] = (byte)((PosX >> 8) % 256);
                bytes[i++] = (byte)(PosY % 256);
                bytes[i++] = (byte)((PosY >> 8) % 256);
                bytes[i++] = (byte)(PosZ % 256);
                bytes[i++] = (byte)((PosZ >> 8) % 256);
                bytes[i++] = ProfileCurve;
                bytes[i++] = PathScaleX;
                bytes[i++] = PathScaleY;
                Array.Copy(GroupID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = Material;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(CreatorID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = PathShearX;
                bytes[i++] = PathShearY;
                bytes[i++] = (byte)PathTaperX;
                bytes[i++] = (byte)PathTaperY;
                bytes[i++] = ProfileEnd;
                bytes[i++] = UsePhysics;
                bytes[i++] = PathBegin;
                bytes[i++] = Active;
                bytes[i++] = PCode;
                bytes[i++] = PathCurve;
                bytes[i++] = (byte)(EveryoneMask % 256);
                bytes[i++] = (byte)((EveryoneMask >> 8) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 16) % 256);
                bytes[i++] = (byte)((EveryoneMask >> 24) % 256);
                Array.Copy(Scale.GetBytes(), 0, bytes, i, 12); i += 12;
                bytes[i++] = State;
                bytes[i++] = (byte)PathTwist;
                bytes[i++] = (byte)(TextureEntry.Length % 256);
                bytes[i++] = (byte)((TextureEntry.Length >> 8) % 256);
                Array.Copy(TextureEntry, 0, bytes, i, TextureEntry.Length); i += TextureEntry.Length;
                bytes[i++] = ProfileHollow;
                bytes[i++] = PathRevolutions;
                Array.Copy(Rotation.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(NextOwnerMask % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 8) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 16) % 256);
                bytes[i++] = (byte)((NextOwnerMask >> 24) % 256);
                bytes[i++] = (byte)(GroupMask % 256);
                bytes[i++] = (byte)((GroupMask >> 8) % 256);
                bytes[i++] = (byte)((GroupMask >> 16) % 256);
                bytes[i++] = (byte)((GroupMask >> 24) % 256);
                bytes[i++] = (byte)(OwnerMask % 256);
                bytes[i++] = (byte)((OwnerMask >> 8) % 256);
                bytes[i++] = (byte)((OwnerMask >> 16) % 256);
                bytes[i++] = (byte)((OwnerMask >> 24) % 256);
            }
        }

        /// <summary>NVPairData block</summary>
        public class NVPairDataBlock
        {
            private byte[] _nvpairs;
            /// <summary>NVPairs field</summary>
            public byte[] NVPairs
            {
                get { return _nvpairs; }
                set
                {
                    if (value == null) { _nvpairs = null; return; }
                    if (value.Length > 1024) { throw new OverflowException("Value exceeds 1024 characters"); }
                    else { _nvpairs = new byte[value.Length]; Array.Copy(value, _nvpairs, value.Length); }
                }
            }

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 1;
                    if (NVPairs != null) { length += 2 + NVPairs.Length; }
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public NVPairDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public NVPairDataBlock(byte[] bytes, ref int i)
            {
                int length;
                try
                {
                    length = (ushort)(bytes[i++] + (bytes[i++] << 8));
                    _nvpairs = new byte[length];
                    Array.Copy(bytes, i, _nvpairs, 0, length); i += length;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)(NVPairs.Length % 256);
                bytes[i++] = (byte)((NVPairs.Length >> 8) % 256);
                Array.Copy(NVPairs, 0, bytes, i, NVPairs.Length); i += NVPairs.Length;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.PassObject</summary>
        public override PacketType Type { get { return PacketType.PassObject; } }
        /// <summary>ObjectData block</summary>
        public ObjectDataBlock ObjectData;
        /// <summary>NVPairData block</summary>
        public NVPairDataBlock[] NVPairData;

        /// <summary>Default constructor</summary>
        public PassObjectPacket()
        {
            Header = new HighHeader();
            Header.ID = 30;
            Header.Reliable = true;
            Header.Zerocoded = true;
            ObjectData = new ObjectDataBlock();
            NVPairData = new NVPairDataBlock[0];
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public PassObjectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            ObjectData = new ObjectDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            NVPairData = new NVPairDataBlock[count];
            for (int j = 0; j < count; j++)
            { NVPairData[j] = new NVPairDataBlock(bytes, ref i); }
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public PassObjectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            ObjectData = new ObjectDataBlock(bytes, ref i);
            int count = (int)bytes[i++];
            NVPairData = new NVPairDataBlock[count];
            for (int j = 0; j < count; j++)
            { NVPairData[j] = new NVPairDataBlock(bytes, ref i); }
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += ObjectData.Length;;
            for (int j = 0; j < NVPairData.Length; j++) { length += NVPairData[j].Length; }
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            ObjectData.ToBytes(bytes, ref i);
            bytes[i++] = (byte)NVPairData.Length;
            for (int j = 0; j < NVPairData.Length; j++) { NVPairData[j].ToBytes(bytes, ref i); }
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>AtomicPassObject packet</summary>
    public class AtomicPassObjectPacket : Packet
    {
        /// <summary>TaskData block</summary>
        public class TaskDataBlock
        {
            /// <summary>AttachmentNeedsSave field</summary>
            public bool AttachmentNeedsSave;
            /// <summary>TaskID field</summary>
            public LLUUID TaskID;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 17;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public TaskDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public TaskDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    AttachmentNeedsSave = (bytes[i++] != 0) ? (bool)true : (bool)false;
                    TaskID = new LLUUID(bytes, i); i += 16;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                bytes[i++] = (byte)((AttachmentNeedsSave) ? 1 : 0);
                Array.Copy(TaskID.GetBytes(), 0, bytes, i, 16); i += 16;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.AtomicPassObject</summary>
        public override PacketType Type { get { return PacketType.AtomicPassObject; } }
        /// <summary>TaskData block</summary>
        public TaskDataBlock TaskData;

        /// <summary>Default constructor</summary>
        public AtomicPassObjectPacket()
        {
            Header = new HighHeader();
            Header.ID = 31;
            Header.Reliable = true;
            TaskData = new TaskDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public AtomicPassObjectPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public AtomicPassObjectPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            TaskData = new TaskDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += TaskData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            TaskData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

    /// <summary>SoundTrigger packet</summary>
    public class SoundTriggerPacket : Packet
    {
        /// <summary>SoundData block</summary>
        public class SoundDataBlock
        {
            /// <summary>ObjectID field</summary>
            public LLUUID ObjectID;
            /// <summary>Gain field</summary>
            public float Gain;
            /// <summary>ParentID field</summary>
            public LLUUID ParentID;
            /// <summary>SoundID field</summary>
            public LLUUID SoundID;
            /// <summary>OwnerID field</summary>
            public LLUUID OwnerID;
            /// <summary>Handle field</summary>
            public ulong Handle;
            /// <summary>Position field</summary>
            public LLVector3 Position;

            /// <summary>Length of this block serialized in bytes</summary>
            public int Length
            {
                get
                {
                    int length = 88;
                    return length;
                }
            }

            /// <summary>Default constructor</summary>
            public SoundDataBlock() { }
            /// <summary>Constructor for building the block from a byte array</summary>
            public SoundDataBlock(byte[] bytes, ref int i)
            {
                try
                {
                    ObjectID = new LLUUID(bytes, i); i += 16;
                    if (!BitConverter.IsLittleEndian) Array.Reverse(bytes, i, 4);
                    Gain = BitConverter.ToSingle(bytes, i); i += 4;
                    ParentID = new LLUUID(bytes, i); i += 16;
                    SoundID = new LLUUID(bytes, i); i += 16;
                    OwnerID = new LLUUID(bytes, i); i += 16;
                    Handle = (ulong)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24) + (bytes[i++] << 32) + (bytes[i++] << 40) + (bytes[i++] << 48) + (bytes[i++] << 56));
                    Position = new LLVector3(bytes, i); i += 12;
                }
                catch (Exception)
                {
                    throw new MalformedDataException();
                }
            }

            /// <summary>Serialize this block to a byte array</summary>
            public void ToBytes(byte[] bytes, ref int i)
            {
                byte[] ba;
                Array.Copy(ObjectID.GetBytes(), 0, bytes, i, 16); i += 16;
                ba = BitConverter.GetBytes(Gain);
                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba, 0, 4); }
                Array.Copy(ba, 0, bytes, i, 4); i += 4;
                Array.Copy(ParentID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(SoundID.GetBytes(), 0, bytes, i, 16); i += 16;
                Array.Copy(OwnerID.GetBytes(), 0, bytes, i, 16); i += 16;
                bytes[i++] = (byte)(Handle % 256);
                bytes[i++] = (byte)((Handle >> 8) % 256);
                bytes[i++] = (byte)((Handle >> 16) % 256);
                bytes[i++] = (byte)((Handle >> 24) % 256);
                bytes[i++] = (byte)((Handle >> 32) % 256);
                bytes[i++] = (byte)((Handle >> 40) % 256);
                bytes[i++] = (byte)((Handle >> 48) % 256);
                bytes[i++] = (byte)((Handle >> 56) % 256);
                Array.Copy(Position.GetBytes(), 0, bytes, i, 12); i += 12;
            }
        }

        private Header header;
        /// <summary>The header for this packet</summary>
        public override Header Header { get { return header; } set { header = value; } }
        /// <summary>Will return PacketType.SoundTrigger</summary>
        public override PacketType Type { get { return PacketType.SoundTrigger; } }
        /// <summary>SoundData block</summary>
        public SoundDataBlock SoundData;

        /// <summary>Default constructor</summary>
        public SoundTriggerPacket()
        {
            Header = new HighHeader();
            Header.ID = 32;
            Header.Reliable = true;
            SoundData = new SoundDataBlock();
        }

        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>
        public SoundTriggerPacket(byte[] bytes, ref int i)
        {
            int packetEnd = bytes.Length - 1;
            Header = new HighHeader(bytes, ref i, ref packetEnd);
            SoundData = new SoundDataBlock(bytes, ref i);
        }

        /// <summary>Constructor that takes a byte array and a prebuilt header</summary>
        public SoundTriggerPacket(Header head, byte[] bytes, ref int i)
        {
            Header = head;
            SoundData = new SoundDataBlock(bytes, ref i);
        }

        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>
        public override byte[] ToBytes()
        {
            int length = 5;
            length += SoundData.Length;;
            if (header.AckList.Length > 0) { length += header.AckList.Length * 4 + 1; }
            byte[] bytes = new byte[length];
            int i = 0;
            header.ToBytes(bytes, ref i);
            SoundData.ToBytes(bytes, ref i);
            if (header.AckList.Length > 0) { header.AcksToBytes(bytes, ref i); }
            return bytes;
        }
    }

}
